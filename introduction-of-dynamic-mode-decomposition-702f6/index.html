<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>Introduction of Dynamic Mode Decomposition | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Introduction of Dynamic Mode Decomposition</h1>
<p>
  <small class="text-secondary">
  
  
  Nov 30, 2019
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/scipy">scipy</a></code></small>


<small><code><a href="https://memotut.com/tags/numpy">numpy</a></code></small>


<small><code><a href="https://memotut.com/tags/dmd">dmd</a></code></small>


<small><code><a href="https://memotut.com/tags/python3">Python3</a></code></small>

</p>
<pre><code>#Introduction
</code></pre>
<p>I could only think of Fourier transform or wavelet transform as the method of investigating temporal changes, but I learned that there is a good method called dynamic mode decomposition (DMD) that can extract modes in both temporal and spatial directions. I will record it here in order to deepen my understanding.</p>
<p>The content is almost the same as the reference site, but I will write a slightly translated Google translation. The code related to graph drawing is not included in the reference, so I added it. You should be able to execute DMD execution to graph drawing as it is.</p>
<p>#Reference
For simplicity, we omit the DMD of the 3D vector field and consider only a simple 1D scalar function.
<a href="http://www.pyrunner.com/weblog/2016/07/25/dmd-python/">Dynamic Mode Decomposition in Python</a></p>
<p>I didn&rsquo;t know SVD either, so I used this as a reference.
<a href="https://qiita.com/horiem/items/71380db4b659fb9307b4">About the relationship between PCA and SVD</a></p>
<h2 id="dynamic-mode-decomposition">Dynamic mode decomposition</h2>
<p>Dynamic Mode Decomposition (DMD) is a relatively recent mathematical innovation that can solve or approximate dynamic systems, especially with respect to coherent structures that grow, decay, and/or oscillate in time. The coherent structure is called DMD mode. Each DMD mode has a corresponding time dynamics defined on a single eigenvalue.</p>
<p>In other words, DMD transforms a dynamic system into a superposition of modes whose dynamics are dominated by eigenvalues.</p>
<p>Surprisingly, the mathematical procedure for identifying DMD modes and eigenvalues is purely linear, but the system itself can be nonlinear. Although not covered here, there is sound rationale for asserting that a nonlinear system can be described by a set of mode and eigenvalue pairs. For more information, read the paper on the integration of Koopman operators and DMD <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>.</p>
<p>The DMD is not only a useful diagnostic tool for analyzing the internal workings of the system, but it can also be used to predict the future state of the system. Only the mode and eigenvalues are needed. With little effort, you can combine modes and eigenvalues to generate a function that approximates the system state at any time.</p>
<h2 id="official-definition">Official definition</h2>
<p>Consider n datasets.
$${(x_0,y_0),(x_1,y_1),\dots (x_n,y_n)}$$</p>
<p>Where $x_i$ and $y_i$ are each column vectors of size $m$. Define two $m\times n$ matrices.
$$X=[x_0\ x_1\ \dots\ x_n],\quad Y=[y_0\ y_1\ \dots\ y_n]$$</p>
<p>If you define the operator $A$ as
$$A=YX^\dagger$$</p>
<p>Where $X^\dagger$ is the pseudoinverse of $X$ and the dynamic modal decomposition of $(X,Y)$ is given by the eigenvalue decomposition of $A$. So DMD mode and eigenvalues are eigenvectors and eigenvalues of $A$.</p>
<p>The definition by Tu et al. <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> above is known as exact DMD. This is currently the most common definition and can be applied to any dataset that meets your specific requirements. In this article, I&rsquo;m most interested when $A$ satisfies (probably approximately) the expression $y_i=Ax_i$ for every $i$. Or more precisely:
$$Y=AX$$</p>
<p>Clearly $X$ is the set of input vectors and $Y$ is the corresponding set of output vectors. This particular interpretation of DMD is very powerful because it provides a convenient way to analyze (and predict) dynamic stems with unknown governing equations. We will discuss dynamic systems later.</p>
<p>There are several theorems that follow this DMD<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> definition. One of the more useful theorems is that if $X$ and $Y$ are linearly consistent (in other words, when $Xv=0$ for the vector $v$, then always $Yv=0$ $Y=AX$ is completely satisfied only if ($ is also satisfied). As we&rsquo;ll see later, testing for linear consistency is relatively straightforward. In other words, linear consistency is not a mandatory prerequisite for using DMD. Even if the DMD decomposition of $A$ does not completely satisfy the expression $Y=AX$, it is a least-squares method that minimizes the error in the $L^2$ norm.</p>
<h2 id="dmd-algorithm">DMD algorithm</h2>
<p>At first glance, the eigenvalue decomposition of $A=YX^\dagger$ does not seem to be a big problem. In fact, if $X$ and $Y$ are the right size, calling the pinv and eig methods a couple of times from Numpy or MATLAB will work. The problem arises when $A$ is really large. Since $A$ is $m\times m$, if $m$ (the number of signals in each time sample) is very large, then the eigenvalue decomposition becomes awkward.</p>
<p>Fortunately, with the help of the exact DMD algorithm, you can break the problem into smaller pieces.</p>
<ol>
<li>
<p>Compute the SVD (singular value decomposition) of $X$, and at the same time perform lower truncation:
$$X=U\Sigma V^*$$</p>
</li>
<li>
<p>Project the matrix $A$ onto $U$ to compute $\tilde A$:
$$\tilde A=U^* AU=U^*YV\Sigma^{-1}$$</p>
</li>
<li>
<p>Compute the eigenvalue $\lambda_i$ and the eigenvector $w_i$ of $\tilde A$:
$$\tilde AW=W\Lambda$$</p>
</li>
<li>
<p>Reconstruct the eigenvalue decomposition of $A$ from $W$ and $\Lambda$. The eigenvalues of $A$ are equivalent to the eigenvalues of $\tilde A$. The eigenvectors of $A$ are given in the sequence $\Phi$.
$$A\Phi=\Phi\Lambda,\quad \Phi=YV\Sigma^{-1}W$$</p>
</li>
</ol>
<p>A more detailed explanation of the derivation of the algorithm can be found in the references <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>. It may also be theoretically interesting to note that $\Phi=UW$ is an alternative derivation of $\Phi$ called the projected DMD mode. This article uses only exact DMD mode.</p>
<p>Let&rsquo;s step through the algorithm in Python. Start by installing and importing all required packages.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib <span style="color:#f92672">as</span> mpl
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">from</span> mpl_toolkits.mplot3d <span style="color:#f92672">import</span> Axes3D
<span style="color:#f92672">from</span> numpy <span style="color:#f92672">import</span> dot, multiply, diag, power
<span style="color:#f92672">from</span> numpy <span style="color:#f92672">import</span> pi, exp, sin, cos, cosh, tanh, real, imag
<span style="color:#f92672">from</span> numpy.linalg <span style="color:#f92672">import</span> inv, eig, pinv
<span style="color:#f92672">from</span> scipy.linalg <span style="color:#f92672">import</span> svd, svdvals
<span style="color:#f92672">from</span> scipy.integrate <span style="color:#f92672">import</span> odeint, ode, complex_ode
<span style="color:#f92672">from</span> warnings <span style="color:#f92672">import</span> warn

<span style="color:#75715e"># This is my favorite</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;font.family&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Times New Roman&#34;</span> <span style="color:#75715e"># Set global font</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;xtick.direction&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;in&#34;</span> <span style="color:#75715e">#x axis tick lines inward</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;ytick.direction&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;in&#34;</span> <span style="color:#75715e">#y axis graduation lines inward</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;xtick.minor.visible&#34;</span>] <span style="color:#f92672">=</span> True <span style="color:#75715e"># Add x-axis minor tick marks</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;ytick.minor.visible&#34;</span>] <span style="color:#f92672">=</span> True <span style="color:#75715e"># Add y-axis minor tick marks</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;xtick.major.width&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.5</span> <span style="color:#75715e"># Line width of x-axis major tick lines</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;ytick.major.width&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.5</span> <span style="color:#75715e">#y-axis major tick line width</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;xtick.minor.width&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#75715e"># Width of the x-axis minor tick marks</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;ytick.minor.width&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#75715e">#y-axis auxiliary scale line width</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;xtick.major.size&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e"># x-axis major tick line length</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;ytick.major.size&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">#y axis major tick line length</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;xtick.minor.size&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#75715e"># x-axis minor scale line length</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;ytick.minor.size&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#75715e"># y-axis minor scale line length</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;font.size&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">14</span> <span style="color:#75715e"># font size</span>
plt<span style="color:#f92672">.</span>rcParams[<span style="color:#e6db74">&#34;axes.linewidth&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.5</span> <span style="color:#75715e"># Box thickness</span>
</code></pre></div><p>Let&rsquo;s generate some play data. Note that in practice you don&rsquo;t necessarily know the governing equations for your data. Here we are creating some equations to create the dataset. Once the data is generated, forget that they exist.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#Define time domain and space domain</span>
x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">100</span>)
t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span><span style="color:#f92672">*</span>pi, <span style="color:#ae81ff">80</span>)
dt <span style="color:#f92672">=</span> t[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">-</span>t[<span style="color:#ae81ff">1</span>]
Xm,Tm <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>meshgrid(x, t)

<span style="color:#75715e"># Create 3 time and space patterns</span>
f1 <span style="color:#f92672">=</span> multiply(<span style="color:#ae81ff">20</span><span style="color:#f92672">-</span><span style="color:#ae81ff">0.2</span><span style="color:#f92672">*</span>power(Xm, <span style="color:#ae81ff">2</span>), exp((<span style="color:#ae81ff">2.3j</span>)<span style="color:#f92672">*</span>Tm))
f2 <span style="color:#f92672">=</span> multiply(Xm, exp(<span style="color:#ae81ff">0.6j</span><span style="color:#f92672">*</span>Tm))
f3 <span style="color:#f92672">=</span> multiply(<span style="color:#ae81ff">5</span><span style="color:#f92672">*</span>multiply(<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>cosh(Xm<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>), tanh(Xm<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)), <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>exp((<span style="color:#ae81ff">0.1</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2.8j</span>)<span style="color:#f92672">*</span>Tm))

<span style="color:#75715e"># Combine signals to create a data matrix</span>
D <span style="color:#f92672">=</span> (f1 <span style="color:#f92672">+</span> f2 <span style="color:#f92672">+</span> f3)<span style="color:#f92672">.</span>T

<span style="color:#75715e">#Create DMD input/output matrix</span>
X <span style="color:#f92672">=</span> D[:,:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
Y <span style="color:#f92672">=</span> D[:,<span style="color:#ae81ff">1</span>:]
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">6</span>))
ax <span style="color:#f92672">=</span> fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">111</span>, projection<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;3d&#34;</span>)
surf <span style="color:#f92672">=</span> ax<span style="color:#f92672">.</span>plot_surface(Xm, Tm, np<span style="color:#f92672">.</span>real(D<span style="color:#f92672">.</span>T), cmap<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;gray&#34;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;x&#34;</span>)
ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;t&#34;</span>)
fig<span style="color:#f92672">.</span>colorbar(surf)
<span style="color:#e6db74">``</span><span style="color:#960050;background-color:#1e0010">`!</span>[output_8_1<span style="color:#f92672">.</span>png](https:<span style="color:#f92672">//</span>qiita<span style="color:#f92672">-</span>image<span style="color:#f92672">-</span>store<span style="color:#f92672">.</span>s3<span style="color:#f92672">.</span>ap<span style="color:#f92672">-</span>northeast<span style="color:#f92672">-</span><span style="color:#ae81ff">1.</span>amazonaws<span style="color:#f92672">.</span>com<span style="color:#f92672">/</span><span style="color:#ae81ff">0</span><span style="color:#f92672">/</span><span style="color:#ae81ff">455608</span><span style="color:#f92672">/</span>eee95cdc<span style="color:#f92672">-</span>e1fb<span style="color:#f92672">-</span>f4eb<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>f3c<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>c97c67c34bd<span style="color:#f92672">.</span>png)

Now calculate the SVD of <span style="color:#960050;background-color:#1e0010">$</span>X<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#f92672">.</span> The first variable of primary interest <span style="color:#f92672">is</span> <span style="color:#960050;background-color:#1e0010">$</span>\Sigma<span style="color:#960050;background-color:#1e0010">$</span>, which <span style="color:#f92672">is</span> the singular value of <span style="color:#960050;background-color:#1e0010">$</span>X<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#f92672">.</span> Once we have the SVD of <span style="color:#960050;background-color:#1e0010">$</span>X<span style="color:#960050;background-color:#1e0010">$</span>, we can extract the <span style="color:#e6db74">&#34;high energy&#34;</span> modes <span style="color:#f92672">and</span> reduce the system dimension <span style="color:#66d9ef">with</span> a proper orthogonal decomposition (Proper Orthogonal Decomposition, POD)<span style="color:#f92672">.</span> Looking at the singular values determines the number of modes to truncate<span style="color:#f92672">.</span>

<span style="color:#e6db74">``</span><span style="color:#960050;background-color:#1e0010">`</span>python
<span style="color:#75715e"># SVD of input matrix</span>
U2,Sig2,Vh2 <span style="color:#f92672">=</span> svd(X, False)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots()
ax<span style="color:#f92672">.</span>scatter(range(len(Sig2)), Sig2, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;singular values&#34;</span>)
ax<span style="color:#f92672">.</span>legend()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/6c35102f-7850-ed66-e775-880de9789c8d.png" alt="output_11_1.png"></p>
<p>Given the singular values above, we can conclude that the data has three important modes. Therefore, truncate the SVD to include only these modes. Then build $\tilde A$ and find its eigenvalue decomposition.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#Rank 3 rounded down</span>
r <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
U <span style="color:#f92672">=</span> U2[:,:r]
Sig <span style="color:#f92672">=</span> diag(Sig2)[:r,:r]
V <span style="color:#f92672">=</span> Vh2<span style="color:#f92672">.</span>conj()<span style="color:#f92672">.</span>T[:,:r]

Build <span style="color:#75715e">#A~</span>
Atil <span style="color:#f92672">=</span> dot(dot(dot(U<span style="color:#f92672">.</span>conj()<span style="color:#f92672">.</span>T, Y), V), inv(Sig))
mu,W <span style="color:#f92672">=</span> eig(Atil)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">circle</span>(r<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>):
    x,y <span style="color:#f92672">=</span> [],[]
    <span style="color:#66d9ef">for</span> _x <span style="color:#f92672">in</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">180</span>,<span style="color:#ae81ff">180</span>,<span style="color:#ae81ff">360</span>):
        x<span style="color:#f92672">.</span>append(np<span style="color:#f92672">.</span>sin(np<span style="color:#f92672">.</span>radians(_x)))
        y<span style="color:#f92672">.</span>append(np<span style="color:#f92672">.</span>cos(np<span style="color:#f92672">.</span>radians(_x)))
    <span style="color:#66d9ef">return</span> x,y

c_x,c_y <span style="color:#f92672">=</span> circle(r<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)

fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">8</span>))
ax<span style="color:#f92672">.</span>plot(c_x, c_y, c<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;k&#34;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dashed&#34;</span>)
ax<span style="color:#f92672">.</span>scatter(np<span style="color:#f92672">.</span>real(mu[<span style="color:#ae81ff">0</span>]), np<span style="color:#f92672">.</span>imag(mu[<span style="color:#ae81ff">0</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1st&#34;</span>)
ax<span style="color:#f92672">.</span>scatter(np<span style="color:#f92672">.</span>real(mu[<span style="color:#ae81ff">1</span>]), np<span style="color:#f92672">.</span>imag(mu[<span style="color:#ae81ff">1</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;2nd&#34;</span>)
ax<span style="color:#f92672">.</span>scatter(np<span style="color:#f92672">.</span>real(mu[<span style="color:#ae81ff">2</span>]), np<span style="color:#f92672">.</span>imag(mu[<span style="color:#ae81ff">2</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;3rd&#34;</span>)
ax<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#34;equal&#34;</span>)
ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\it{Re}\,\mu$&#34;</span>)
ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\it{Im}\,\mu$&#34;</span>)
ax<span style="color:#f92672">.</span>legend()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/b2735bc4-67a5-3c53-3c2b-dc8c79a975e7.png" alt="output_14_1.png"></p>
<p>Each eigenvalue of $\Lambda$ tells us about the dynamic behavior of the corresponding DMD mode. Its exact interpretation depends on the nature of the relationship between $X$ and $Y$. In the case of difference equations, many conclusions can be drawn. If the eigenvalue has a non-zero imaginary part, then there is oscillation in the corresponding DMD mode. If the eigenvalues are within the unit circle, the mode is damped. If the eigenvalues are outside, then the mode is growing. If the eigenvalues fit the unit circle exactly, then the mode neither grows nor decays.</p>
<p>Then build exact DMD mode.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Build DMD mode</span>
Phi <span style="color:#f92672">=</span> dot(dot(dot(Y, V), inv(Sig)), W)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots()
ax<span style="color:#f92672">.</span>plot(x, np<span style="color:#f92672">.</span>real(Phi[:,<span style="color:#ae81ff">0</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1st mode&#34;</span>)
ax<span style="color:#f92672">.</span>plot(x, np<span style="color:#f92672">.</span>real(Phi[:,<span style="color:#ae81ff">1</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;2nd mode&#34;</span>)
ax<span style="color:#f92672">.</span>plot(x, np<span style="color:#f92672">.</span>real(Phi[:,<span style="color:#ae81ff">2</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;3rd mode&#34;</span>)
ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;x&#34;</span>)
ax<span style="color:#f92672">.</span>legend()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/22174fba-2e26-54f4-e327-6bfa830baded.png" alt="output_18_1.png"></p>
<p>The $\Phi$ column is the DMD mode plotted above. They are a consistent structure that grows/damps/oscillates in the system according to different time dynamics. Compare the curves in the plot above to the rotating, evolving shapes found in the original 3D surface plot. You will notice similarities.</p>
<p>This is the technical end of the DMD algorithm. With a basic understanding of the eigenvalue decomposition of $A$ and the nature of the system $Y=AX$, we can construct the matrix $\Psi$ corresponding to the time evolution of the system. To fully understand the code below, look at the difference equation function $x(t)$ in the next section.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#Calculation of time evolution</span>
b <span style="color:#f92672">=</span> dot(pinv(Phi), X[:,<span style="color:#ae81ff">0</span>])
Psi <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros([r, len(t)], dtype<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;complex&#39;</span>)
<span style="color:#66d9ef">for</span> i,_t <span style="color:#f92672">in</span> enumerate(t):
    Psi[:,i] <span style="color:#f92672">=</span> multiply(power(mu, _t<span style="color:#f92672">/</span>dt), b)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>))
ax1,ax2,ax3 <span style="color:#f92672">=</span> fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">311</span>), fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">312</span>), fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">313</span>)
plt<span style="color:#f92672">.</span>subplots_adjust(wspace<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, hspace<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
ax1<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;1st mode&#34;</span>), ax2<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;2nd mode&#34;</span>), ax3<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;3rd mode&#34;</span>)

ax1<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>real(Psi[<span style="color:#ae81ff">0</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\it{Re}\,\Psi$&#34;</span>)
ax1<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>imag(Psi[<span style="color:#ae81ff">0</span>]), label<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\it{Re}\,\Psi$&#34;</span>)
ax2<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>real(Psi[<span style="color:#ae81ff">1</span>])), ax2<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>imag(Psi[<span style="color:#ae81ff">1</span>]))
ax3<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>real(Psi[<span style="color:#ae81ff">2</span>])), ax3<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>imag(Psi[<span style="color:#ae81ff">2</span>]))
ax3<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;t&#34;</span>)

fig<span style="color:#f92672">.</span>legend()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/1e17fdf9-0cb3-4a87-f1f9-08a444d176b4.png" alt="output_22_1.png"></p>
<p>The three plots above are the time dynamics of the three DMD modes. Notice that all three are vibrating. In addition, the second mode appears to grow exponentially. This is confirmed by the eigenvalue plot.</p>
<p>To create a fit of the original data matrix, simply multiply $\Phi$ by $\Psi$. In this particular case, the fit exactly matches the original.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># DMD reconstruction calculation</span>
D2 <span style="color:#f92672">=</span> dot(Phi, Psi)
np<span style="color:#f92672">.</span>allclose(D, D2) <span style="color:#75715e"># True</span>
</code></pre></div><h2 id="dynamic-system">Dynamic system</h2>
<p>In this article, we will consider only two interpretations of the expression $Y=AX$. The first interpretation is where $A$ defines the difference equation
$$x_{i+1}=Ax_i$$</p>
<p>In this case, the operator $A$ advances the dynamic system state $x_i$ one step in time. Let&rsquo;s say you have a time series $D$.
$$D=[x_0\ x_1\ \dots\ x_{n+1}]$$</p>
<p>Where $x_i$ is a column vector that defines the $m$ dimensional state of the system at time step $i$. Then you can define $X$ and $Y$ as follows:
$$X=[x_0\ x_1\ \dots\ x_{n}],\quad Y=[x_1\ x_2\ \dots\ x_{n+1}]$$</p>
<p>Thus, each pair of $X$ and $Y$ column vectors corresponds to one iteration of the difference equation, which is generally
$$Y=AX$$</p>
<p>Use DMD to find the unique decomposition of $A\Phi=\Phi\Lambda$. Using DMD mode and eigenvalues, you can easily transform $Y=AX$ into a function defined by discrete-time iteration $k$ with time step $\Delta t$.
$$x_k=\Phi\Lambda^k\Phi^\dagger x_0$$</p>
<p>The corresponding function for continuous time $t$ is
$$x(t)=\Phi\Lambda^{t/\Delta t}\Phi^\dagger x(0)$$</p>
<p>What&rsquo;s really amazing is that I defined an explicit function in time using only the data. This is a good example of equationless modeling.</p>
<p>The second interpretation of $Y=AX$ considered in this article is where $A$ defines the system of differential equations.
$$\dot x=Ax$$</p>
<p>In this case, the operator $A$ computes the first derivative with respect to time of the vector $x_i$. The matrices $X$ and $Y$ consist of $n$ samples of the vector field. The $i$th column of $X$ is the position vector $x_i$. The $i$th column of $Y$ is the velocity vector $\dot x_i$.</p>
<p>After calculating the DMD, the function of time is very similar to the previous one (ie the difference equation). If $x(0)$ is any initial condition and $t$ is continuous time,
$$x(t)=\Phi\text{exp}(\Lambda t)\Phi^\dagger x(0)$$</p>
<h2 id="helper-method">Helper method</h2>
<p>For convenience, I put the DMD code in one method and define some helper methods to check the linear consistency and confirm the solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nullspace</span>(A, atol<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-13</span>, rtol<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
    <span style="color:#75715e"># from http://scipy-cookbook.readthedocs.io/items/RankNullspace.html</span>
    A <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>atleast_2d(A)
    u, s, vh <span style="color:#f92672">=</span> svd(A)
    tol <span style="color:#f92672">=</span> max(atol, rtol <span style="color:#f92672">*</span> s[<span style="color:#ae81ff">0</span>])
    nnz <span style="color:#f92672">=</span> (s <span style="color:#f92672">&gt;=</span> tol)<span style="color:#f92672">.</span>sum()
    ns <span style="color:#f92672">=</span> vh[nnz:]<span style="color:#f92672">.</span>conj()<span style="color:#f92672">.</span>T
    <span style="color:#66d9ef">return</span> ns

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_linear_consistency</span>(X, Y, show_warning<span style="color:#f92672">=</span>True):<span style="color:#75715e"># tests linear consistency of two matrices (i.e., whenever Xc=0, then Yc=0)</span>
    A <span style="color:#f92672">=</span> dot(Y, nullspace(X))
    total <span style="color:#f92672">=</span> A<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]
    z <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros([total, <span style="color:#ae81ff">1</span>])
    fails <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(total):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> np<span style="color:#f92672">.</span>allclose(z, A[:,i]):
            fails <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">if</span> fails <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> show_warning:
        warn(<span style="color:#e6db74">&#39;linear consistency check failed {} out of {}&#39;</span><span style="color:#f92672">.</span>format(fails, total))
    <span style="color:#66d9ef">return</span> fails, total

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dmd</span>(X, Y, truncate<span style="color:#f92672">=</span>None):
    U2,Sig2,Vh2 <span style="color:#f92672">=</span> svd(X, False) <span style="color:#75715e"># SVD of input matrix</span>
    r <span style="color:#f92672">=</span> len(Sig2) <span style="color:#66d9ef">if</span> truncate <span style="color:#f92672">is</span> None <span style="color:#66d9ef">else</span> truncate <span style="color:#75715e"># rank truncation</span>
    U <span style="color:#f92672">=</span> U2[:,:r]
    Sig <span style="color:#f92672">=</span> diag(Sig2)[:r,:r]
    V <span style="color:#f92672">=</span> Vh2<span style="color:#f92672">.</span>conj()<span style="color:#f92672">.</span>T[:,:r]
    Atil <span style="color:#f92672">=</span> dot(dot(dot(U<span style="color:#f92672">.</span>conj()<span style="color:#f92672">.</span>T, Y), V), inv(Sig)) <span style="color:#75715e"># build A tilde</span>
    mu,W <span style="color:#f92672">=</span> eig(Atil)
    Phi <span style="color:#f92672">=</span> dot(dot(dot(Y, V), inv(Sig)), W) <span style="color:#75715e"># build DMD modes</span>
    <span style="color:#66d9ef">return</span> mu, Phi

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check_dmd_result</span>(X, Y, mu, Phi, show_warning<span style="color:#f92672">=</span>True):
    b <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>allclose(Y, dot(dot(dot(Phi, diag(mu)), pinv(Phi)), X))
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> b <span style="color:#f92672">and</span> show_warning:
        warn(<span style="color:#e6db74">&#39;dmd result does not satisfy Y=AX&#39;</span>)
</code></pre></div><h2 id="制限事項">制限事項</h2>
<p>DMDにはいくつかの既知の制限があります。 まず第一に、並進および回転の不変性を特にうまく処理できません。 第二に、一時的な時間動作が存在する場合、完全に失敗する可能性があります。 次の例は、これらの問題を示しています。</p>
<h3 id="1-並進不変性">1. 並進不変性</h3>
<p>次のデータセットは非常に単純です。 これは、システムの進化に応じて空間ドメインに沿って並進する単一モード（ガウス）で構成されます。 DMDはこれをきれいに処理すると思うかもしれませんが、逆のことが起こります。 SVDは、明確に定義された単一の特異値を取得する代わりに、多くの値を取得します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 時間領域と空間領域を定義する</span>
x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">50</span>)
t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">100</span>)
dt <span style="color:#f92672">=</span> t[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> t[<span style="color:#ae81ff">1</span>]
Xm,Tm <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>meshgrid(x, t)

<span style="color:#75715e"># 空間的にも時間的にも移動する単一モードでデータを作成する</span>
D <span style="color:#f92672">=</span> exp(<span style="color:#f92672">-</span>power((Xm<span style="color:#f92672">-</span>Tm<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>))
D <span style="color:#f92672">=</span> D<span style="color:#f92672">.</span>T

<span style="color:#75715e"># 入出力行列を抽出する</span>
X <span style="color:#f92672">=</span> D[:,:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
Y <span style="color:#f92672">=</span> D[:,<span style="color:#ae81ff">1</span>:]
check_linear_consistency(X, Y)

U2,Sig2,Vh2 <span style="color:#f92672">=</span> svd(X, False)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">5</span>))
ax1,ax2 <span style="color:#f92672">=</span> fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">121</span>), fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">122</span>)
ax1<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;x&#34;</span>), ax1<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;t&#34;</span>)
ax1<span style="color:#f92672">.</span>imshow(D<span style="color:#f92672">.</span>T, aspect<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
ax2<span style="color:#f92672">.</span>scatter(range(len(Sig2)), Sig2)
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/359c45bd-9056-c1f0-02b3-9591c990fb51.png" alt="output_33_1.png"></p>
<p>左側のプロットは、システムの時間変化を示しています。 右側のプロットは特異値を示しています。 システムを正確に近似するには、10近いDMDモードが必要であることがわかりました。次のプロットを考えてみましょう。真のダイナミクスと、重ね合わせるモードの数を変化させたものを比較します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_dmd_modes</span>(t, X, Y, r):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    DMD再構成
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    mu, Phi <span style="color:#f92672">=</span> dmd(X, Y, truncate<span style="color:#f92672">=</span>r)
    b <span style="color:#f92672">=</span> dot(pinv(Phi), X[:,<span style="color:#ae81ff">0</span>])
    Psi <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros([r, len(t)], dtype<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;complex&#39;</span>)
    <span style="color:#66d9ef">for</span> i,_t <span style="color:#f92672">in</span> enumerate(t):
        Psi[:,i] <span style="color:#f92672">=</span> multiply(power(mu, _t<span style="color:#f92672">/</span>dt), b)
    <span style="color:#66d9ef">return</span> dot(Phi, Psi)

fig <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>))
axes <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">9</span>):
    axes<span style="color:#f92672">.</span>append(fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">331</span><span style="color:#f92672">+</span>i))
plt<span style="color:#f92672">.</span>subplots_adjust(wspace<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, hspace<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)

<span style="color:#66d9ef">for</span> i,ax <span style="color:#f92672">in</span> enumerate(axes):
    ax<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;{} modes&#34;</span><span style="color:#f92672">.</span>format(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
    ax<span style="color:#f92672">.</span>imshow(np<span style="color:#f92672">.</span>real(build_dmd_modes(t, X, Y, r<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>T), aspect<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/d569ea29-ed67-f1f4-bc14-32d5ec597c6e.png" alt="output_36_0.png"></p>
<h3 id="2-過渡時間の挙動">2. 過渡時間の挙動</h3>
<p>この最後の例では、一時的な時間のダイナミクスを含むデータセットを調べます。 具体的には、データにガウスが存在する場合と存在しない場合を示しています。 残念ながら、DMDはこのデータを正確に分解できません。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 時間領域と空間領域を定義する</span>
x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">50</span>)
t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">100</span>)
dt <span style="color:#f92672">=</span> t[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> t[<span style="color:#ae81ff">1</span>]
Xm,Tm <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>meshgrid(x, t)

<span style="color:#75715e"># 単一の一時モードでデータを作成する</span>
D <span style="color:#f92672">=</span> exp(<span style="color:#f92672">-</span>power((Xm)<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>)) <span style="color:#f92672">*</span> exp(<span style="color:#f92672">-</span>power((Tm<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>))
D <span style="color:#f92672">=</span> D<span style="color:#f92672">.</span>astype(<span style="color:#e6db74">&#39;complex&#39;</span>)<span style="color:#f92672">.</span>T

<span style="color:#75715e"># 入出力行列を抽出する</span>
X <span style="color:#f92672">=</span> D[:,:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
Y <span style="color:#f92672">=</span> D[:,<span style="color:#ae81ff">1</span>:]
check_linear_consistency(X, Y)

<span style="color:#75715e"># DMD分解</span>
r <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
mu,Phi <span style="color:#f92672">=</span> dmd(X, Y, r)
check_dmd_result(X, Y, mu, Phi)

<span style="color:#75715e"># 時間発展</span>
b <span style="color:#f92672">=</span> dot(pinv(Phi), X[:,<span style="color:#ae81ff">0</span>])
Psi <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros([r, len(t)], dtype<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;complex&#39;</span>)
<span style="color:#66d9ef">for</span> i,_t <span style="color:#f92672">in</span> enumerate(t):
    Psi[:,i] <span style="color:#f92672">=</span> multiply(power(mu, _t<span style="color:#f92672">/</span>dt), b)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">fig <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>))
ax1,ax2 <span style="color:#f92672">=</span> fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">221</span>),fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">222</span>)
ax3,ax4 <span style="color:#f92672">=</span> fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">223</span>),fig<span style="color:#f92672">.</span>add_subplot(<span style="color:#ae81ff">224</span>)

ax1<span style="color:#f92672">.</span>imshow(np<span style="color:#f92672">.</span>real(D), aspect<span style="color:#f92672">=</span><span style="color:#ae81ff">2.0</span>), ax1<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;True&#34;</span>)
ax2<span style="color:#f92672">.</span>imshow(np<span style="color:#f92672">.</span>real(dot(Phi, Psi)<span style="color:#f92672">.</span>T), aspect<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>), ax2<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;1-mode approx.&#34;</span>)
ax3<span style="color:#f92672">.</span>plot(x, np<span style="color:#f92672">.</span>real(Phi)), ax3<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;x&#34;</span>), ax3<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;mode1&#34;</span>)
ax4<span style="color:#f92672">.</span>plot(t, np<span style="color:#f92672">.</span>real(Psi[<span style="color:#ae81ff">0</span>])), ax3<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;t&#34;</span>), ax4<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;time evol. of mode 1&#34;</span>)
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/455608/d59b538c-09b9-36f5-5b49-de716045d445.png" alt="output_39_1.png"></p>
<p>DMDはモードを正しく識別しますが、時間の振る舞いを完全に識別することはできません。 これは、DMD時系列の時間挙動が固有値に依存していることを考慮すると理解できます。固有値は、指数関数的成長（固有値の実数部）と振動（虚数部）の組み合わせのみを特徴付けることができます。</p>
<p>このシステムの興味深い点は、理想的な分解がさまざまな固有値を持つ単一モード（図に示すように）の重ね合わせで構成される可能性があることです。 単一のモードに、真の時間ダイナミクスを近似する多くの直交サインとコサインの線形結合（フーリエ級数）が掛けられていると想像してください。 残念ながら、SVDベースのDMDの単一のアプリケーションでは、異なる固有値で同じDMDモードを何度も生成することはできません。</p>
<p>さらに、時間の振る舞いを多数の固有値として正しく抽出できたとしても、過渡的な振る舞い自体を完全に理解しないと、解の予測機能は信頼できないことに注意することが重要です。 一時的な動作は、その性質上、永続的ではありません。</p>
<p>多重解像度DMD（mrDMD）は、DMDを再帰的に適用することにより、一時的な時間動作の問題を軽減しようとしています。</p>
<h2 id="結言">結言</h2>
<p>その制限にもかかわらず、DMDは動的システムを分析および予測するための非常に強力なツールです。 すべてのバックグラウンドのすべてのデータサイエンティストは、DMDとその適用方法について十分に理解している必要があります。 この記事の目的は、DMDの背後にある理論を提供し、実際のデータで使用できる実用的なPythonのコード例を提供することです。 DMDの正式な定義を検討し、アルゴリズムを段階的に説明し、失敗した例を含むいくつかの簡単な使用例を試してみました。これにより、DMDが研究プロジェクトまたはエンジニアリングプロジェクトにどのように適用されるかについて、より明確な理解が得られることを願っています。</p>
<p>DMDには多くの拡張機能があります。 将来の作業では、多解像度DMD（mrDMD）やスパースDMD（sDMD）など、これらの拡張機能の一部に関する投稿が行われる可能性があります。</p>
<h1 id="まとめif-you-want-to-dmd-the-time-evolution-of-a-2d-array-like-a-high-speed-camera-image-flatten-the-2d-array-into-a-1d-array-and-the-above-code-will-work-ill-add-an-example-of-dmd-of-a-cfd-simulation-of-karman-vortex">まとめIf you want to DMD the time evolution of a 2D array like a high speed camera image, flatten the 2D array into a 1D array and the above code will work. I&rsquo;ll add an example of DMD of a CFD simulation of Karman vortex.</h1>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>&ldquo;Kutz, J. Nathan. Data-driven modeling &amp; scientific computation: methods for complex systems &amp; big data. OUP Oxford, 2013&rdquo; <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>&ldquo;Tu, Jonathan H., et al. “On dynamic mode decomposition: theory and applications.” arXiv preprint arXiv:1312.0041 (2013).” <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>&ldquo;Wikipedia contributors. “Composition operator.” Wikipedia, The Free Encyclopedia. Wikipedia, The Free Encyclopedia, 28 Dec. 2015. Web. 24 Jul. 2016.&rdquo; <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
