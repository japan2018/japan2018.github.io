<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>Answers and impressions of 100 language processing knocks-Part 2 | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Answers and impressions of 100 language processing knocks-Part 2</h1>
<p>
  <small class="text-secondary">
  
  
  Dec 19, 2019
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/natural-language-processing"> natural language processing</a></code></small>


<small><code><a href="https://memotut.com/tags/language-processing-100-knocks"> language processing 100 knocks</a></code></small>

</p>
<pre><code>advent calendar day 17
</code></pre>
<p>I&rsquo;m late .. ..</p>
<h2 id="this-is">this is</h2>
<p><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/">Language processing 100 knocks</a>Isolvedit,soIwillwriteoneanswerandoneimpression(secondpart)
It took a lot more time than last time ~~~</p>
<h2 id="assumptions">Assumptions</h2>
<p>Environment etc. <a href="https://qiita.com/sh05_sh05/items/234e734cfceaa928bdba">here</a>(previouslink)</p>
<h2 id="main-story">Main story</h2>
<h3 id="chapter-5-dependency-analysis">Chapter 5: Dependency Analysis</h3>
<blockquote>
<p>Use Sobo Natsume&rsquo;s novel &ldquo;I am a cat&rdquo; (neko.txt) for dependency analysis using CaboCha, and save the result in a file called neko.txt.cabocha. Use this file to implement the program corresponding to the following questions.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> CaboCha
c <span style="color:#f92672">=</span> CaboCha<span style="color:#f92672">.</span>Parser()
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./neko.txt&#39;</span>) <span style="color:#66d9ef">as</span> f:
    text <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./neko.txt.cabocha&#39;</span>, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;w&#39;</span>) <span style="color:#66d9ef">as</span> f:
    <span style="color:#66d9ef">for</span> se <span style="color:#f92672">in</span> [s <span style="color:#f92672">+</span><span style="color:#e6db74">&#39;. &#39;</span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> text<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;.&#39;</span>)]:
        f<span style="color:#f92672">.</span>write(c<span style="color:#f92672">.</span>parse(se )<span style="color:#f92672">.</span>toString(CaboCha<span style="color:#f92672">.</span>FORMAT_LATTICE))
</code></pre></div><p>Actually, this is the first dependency analysis so I did a lot of research on this alone</p>
<h4 id="40-read-dependency-analysis-result-morpheme">40 Read dependency analysis result (morpheme)</h4>
<blockquote>
<p>Implement Morph, a class that represents morphemes. This class has surface variables (surface), basic words (base), part-of-speech (pos), and part-of-speech subclassification 1 (pos1) as member variables. Furthermore, read the analysis result of CaboCha (neko.txt.cabocha), express each sentence as a list of Morph objects, and display the morpheme sequence of the third sentence.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#40</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Morph</span>:
    <span style="color:#66d9ef">def</span> __init__(self, surface, base, pos, pos1):
        self<span style="color:#f92672">.</span>surface <span style="color:#f92672">=</span> surface
        self<span style="color:#f92672">.</span>base <span style="color:#f92672">=</span> base
        self<span style="color:#f92672">.</span>pos <span style="color:#f92672">=</span> pos
        self<span style="color:#f92672">.</span>pos1 <span style="color:#f92672">=</span> pos1

doc <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./neko.txt.cabocha&#39;</span>) <span style="color:#66d9ef">as</span> f:
    sentence <span style="color:#f92672">=</span> []
    line <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readline()
    <span style="color:#66d9ef">while</span>(line):
        <span style="color:#66d9ef">while</span>(<span style="color:#e6db74">&#39;EOS&#39;</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> line):
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> line<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;*&#39;</span>):
                cols <span style="color:#f92672">=</span> line<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>)
                m <span style="color:#f92672">=</span> Morph(
                    surface<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">0</span>],
                    base<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>],
                    pos<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#ae81ff">0</span>],
                    pos1<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#ae81ff">1</span>],
                )
                sentence<span style="color:#f92672">.</span>append(m)
            line <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readline()
        doc<span style="color:#f92672">.</span>append(sentence)
        sentence <span style="color:#f92672">=</span> []
        line <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readline()
<span style="color:#66d9ef">print</span>([t<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> doc[<span style="color:#ae81ff">2</span>]])
</code></pre></div><p>Do it while checking the output format of CaboCha</p>
<h4 id="41-read-dependency-analysis-result-phrasedependency">41 Read dependency analysis result (Phrase/Dependency)</h4>
<p>In addition to &gt;40, implement the class Chunk that represents clauses. This class has a list of morphemes (Morph objects) (morphs), a dependent clause index number (dst), and a list of dependent clause index numbers (srcs) as member variables. Furthermore, read the analysis result of CaboCha of the input text, express one sentence as a list of Chunk objects, and display the character string of the eighth sentence and the destination. For the rest of Chapter 5, use the program you created here.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 41</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Chunk</span>:
    <span style="color:#66d9ef">def</span> __init__(self, morphs, dst, srcs):
        self<span style="color:#f92672">.</span>morphs <span style="color:#f92672">=</span> morphs
        self<span style="color:#f92672">.</span>dst <span style="color:#f92672">=</span> dst
        self<span style="color:#f92672">.</span>srcs <span style="color:#f92672">=</span> srcs
        
doc <span style="color:#f92672">=</span> []
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;./neko.txt.cabocha&#39;</span>) <span style="color:#66d9ef">as</span> f:
    sentence <span style="color:#f92672">=</span> []
    line <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readline()
    <span style="color:#66d9ef">while</span>(line):
        <span style="color:#66d9ef">if</span> line<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;*&#39;</span>):
            cols <span style="color:#f92672">=</span> line<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;&#39;</span>)
            <span style="color:#75715e"># Do not include the one on the previous line of EOS</span>
            <span style="color:#66d9ef">if</span> cols[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span>:
                sentence<span style="color:#f92672">.</span>append(c)
            c <span style="color:#f92672">=</span> Chunk(
                morphs<span style="color:#f92672">=</span>[],
                dst<span style="color:#f92672">=</span>int(cols[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;D&#39;</span>)[<span style="color:#ae81ff">0</span>]),
                srcs<span style="color:#f92672">=</span>[]
            )
        <span style="color:#66d9ef">elif</span><span style="color:#e6db74">&#39;EOS&#39;</span> <span style="color:#f92672">in</span> line:
            sentence<span style="color:#f92672">.</span>append(c)
            <span style="color:#75715e">#Processing to find what it takes</span>
            <span style="color:#66d9ef">for</span> i, c <span style="color:#f92672">in</span> enumerate(sentence):
                c<span style="color:#f92672">.</span>srcs <span style="color:#f92672">=</span> [idx <span style="color:#66d9ef">for</span> idx, chk, <span style="color:#f92672">in</span> enumerate(sentence) <span style="color:#66d9ef">if</span> chk<span style="color:#f92672">.</span>dst <span style="color:#f92672">==</span> i]
                
            doc<span style="color:#f92672">.</span>append(sentence)
            sentence <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">else</span>:
            cols <span style="color:#f92672">=</span> line<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>)
            <span style="color:#66d9ef">if</span> cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;symbol&#34;</span>:
                m <span style="color:#f92672">=</span> Morph(
                    surface<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">0</span>],
                    base<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>],
                    pos<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#ae81ff">0</span>],
                    pos1<span style="color:#f92672">=</span>cols[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;,&#39;</span>)[<span style="color:#ae81ff">1</span>],
                )
                c<span style="color:#f92672">.</span>morphs<span style="color:#f92672">.</span>append(m)
        line <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readline()
<span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> doc[<span style="color:#ae81ff">7</span>]:
    <span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>dst, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;,&#39;</span>)
    <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs:
        <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>surface, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
    <span style="color:#66d9ef">print</span>()
<span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> doc[<span style="color:#ae81ff">0</span>]:
    <span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>dst, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;,&#39;</span>)
    <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs:
        <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>surface)
        <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>pos)
    <span style="color:#66d9ef">print</span>()
</code></pre></div><p>I was thinking about how to find the phrase that is relevant to me, but I couldn&rsquo;t think of a good one, so I simply looped and scanned.</p>
<h4 id="42-display-of-source-and-destination-clauses">42 Display of source and destination clauses</h4>
<blockquote>
<p>Extract all the text of the source clause and the destination clause in tab delimited format. However, do not output symbols such as punctuation marks.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#42</span>
<span style="color:#75715e"># 50 for all because jupyter(chrome) is solidified</span>
<span style="color:#66d9ef">for</span> i, d <span style="color:#f92672">in</span> enumerate(doc[:<span style="color:#ae81ff">50</span>]):
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> d:
        <span style="color:#66d9ef">if</span> int(c<span style="color:#f92672">.</span>dst) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">continue</span>
        <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs:
            <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;symbol&#39;</span>:
                <span style="color:#66d9ef">continue</span>
            <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>surface, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
        <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> d[c<span style="color:#f92672">.</span>dst]<span style="color:#f92672">.</span>morphs:
            <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;symbol&#39;</span>:
                <span style="color:#66d9ef">continue</span>
            <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>surface, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
        <span style="color:#66d9ef">print</span>()
</code></pre></div><p>Do while paying attention to sentences, clauses, and morphemes</p>
<h4 id="43-extract-bunsetsu-that-includes-nouns-related-to-bunsetsu-that-includes-verbs">43 Extract bunsetsu that includes nouns related to bunsetsu that includes verbs</h4>
<blockquote>
<p>When a phrase containing a noun relates to a phrase containing a verb, extract them in a tab-delimited format. However, do not output symbols such as punctuation marks.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#43</span>
<span style="color:#75715e"># 50 for all because jupyter(chrome) is solidified</span>
<span style="color:#66d9ef">for</span> i, d <span style="color:#f92672">in</span> enumerate(doc[:<span style="color:#ae81ff">50</span>]):
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> d:
        <span style="color:#66d9ef">if</span> int(c<span style="color:#f92672">.</span>dst) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">continue</span>
        contain_noun <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;noun&#39;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs]
        contain_verb <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;verb&#39;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> d[c<span style="color:#f92672">.</span>dst]<span style="color:#f92672">.</span>morphs]
        <span style="color:#66d9ef">if</span> contain_noun <span style="color:#f92672">and</span> contain_verb:
            <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs:
                <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;symbol&#39;</span>:
                    <span style="color:#66d9ef">continue</span>
                <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>surface, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
            <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> d[int(c<span style="color:#f92672">.</span>dst)]<span style="color:#f92672">.</span>morphs:
                <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;symbol&#39;</span>:
                    <span style="color:#66d9ef">continue</span>
                <span style="color:#66d9ef">print</span>(m<span style="color:#f92672">.</span>surface, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>)
            <span style="color:#66d9ef">print</span>()
</code></pre></div><p>I simply looked up with <code>if</code></p>
<h4 id="44-visualization-of-dependency-tree">44 Visualization of dependency tree</h4>
<blockquote>
<p>Visualize the dependency tree of the given sentence as a directed graph. For visualization, convert the dependency tree into DOT language and use Graphviz. To visualize a directed graph directly from Python, use pydot.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#44</span>
<span style="color:#f92672">import</span> random<span style="color:#f92672">,</span> pathlib
<span style="color:#f92672">from</span> graphviz <span style="color:#f92672">import</span> Digraphf <span style="color:#f92672">=</span> pathlib<span style="color:#f92672">.</span>Path(<span style="color:#e6db74">&#39;nekocabocha.png&#39;</span>)
fmt <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>suffix<span style="color:#f92672">.</span>lstrip(<span style="color:#e6db74">&#39;.&#39;</span>)
fname <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>stem
target_doc <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>choice(doc)
target_doc <span style="color:#f92672">=</span> doc[<span style="color:#ae81ff">8</span>]
idx <span style="color:#f92672">=</span> doc<span style="color:#f92672">.</span>index(target_doc)

dot <span style="color:#f92672">=</span> Digraph(format<span style="color:#f92672">=</span>fmt)
dot<span style="color:#f92672">.</span>attr(<span style="color:#e6db74">&#34;node&#34;</span>, shape<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;circle&#34;</span>)

N <span style="color:#f92672">=</span> len(target_doc)
<span style="color:#75715e">#Add node</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
    dot<span style="color:#f92672">.</span>node(str(i), <span style="color:#e6db74">``</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> target_doc[i]<span style="color:#f92672">.</span>morphs]))

<span style="color:#75715e"># Add side</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
    <span style="color:#66d9ef">if</span> target_doc[i]<span style="color:#f92672">.</span>dst <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
        dot<span style="color:#f92672">.</span>edge(str(i), str(target_doc[i]<span style="color:#f92672">.</span>dst))

<span style="color:#75715e"># dot.engine = &#34;circo&#34;</span>
dot<span style="color:#f92672">.</span>filename <span style="color:#f92672">=</span> filename
dot<span style="color:#f92672">.</span>render()

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join((m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> target_doc <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs]))
<span style="color:#66d9ef">print</span>(dot)
<span style="color:#f92672">from</span> IPython.display <span style="color:#f92672">import</span> Image, display_png
display_png(Image(str(f)))

</code></pre></div><p>I did not do much while thinking that visualization seems to be fun, so I did it for the first time, Wikipedia was enough to get a rough idea of the DOT language</p>
<h4 id="45-extracting-verb-case-patterns">45 Extracting verb case patterns</h4>
<blockquote>
<p>I would like to consider the sentence used this time as a corpus and investigate the cases that Japanese predicates can take. Consider the verb as a predicate, the particle of the clause related to the verb as a case, and output the predicate and case in tab-delimited format. However, the output should meet the following specifications.
In clauses containing verbs, the basic form of the leftmost verb is the predicate
Case particles related to predicates
When there are multiple particles (bunsetsu) related to the predicate, all particles are arranged in dictionary order with a space between them.
Consider the example sentence (eighth sentence of neko.txt.cabocha) &ldquo;I saw a human being for the first time here.&rdquo; This sentence contains two verbs, &ldquo;begin&rdquo; and &ldquo;see&rdquo;, and the phrase &ldquo;begin&rdquo; is parsed as &ldquo;here&rdquo; and the phrase as &ldquo;see&rdquo; is parsed as &ldquo;I am&rdquo; and &ldquo;mono&rdquo; Should yield the following output.
<code>Begin with</code>
<code>see is</code>
Save the output of this program to a file and check the following items using UNIX commands.
Combination of predicates and case patterns that occur frequently in the corpus
The case patterns of the verbs “do”, “see”, and “give” (arrange in the corpus in order of frequency of occurrence)</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#45</span>
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;neko_verb.txt&#34;</span>, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> f:
    <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> doc:
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
            <span style="color:#66d9ef">if</span><span style="color:#e6db74">&#39;verb&#39;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs]:
                row <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span>morphs[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>base
                j_list <span style="color:#f92672">=</span> []
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>srcs:
                    <span style="color:#66d9ef">if</span> len(s[i]<span style="color:#f92672">.</span>morphs) <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>:
                        <span style="color:#66d9ef">continue</span>
                    srclast <span style="color:#f92672">=</span> s[i]<span style="color:#f92672">.</span>morphs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                    <span style="color:#66d9ef">if</span> srclast<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;particle&#39;</span>:
                        j_list<span style="color:#f92672">.</span>append(srclast<span style="color:#f92672">.</span>surface)
                <span style="color:#66d9ef">if</span> len(j_list)<span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                    j_list<span style="color:#f92672">.</span>sort()
                    row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(j_list)
                    f<span style="color:#f92672">.</span>write(row <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ cat neko_verb.txt | sort | uniq -c | sort -rn -k <span style="color:#ae81ff">3</span>
$ cat neko_verb.txt | grep <span style="color:#e6db74">&#34;^Yes&#34;</span> | sort | uniq -c | sort -rn -k <span style="color:#ae81ff">3</span>
$ cat neko_verb.txt | grep <span style="color:#e6db74">&#34;view&#34;</span> | sort | uniq -c | sort -rn -k <span style="color:#ae81ff">3</span>
$ cat neko_verb.txt | grep <span style="color:#e6db74">&#34;give&#34;</span> | sort | uniq -c | sort -rn -k <span style="color:#ae81ff">3</span>
</code></pre></div><p>Combine &ldquo;part of speech&rdquo; and &ldquo;relationship&rdquo; so far</p>
<h4 id="46-extracting-verb-case-frame-information">46 Extracting verb case frame information</h4>
<p>Modify the program of &gt;45 and output the term (the clause itself related to the predicate) following the predicate and case pattern in tab delimited format. In addition to the 45 specifications, try to meet the following specifications.
The term is the word string of the clause related to the predicate (it is not necessary to remove the trailing particle)
When there are multiple clauses related to the predicate, arrange them in space delimiters according to the same criteria and order as the particle.
Consider the example sentence (eighth sentence of neko.txt.cabocha) &ldquo;I saw a human being for the first time here.&rdquo; This sentence contains two verbs, &ldquo;begin&rdquo; and &ldquo;see&rdquo;, and the phrase &ldquo;begin&rdquo; is parsed as &ldquo;here&rdquo; and the phrase as &ldquo;see&rdquo; is parsed as &ldquo;I am&rdquo; and &ldquo;mono&rdquo; Should yield the following output.
<code>Begin with here</code>
<code>See what I see</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#46</span>
<span style="color:#75715e"># This is different from the output example, but the problem specification is satisfied here</span>
<span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> doc:
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
        <span style="color:#66d9ef">if</span><span style="color:#e6db74">&#39;verb&#39;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs]:
            row <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span>morphs[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>base
            j_list <span style="color:#f92672">=</span> []
            c_list <span style="color:#f92672">=</span> []
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>srcs:
                <span style="color:#66d9ef">if</span> len(s[i]<span style="color:#f92672">.</span>morphs) <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>:
                    <span style="color:#66d9ef">continue</span>
                srclast <span style="color:#f92672">=</span> s[i]<span style="color:#f92672">.</span>morphs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">if</span> srclast<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;particle&#39;</span>:
                    j_list<span style="color:#f92672">.</span>append(srclast<span style="color:#f92672">.</span>surface)
                    c_list<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> s[i]<span style="color:#f92672">.</span>morphs]))
            <span style="color:#66d9ef">if</span> len(j_list)<span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                j_list<span style="color:#f92672">.</span>sort()
                c_list<span style="color:#f92672">.</span>sort()
                row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(j_list) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(c_list)
                <span style="color:#66d9ef">print</span>(row)
</code></pre></div><blockquote>
<p>When there are multiple clauses related to the predicate, place them in the same criteria and order as the particle, separated by spaces.</p>
</blockquote>
<p>Since it is said that it is different from the output example, but the clauses are sorted independently</p>
<h4 id="47-mining-functional-verb-syntax">47 Mining functional verb syntax</h4>
<blockquote>
<p>I would like to focus only on cases where the verb wo case contains a sahen connection noun. Modify 46 programs to meet the following specifications.
Only when the clause consisting of &ldquo;Sahen connected noun + wo (particle)&rdquo; relates to a verb
The predicate is &ldquo;Sahen connected noun + is the basic form of + verb&rdquo;, and when there are multiple verbs in a clause, the leftmost verb is used.
When there are multiple particles (bunsetsu) related to the predicate, all particles are arranged in dictionary order with a space between them.
When there are multiple clauses related to the predicate, all terms are arranged in a space-separated manner (align with the order of particles).
For example, the following output should be obtained from the sentence &ldquo;My husband replies to the letter as soon as it comes.&rdquo;
<code>When I reply, the owner of the letter and the letter</code>
Save the output of this program to a file and check the following items using UNIX commands.
Frequent predicates in the corpus (Sahen connective noun + + verb)
Frequent predicate and particle patterns in the corpus</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#47</span>
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;neko_func_verb.txt&#34;</span>, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> f:
    <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> doc:
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
            <span style="color:#66d9ef">if</span><span style="color:#e6db74">&#39;verb&#39;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs]:
                verb <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span>morphs[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>base
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>srcs:
                    v_head <span style="color:#f92672">=</span> s[i]<span style="color:#f92672">.</span>morphs[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:]
                    <span style="color:#66d9ef">if</span> len(v_head) <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>:
                        <span style="color:#66d9ef">continue</span>
                    <span style="color:#66d9ef">if</span> v_head[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>pos1 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;sa connection&#34;</span> <span style="color:#f92672">and</span> v_head[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>surface <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;to&#34;</span>:
                        verb <span style="color:#f92672">=</span> <span style="color:#e6db74">``</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> v_head]) <span style="color:#f92672">+</span> verb
                        joshi_dic <span style="color:#f92672">=</span> {}

                        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>srcs:
                            <span style="color:#66d9ef">if</span> len(s[j]<span style="color:#f92672">.</span>morphs) <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>:
                                <span style="color:#66d9ef">continue</span>
                            srclast <span style="color:#f92672">=</span> s[j]<span style="color:#f92672">.</span>morphs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                            <span style="color:#66d9ef">if</span> srclast<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;particle&#39;</span> <span style="color:#f92672">and</span> srclast<span style="color:#f92672">.</span>surface <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;to&#34;</span>:
                                joshi_dic[srclast<span style="color:#f92672">.</span>surface] <span style="color:#f92672">=</span> <span style="color:#e6db74">``</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> s[j]<span style="color:#f92672">.</span>morphs])

                        <span style="color:#66d9ef">if</span> len(joshi_dic<span style="color:#f92672">.</span>keys())<span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                            joshi_list <span style="color:#f92672">=</span> list(joshi_dic<span style="color:#f92672">.</span>keys())
                            joshi_list<span style="color:#f92672">.</span>sort()
                            row <span style="color:#f92672">=</span> verb <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(joshi_list) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([joshi_dic[joshi] <span style="color:#66d9ef">for</span> joshi <span style="color:#f92672">in</span> joshi_list])
                            f<span style="color:#f92672">.</span>write(row <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
<span style="color:#e6db74">``````</span>sh
<span style="color:#960050;background-color:#1e0010">$</span> cat neko_func_verb<span style="color:#f92672">.</span>txt <span style="color:#f92672">|</span> sed <span style="color:#e6db74">&#34;s/</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">/ /g&#34;</span><span style="color:#f92672">|</span> cut <span style="color:#f92672">-</span>f <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span>d <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">|</span> sort <span style="color:#f92672">|</span> uniq <span style="color:#f92672">-</span>c <span style="color:#f92672">|</span> sort <span style="color:#f92672">-</span>rn <span style="color:#f92672">-</span>k <span style="color:#ae81ff">3</span>
<span style="color:#960050;background-color:#1e0010">$</span> cat neko_func_verb<span style="color:#f92672">.</span>txt <span style="color:#f92672">|</span> sed <span style="color:#e6db74">&#34;s/</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">/+/g&#34;</span><span style="color:#f92672">|</span> cut <span style="color:#f92672">-</span>f <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span>d <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">|</span> sed <span style="color:#e6db74">&#34;s/+/</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">/g&#34;</span> <span style="color:#f92672">|</span> sort <span style="color:#f92672">|</span> uniq <span style="color:#f92672">-</span>c <span style="color:#f92672">|</span> sort<span style="color:#f92672">-</span> rn <span style="color:#f92672">-</span>k <span style="color:#ae81ff">3</span>
</code></pre></div><blockquote>
<p>If there are multiple clauses related to the predicate, put all terms in a space (separate the order of particles).</p>
</blockquote>
<p>This was a collection, so I made it a dictionary type and corresponded
No matter how many times I read the problem, I can&rsquo;t understand it</p>
<h4 id="48-extraction-of-path-from-noun-to-root">48 Extraction of path from noun to root</h4>
<blockquote>
<p>For a phrase that includes all nouns in a sentence, extract the path from that phrase to the root of the syntax tree. However, the path on the syntax tree satisfies the following specifications.
Each clause is represented by a (surface type) morpheme sequence
Concatenate the expressions of each clause with &ldquo;-&gt;&rdquo; from the start clause to the end clause of the path
The sentence &ldquo;I saw human beings here for the first time&rdquo; (the 8th sentence of neko.txt.cabocha) should give the following output.
<code>I'm -&gt; Saw</code>
<code>Here -&gt; for the first time -&gt; human -&gt; something -&gt; saw</code>
<code>Human -&gt; Things -&gt; Saw</code>
<code>thing -&gt; saw</code></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#48</span>
<span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> doc:
    <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;noun&#34;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs]:
            row <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs])
            chunk_to <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span>dst
            <span style="color:#66d9ef">if</span> chunk_to <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
                <span style="color:#66d9ef">continue</span>
            <span style="color:#66d9ef">while</span>(chunk_to <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;-&gt; &#34;</span><span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> s[chunk_to]<span style="color:#f92672">.</span>morphs])
                chunk_to <span style="color:#f92672">=</span> s[chunk_to]<span style="color:#f92672">.</span>dst
            <span style="color:#66d9ef">print</span>(row)
</code></pre></div><p>This solves smoothly compared to the previous problem</p>
<h4 id="49-extraction-of-dependency-path-between-nouns">49 Extraction of dependency path between nouns</h4>
<blockquote>
<p>Extract the shortest dependency path that connects all pairs of noun phrases in the sentence. However, when the clause numbers of the noun phrase pair are i and j (i&lt;j), the dependency path satisfies the following specifications.
Similar to problem 48, the path is expressed by connecting each phrase expression (surface morphological sequence) from the start phrase to the end phrase with &ldquo;-&gt;&rdquo;.
Replace noun phrases contained in bunsetsu i and j with X and Y, respectively
There are two possible shapes of the dependency path.
If bunsetsu j exists on the path from bunsetsu i to the root of syntax tree: Display the path from bunsetsu i to bunsetsu j
Except for the above, when intersections are common bunsetsu k on the path from bunsetsu i and bunsetsu j to the root of the syntax tree: path just before bunsetsu i to bunsetsu k and path just before bunsetsu j to bunsetsu k, bunsetsu k Display the contents of &quot;&rdquo; by concatenating with &ldquo;|&rdquo;
For example, from the sentence &ldquo;I saw a human being for the first time here&rdquo; (the 8th sentence of neko.txt.cabocha), the following output should be obtained.
<code>X is | Y -&gt; start -&gt; human -&gt; something | saw </code>
<code>X is | Y -&gt; something | Saw </code>
<code>X is | Y | Saw</code>
<code>X -&gt; start -&gt; Y</code>
<code>X -&gt; start -&gt; human -&gt; Y</code>
<code>X -&gt; Y</code></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#49</span>
<span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> doc:
    <span style="color:#75715e"># i &lt;j, so the tail is unnecessary</span>
    <span style="color:#66d9ef">for</span> i, c <span style="color:#f92672">in</span> enumerate(s[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]):
        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;noun&#34;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs] <span style="color:#f92672">and</span> c<span style="color:#f92672">.</span>morphs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;particle&#34;</span>:
            Find <span style="color:#75715e"># j</span>
            <span style="color:#66d9ef">for</span> c_rest <span style="color:#f92672">in</span> s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]:
                <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;noun&#34;</span> <span style="color:#f92672">in</span> [m<span style="color:#f92672">.</span>pos <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c_rest<span style="color:#f92672">.</span>morphs] <span style="color:#f92672">and</span> c_rest<span style="color:#f92672">.</span>morphs[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>pos <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;particle&#34;</span>:
                    i_clause <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>pos <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;noun&#34;</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;X&#34;</span> <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>morphs])
                    j_clause <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>pos <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;noun&#34;</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;Y&#34;</span> <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> c_rest<span style="color:#f92672">.</span>morphs])
                    
                    row <span style="color:#f92672">=</span> i_clause
                    chunk_to <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span>dst
                    <span style="color:#75715e"># Ask for a path to see if j is on the path</span>
                    kkr_path <span style="color:#f92672">=</span> [chunk_to]
                    <span style="color:#66d9ef">while</span>(kkr_path[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                        kkr_path<span style="color:#f92672">.</span>append(s[chunk_to]<span style="color:#f92672">.</span>dst)
                        chunk_to <span style="color:#f92672">=</span> s[chunk_to]<span style="color:#f92672">.</span>dst
                    
                    <span style="color:#66d9ef">if</span> s<span style="color:#f92672">.</span>index(c_rest) <span style="color:#f92672">in</span> kkr_path:
                        chunk_to <span style="color:#f92672">=</span> c<span style="color:#f92672">.</span>dst
                        <span style="color:#66d9ef">while</span>(chunk_to <span style="color:#f92672">!=</span> s<span style="color:#f92672">.</span>index(c_rest)):
                            row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;-&gt; &#34;</span><span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> s[chunk_to]<span style="color:#f92672">.</span>morphs])
                            chunk_to <span style="color:#f92672">=</span> s[chunk_to]<span style="color:#f92672">.</span>dst
                        row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;-&gt;&#34;</span> <span style="color:#f92672">+</span> j_clause
                    <span style="color:#66d9ef">else</span>:
                        row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">+</span> j_clause
                        chunk_to <span style="color:#f92672">=</span> c_rest<span style="color:#f92672">.</span>dst
                        <span style="color:#66d9ef">while</span>(s[chunk_to]<span style="color:#f92672">.</span>dst <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                            row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;-&gt; &#34;</span><span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> s[chunk_to]<span style="color:#f92672">.</span>morphs])
                            chunk_to <span style="color:#f92672">=</span> s[chunk_to]<span style="color:#f92672">.</span>dst
                        row <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;| &#34;</span><span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([m<span style="color:#f92672">.</span>surface <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> s[chunk_to]<span style="color:#f92672">.</span>morphs])
                        
                    <span style="color:#66d9ef">print</span>(row)

</code></pre></div><blockquote>
<p>Replace noun phrases contained in clauses i and j with X and Y, respectively</p>
</blockquote>
<p>The specifications and output examples were also slightly different, but I replaced them with nouns like &ldquo;X ga&rdquo;.</p>
<h3 id="chapter-6-processing-english-text">Chapter 6: Processing English Text</h3>
<blockquote>
<p>For English text (nlp.txt), execute the following process.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ wget http://www.cl.ecei.tohoku.ac.jp/nlp100/data/nlp.txt
</code></pre></div><h4 id="50-sentence-breaks">50 sentence breaks</h4>
<blockquote>
<p>(. or ;or :or? Or !)→ Whitespace character→ Treat the pattern of capital letters as sentence delimiters, and output the input document in the form of one sentence per line.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#50</span>
<span style="color:#f92672">import</span> re
sentence_sep <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>compile(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;(\.|;|:|\?|!) ([A-Z])&#39;</span>)

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;./nlp.txt&#34;</span>) <span style="color:#66d9ef">as</span> f:
    txt <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
txt <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>sub(sentence_sep, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;\1\n\2&#39;</span>, txt)
<span style="color:#66d9ef">print</span>(txt)
</code></pre></div><p>I solved it while thinking</p>
<h4 id="51-extracting-words">51 Extracting words</h4>
<blockquote>
<p>Treat spaces as word delimiters, receive 50 outputs as input, and output 1 word per line. However, output a blank line at the end of the sentence.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 51</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">space2return</span>(txt):
    sentence_sep <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>compile(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;(\.|;|:|\?|!)\n([A-Z])&#39;</span>)
    txt <span style="color:#f92672">=</span> re<span style="color:#f92672">.</span>sub(sentence_sep, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;\1\n\n\2&#39;</span>, txt)
    <span style="color:#66d9ef">return</span> re<span style="color:#f92672">.</span>sub(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;\n&#39;</span>, txt)

txt <span style="color:#f92672">=</span> space2return(txt)
<span style="color:#66d9ef">print</span>(txt)
</code></pre></div><p>Although it receives 50 output, it responds on an ad hoc basis as it causes a little unexpected behavior with sentence line breaks.</p>
<h4 id="52-stemming">52 Stemming</h4>
<p>Take the output of &gt;51 as input, apply Porter&rsquo;s stemming algorithm, and output words and stems in tab-delimited format. In Python, use the stemming module as an implementation of Porter&rsquo;s stemming algorithm.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#52</span>
<span style="color:#f92672">from</span> nltk.stem <span style="color:#f92672">import</span> PorterStemmer
ps <span style="color:#f92672">=</span> PorterStemmer()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stem_text</span>(txt):
    <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> txt<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>):
        <span style="color:#66d9ef">yield</span> l <span style="color:#f92672">+</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">+</span> ps <span style="color:#f92672">.</span>stem(l)
    
<span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> stem_text(txt):
    <span style="color:#66d9ef">print</span>(line)
</code></pre></div><p><a href="https://pypi.org/project/stemming/">Presented link</a> did not exist, so I used it instead.
I tried using the yield that I usually avoid, but I found that the return value becomes an iterator</p>
<h4 id="53-tokenization">53 Tokenization</h4>
<blockquote>
<p>Use Stanford Core NLP to obtain the analysis result of the input text in XML format. Also, read this XML file and output the input text in the format of one word per line.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ wget http://nlp.stanford.edu/software/stanford-corenlp-full-2018-10-05.zip
$ unzip stanford-corenlp-full-2018-10-05.zip
$ java -cp <span style="color:#e6db74">&#34;./stanford-corenlp-full-2018-10-05/*&#34;</span> edu.stanford.nlp.pipeline.StanfordCoreNLP -annotators tokenize,ssplit,parse,lemma,ner,coref -file ./nlp.txt
</code></pre></div><p>I suffered from XML parsing rather than this guyRefer to the reference for <code>-annotators</code> at runtime of java, and modify if necessary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#53</span>
<span style="color:#f92672">import</span> xml.etree.ElementTree <span style="color:#f92672">as</span> ET

tree <span style="color:#f92672">=</span> ET<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;./nlp.txt.xml&#34;</span>)
root <span style="color:#f92672">=</span> tree<span style="color:#f92672">.</span>getroot()
<span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>iter(<span style="color:#e6db74">&#34;token&#34;</span>):
    <span style="color:#66d9ef">print</span>(token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;word&#34;</span>)<span style="color:#f92672">.</span>text)
</code></pre></div><p>I wonder if it&rsquo;s a way to output the whole thing and check the tags.</p>
<h4 id="54-part-of-speech-tagging">54 Part of speech tagging</h4>
<blockquote>
<p>Read the Stanford Core NLP analysis result XML and output the words, lemmas, and parts of speech in tab-delimited format.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#54</span>
<span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>iter(<span style="color:#e6db74">&#34;token&#34;</span>):
    <span style="color:#66d9ef">print</span>(token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;word&#34;</span>)<span style="color:#f92672">.</span>text <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;lemma&#34;</span>)<span style="color:#f92672">.</span>text <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;POS&#34;</span>)<span style="color:#f92672">.</span>text)
</code></pre></div><p>Very hard to see</p>
<h4 id="55-proper-expression-extraction">55 Proper expression extraction</h4>
<blockquote>
<p>Extract all the names in the input sentence.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 55</span>
<span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>iter(<span style="color:#e6db74">&#34;token&#34;</span>):
    NERtag <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;NER&#34;</span>)<span style="color:#f92672">.</span>text
    <span style="color:#66d9ef">if</span> NERtag <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;PERSON&#34;</span>:
        <span style="color:#66d9ef">print</span>(token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;word&#34;</span>)<span style="color:#f92672">.</span>text)
</code></pre></div><p>It was tagged when I thought it was implemented</p>
<h4 id="56-co-reference-analysis">56 Co-reference analysis</h4>
<blockquote>
<p>Replace the reference expression (mention) with a representative reference expression based on the result of the co-reference analysis of Stanford Core NLP. However, when replacing, be careful so that the original reference expression can be understood, as in &ldquo;representative reference expression (reference expression)&rdquo;.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 56</span>
rep_dic_list <span style="color:#f92672">=</span> []

<span style="color:#75715e"># Dictionary</span>
<span style="color:#66d9ef">for</span> coreferences <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#34;document/coreference&#34;</span>):
    <span style="color:#66d9ef">for</span> mentions <span style="color:#f92672">in</span> coreferences:
        <span style="color:#66d9ef">for</span> m <span style="color:#f92672">in</span> mentions:
            <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;representative&#34;</span> <span style="color:#f92672">in</span> m<span style="color:#f92672">.</span>attrib:
                rep_txt <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;text&#34;</span>)<span style="color:#f92672">.</span>text
            <span style="color:#66d9ef">else</span>:
                tmp_dic <span style="color:#f92672">=</span> {}
                tmp_dic[<span style="color:#e6db74">&#34;sentence&#34;</span>] <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;sentence&#34;</span>)<span style="color:#f92672">.</span>text
                tmp_dic[<span style="color:#e6db74">&#34;start&#34;</span>] <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;start&#34;</span>)<span style="color:#f92672">.</span>text
                tmp_dic[<span style="color:#e6db74">&#34;end&#34;</span>] <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;end&#34;</span>)<span style="color:#f92672">.</span>text
                tmp_dic[<span style="color:#e6db74">&#34;rep_txt&#34;</span>] <span style="color:#f92672">=</span> rep_txt
                rep_dic_list<span style="color:#f92672">.</span>append(tmp_dic)
                
<span style="color:#75715e"># Output</span>
<span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>iter(<span style="color:#e6db74">&#34;sentence&#34;</span>):
    rep_sent_list <span style="color:#f92672">=</span> [rd <span style="color:#66d9ef">for</span> rd <span style="color:#f92672">in</span> rep_dic_list <span style="color:#66d9ef">if</span> rd[<span style="color:#e6db74">&#34;sentence&#34;</span>] <span style="color:#f92672">==</span> s<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;id&#34;</span>]]
    <span style="color:#75715e"># Whether the statement requires substitution</span>
    <span style="color:#66d9ef">if</span> len(rep_sent_list) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">.</span>join([token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;word&#34;</span>)<span style="color:#f92672">.</span>text <span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>iter(<span style="color:#e6db74">&#34;token&#34;</span>)]), end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>)
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>iter(<span style="color:#e6db74">&#34;token&#34;</span>):
            tid <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;id&#34;</span>]
            rep_token_list <span style="color:#f92672">=</span> [rd <span style="color:#66d9ef">for</span> rd <span style="color:#f92672">in</span> rep_sent_list <span style="color:#66d9ef">if</span> rd[<span style="color:#e6db74">&#34;start&#34;</span>] <span style="color:#f92672">==</span> tid <span style="color:#f92672">or</span> rd[<span style="color:#e6db74">&#34;end&#34;</span>] <span style="color:#f92672">==</span> tid]
            
            <span style="color:#66d9ef">if</span> len(rep_token_list)<span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#75715e"># There is only one corresponding item, so take it out.</span>
                rep_dic <span style="color:#f92672">=</span> rep_token_list[<span style="color:#ae81ff">0</span>]
                
                <span style="color:#75715e"># Decoration</span>
                <span style="color:#66d9ef">if</span> tid <span style="color:#f92672">==</span> rep_dic[<span style="color:#e6db74">&#34;start&#34;</span>]:
                    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34; &#34;&#34; + rep_dic[&#34;</span>rep_txt<span style="color:#e6db74">&#34;] + &#34;</span>(<span style="color:#e6db74">&#34;, end=&#34;</span> <span style="color:#e6db74">&#34;)</span>
                <span style="color:#66d9ef">if</span> tid <span style="color:#f92672">==</span> rep_dic[<span style="color:#e6db74">&#34;end&#34;</span>]:
                    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;)&#34;&#34;, end=&#34;</span> <span style="color:#e6db74">&#34;)</span>
                    
            <span style="color:#66d9ef">print</span>(token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;word&#34;</span>)<span style="color:#f92672">.</span>text, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>)
</code></pre></div><p>I couldn&rsquo;t understand the problem statement and left it for a long time here.
Make a dictionary and modify it rather than replace it</p>
<h4 id="57-dependency-analysis">57 Dependency analysis</h4>
<blockquote>
<p>Visualize the results of dependency analysis (collapsed-dependencies) of Stanford Core NLP as a directed graph. For visualization, convert the dependency tree into DOT language and use Graphviz. To visualize a directed graph directly from Python, use pydot.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#57</span>
<span style="color:#f92672">import</span> random<span style="color:#f92672">,</span> pathlib
<span style="color:#f92672">from</span> graphviz <span style="color:#f92672">import</span> Digraph

f <span style="color:#f92672">=</span> pathlib<span style="color:#f92672">.</span>Path(<span style="color:#e6db74">&#39;nlp.png&#39;</span>)
fmt <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>suffix<span style="color:#f92672">.</span>lstrip(<span style="color:#e6db74">&#39;.&#39;</span>)
fname <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>stem

dot <span style="color:#f92672">=</span> Digraph(format<span style="color:#f92672">=</span>fmt)
dot<span style="color:#f92672">.</span>attr(<span style="color:#e6db74">&#34;node&#34;</span>, shape<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;circle&#34;</span>)

sent_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>

<span style="color:#66d9ef">for</span> sents <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>findall(f<span style="color:#e6db74">&#34;document/sentences/sentence[@id=&#39;{sent_id}&#39;]&#34;</span>):
    <span style="color:#66d9ef">for</span> deps <span style="color:#f92672">in</span> sents:
        <span style="color:#66d9ef">for</span> dep <span style="color:#f92672">in</span> deps<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#34;[@type=&#39;collapsed-dependencies&#39;]&#34;</span>):
            <span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> dep:
                gvnr <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;governor&#34;</span>)
                dpnt <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;dependent&#34;</span>)
                dot<span style="color:#f92672">.</span>node(gvnr<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>], gvnr<span style="color:#f92672">.</span>text)
                dot<span style="color:#f92672">.</span>node(dpnt<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>], dpnt<span style="color:#f92672">.</span>text)
                dot<span style="color:#f92672">.</span>edge(gvnr<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>], dpnt<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>])


dot<span style="color:#f92672">.</span>filename <span style="color:#f92672">=</span> fname
dot<span style="color:#f92672">.</span>render()

<span style="color:#75715e"># print(dot)</span>
<span style="color:#f92672">from</span> IPython.display <span style="color:#f92672">import</span> Image, display_png
display_png(Image(str(f)))
</code></pre></div><p>At first, I didn&rsquo;t understand because I passed through <code>governor</code> and <code>dependent</code>.</p>
<h4 id="58-tuple-extraction">58 Tuple extraction</h4>
<blockquote>
<p>Based on the result of dependency analysis (collapsed-dependencies) of Stanford Core NLP, output the set of “subject, predicate and object” in tab delimited format. However, refer to the following for definitions of the subject, predicate, and object.
<code>Predicate: a word with a child of nsubj relation and dobj relation</code>
<code>Subject: Child that has nsubj relation from the predicate (dependent)</code>
<code>Object: child that has dobj relation from predicate (dependent)</code></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#58</span>
<span style="color:#66d9ef">for</span> sents <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>findall(f<span style="color:#e6db74">&#34;document/sentences/sentence&#34;</span>):
    <span style="color:#66d9ef">for</span> deps <span style="color:#f92672">in</span> sents:
        <span style="color:#66d9ef">for</span> dep <span style="color:#f92672">in</span> deps<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#34;[@type=&#39;collapsed-dependencies&#39;]&#34;</span>):
            nsubj_list <span style="color:#f92672">=</span> []
            <span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> dep<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#34;./dep[@type=&#39;nsubj&#39;]&#34;</span>):
                gvnr <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;governor&#34;</span>)
                dpnt <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;dependent&#34;</span>)
                nsubj_list<span style="color:#f92672">.</span>append( (
                    (gvnr<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>], gvnr<span style="color:#f92672">.</span>text): (dpnt<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>], dpnt<span style="color:#f92672">.</span>text)
                })
            <span style="color:#66d9ef">for</span> token <span style="color:#f92672">in</span> dep<span style="color:#f92672">.</span>findall(<span style="color:#e6db74">&#34;./dep[@type=&#39;dobj&#39;]&#34;</span>):
                gvnr <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;governor&#34;</span>)
                dpnt <span style="color:#f92672">=</span> token<span style="color:#f92672">.</span>find(<span style="color:#e6db74">&#34;dependent&#34;</span>)
                dobj_tuple <span style="color:#f92672">=</span> (gvnr<span style="color:#f92672">.</span>attrib[<span style="color:#e6db74">&#34;idx&#34;</span>], gvnr<span style="color:#f92672">.</span>text)
                
                <span style="color:#66d9ef">if</span> dobj_tuple <span style="color:#f92672">in</span> [list(nsubj<span style="color:#f92672">.</span>keys())[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> nsubj <span style="color:#f92672">in</span> nsubj_list]:
                    idx <span style="color:#f92672">=</span> [list(nsubj<span style="color:#f92672">.</span>keys())[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> nsubj <span style="color:#f92672">in</span> nsubj_list]<span style="color:#f92672">.</span>index( dobj_tuple )<span style="color:#f92672">.</span>
                    jutugo <span style="color:#f92672">=</span> gvnr<span style="color:#f92672">.</span>text
                    shugo <span style="color:#f92672">=</span> nsubj_list[idx][dobj_tuple][<span style="color:#ae81ff">1</span>]
                    mokutekigo <span style="color:#f92672">=</span> dpnt<span style="color:#f92672">.</span>text
                    <span style="color:#66d9ef">print</span>(shugo <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> jutugo <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> mokutekigo)

</code></pre></div><p>A policy to create a dictionary and then search for one that meets the conditions</p>
<h4 id="59-s-expression-analysis">59 S-expression analysis</h4>
<blockquote>
<p>Read the result of Stanford Core NLP&rsquo;s phrase structure analysis (S-expression) and display all noun phrases (NP) in the sentence. Display all nested noun phrases.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 59</span>
<span style="color:#f92672">import</span> xml.etree.ElementTree <span style="color:#f92672">as</span> ET
<span style="color:#f92672">import</span> re

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search_nest</span>(t):
    <span style="color:#66d9ef">if</span> isinstance(t[<span style="color:#ae81ff">0</span>], str):
        <span style="color:#66d9ef">if</span> isinstance(t[<span style="color:#ae81ff">1</span>], str):<span style="color:#66d9ef">if</span> t[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;NP&#34;</span>:
                <span style="color:#66d9ef">print</span>(t[<span style="color:#ae81ff">1</span>])
            <span style="color:#66d9ef">return</span> t[<span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">if</span> t[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;NP&#34;</span>:
                np_list <span style="color:#f92672">=</span> []
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> t[<span style="color:#ae81ff">1</span>:]:
                    res <span style="color:#f92672">=</span> search_nest(i)
                    <span style="color:#66d9ef">if</span> isinstance(res, str):
                        np_list<span style="color:#f92672">.</span>append(search_nest(i))
                <span style="color:#66d9ef">if</span> len(np_list) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39; &#39;</span><span style="color:#f92672">.</span>join(np_list))
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> t[<span style="color:#ae81ff">1</span>:]:
                    search_nest(i)
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> t:
            search_nest(i)


tree <span style="color:#f92672">=</span> ET<span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#34;./nlp.txt.xml&#34;</span>)
root <span style="color:#f92672">=</span> tree<span style="color:#f92672">.</span>getroot()
sent_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>

<span style="color:#66d9ef">for</span> parse <span style="color:#f92672">in</span> root<span style="color:#f92672">.</span>findall(f<span style="color:#e6db74">&#34;document/sentences/sentence[@id=&#39;{sent_id}&#39;]/parse&#34;</span>):
    S_str <span style="color:#f92672">=</span> parse<span style="color:#f92672">.</span>text
    S_str <span style="color:#f92672">=</span> S_str<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;(&#34;</span>, <span style="color:#e6db74">&#34;(&#39;&#34;</span>)
    S_str <span style="color:#f92672">=</span> S_str<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;)&#34;</span>, <span style="color:#e6db74">&#34;&#39;)&#34;</span>)
    S_str <span style="color:#f92672">=</span> S_str<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#e6db74">&#34;&#39;, &#39;&#34;</span>)
    S_str <span style="color:#f92672">=</span> S_str<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;&#39;(&#34;</span>, <span style="color:#e6db74">&#34;(&#34;</span>)
    S_str <span style="color:#f92672">=</span> S_str<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;)&#39;&#34;</span>, <span style="color:#e6db74">&#34;)&#34;</span>)
    <span style="color:#66d9ef">exec</span>(f<span style="color:#e6db74">&#34;S_tuple = {S_str[:-2]}&#34;</span>)
    search_nest(S_tuple)
    

</code></pre></div><p><code>()</code>の入れ子の認識ができずに人生最大の汚い実装をした、ゴリゴリにハードコーディングしてタプル型にして再帰的に取り出す。
<code>regex</code>を試しても自分で解決できなかったので解答を優先した。</p>
<h2 id="おわり">おわり</h2>
<p>どちらの章も初めてのライブラリであったことと言語処理の用語が急に増えたので1~4章の倍くらい時間がかかった
しかし残りはDB, ML, ベクトルなのでいけるっしょという油断をしている</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
