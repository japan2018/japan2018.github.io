<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>Application of affine transformation by tensor-From basics to object detection- | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Application of affine transformation by tensor-From basics to object detection-</h1>
<p>
  <small class="text-secondary">
  
  
  May 26, 2020
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/numpy"> numpy</a></code></small>


<small><code><a href="https://memotut.com/tags/machine-learning"> machine learning</a></code></small>


<small><code><a href="https://memotut.com/tags/preprocessing"> preprocessing</a></code></small>


<small><code><a href="https://memotut.com/tags/affine-transformation"> affine transformation</a></code></small>

</p>
<pre><code>This article is about simplifying preprocessing by using affine transformation with tensors. The affine transformation can be applied to images, but the same transformation can be applied to annotations such as Bounding Box. You can also apply different transformations to one object at the same time by extending it to a tensor.
</code></pre>
<h2 id="affine-transformation-basics">Affine transformation basics</h2>
<p>The affine transformation represents the movement of points in the following formula.</p>
<p>$$\begin{bmatrix}x&rsquo; \\ y&rsquo;\\ 1 \end{bmatrix} = \begin{bmatrix}a &amp; b &amp; c \\ d &amp; e &amp; f \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix}x \\ y \\ 1 \end{bmatrix} \tag{1}$$</p>
<p>If you want to see a vague understanding of affine transformation, please also see <a href="https://qiita.com/koshian2/items/c133e2e10c261b8646bf">this article</a>.</p>
<p>I&rsquo;m taking the product of a 3x3 matrix and a 3x1 matrix, where the 3x3 matrix defines the transformation and the 3x1 matrix is the point before the move.</p>
<h3 id="example-1-parallel-movement">Example 1: Parallel movement</h3>
<p>When the point (10, 20) is moved 100 in the $x$ direction and 50 in the $y$ direction, the coordinates after the movement are (110, 70), but they are expressed as follows.</p>
<p>$$\begin{bmatrix}110 \\ 70 \\ 1 \end{bmatrix} = \begin{bmatrix}1 &amp; 0 &amp; 100 \\ 0 &amp; 1 &amp; 50 \\ 0 &amp; 0 &amp; 1 \end {bmatrix} \begin{bmatrix} 10 \\ 20 \\ 1 \end{bmatrix} \tag{2}$$</p>
<p>You might think, &ldquo;I wouldn&rsquo;t have to use this kind of matrix,&rdquo; but the point is that it can be expressed in a matrix. The code is as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">50</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]])
source <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">1</span>])[:, None]
dest <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(affine, source)
<span style="color:#66d9ef">print</span>(dest)
<span style="color:#75715e">#[[110]</span>
<span style="color:#75715e"># [70]</span>
<span style="color:#75715e"># [1]]</span>
</code></pre></div><p>When the movement in the $x$ direction is $t_x$ and the movement in the $y$ direction is $t_y$, the translation transformation matrix is as follows.</p>
<p>$$\begin{bmatrix}1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag{3}$$</p>
<p>Note that the third row of each matrix is a number that has no meaning. 1 is included for the convenience of matrix product calculation.</p>
<h3 id="example-2-scale">Example 2: Scale</h3>
<p>When the point (50, 100) is doubled in the $x$ direction and 0.8 times in the $y$ direction, the coordinates after movement are (100, 80), but they are expressed as follows.</p>
<p>$$\begin{bmatrix}100 \\ 80 \\ 1 \end{bmatrix} = \begin{bmatrix}2 &amp; 0 &amp; 0 \\ 0 &amp; 0.8 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end {bmatrix} \begin{bmatrix} 50 \\ 100 \\ 1 \end{bmatrix} \tag{4}$$</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.8</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]])
source <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">1</span>])[:, None]
dest <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(affine, source)
<span style="color:#66d9ef">print</span>(dest)
<span style="color:#75715e"># [[100.]</span>
<span style="color:#75715e"># [80.]</span>
<span style="color:#75715e"># [1.]]</span>
</code></pre></div><p>When the expansion in the $x$ direction is $s_x$ and the expansion in the $y$ direction is $s_y$, the scaling conversion matrix is as follows.</p>
<p>$$\begin{bmatrix}s_x &amp; 0 &amp; 0 \\ 0 &amp; s_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag{5}$$</p>
<h2 id="affine-transformation-for-multiple-points">Affine transformation for multiple points</h2>
<p>Since the affine transformation is a matrix calculation, the number of points can be expanded arbitrarily. To find the affine transformation for $N$ points, take the product of the 3x3 matrix and the 3xN matrix. The result is a 3xN matrix.</p>
<p>$$\begin{bmatrix} x_1&rsquo; &amp; \cdots &amp; x_N&rsquo; \\ y_1&rsquo; &amp; \cdots &amp; y_N&rsquo; \\ 1 &amp; \cdots &amp; 1 \end{bmatrix} = \begin{bmatrix} a &amp; b &amp; c \\ d &amp; e &amp; f \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} x_1 &amp; \cdots &amp; x_N \\ y_1 &amp; \cdots &amp; y_N \\ 1 &amp; \cdots &amp; 1 \end{bmatrix} \tag{6}$$</p>
<h3 id="example-3-affine-transformation-of-a-rectangle">Example 3: Affine transformation of a rectangle</h3>
<p>The affine transformation of $N=4$ points results in a quadrangle affine transformation. Applying an affine transformation that expands $(2, 3)$ times in the direction $(x, y)$ and translates $(5, -1)$ to the vertices of a rectangle gives:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">w, h <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>
points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0</span>, w, w, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, h, h], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]], np<span style="color:#f92672">.</span>float32) <span style="color:#75715e"># (3, 4)</span>
affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]]) <span style="color:#75715e"># (3, 3)</span>
dest <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(affine, points)

plt<span style="color:#f92672">.</span>scatter(points[<span style="color:#ae81ff">0</span>,:], points[<span style="color:#ae81ff">1</span>,:], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cyan&#34;</span>)
plt<span style="color:#f92672">.</span>scatter(dest[<span style="color:#ae81ff">0</span>,:], dest[<span style="color:#ae81ff">1</span>,:], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;magenta&#34;</span>)
plt<span style="color:#f92672">.</span>show()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/232088/bbec29ac-739b-6223-2012-ab16337976d9.png" alt="affine_01.png"></p>
<h3 id="example-4-rotating-rectangle-and-boudning-box">Example 4: Rotating rectangle and Boudning Box</h3>
<p>This is an example that can be used in the pre-processing of object detection. When the image is rotated by Data Augmentation of object detection, it is necessary to rotate the Bounding Box as well. The Bounding Box can be defined by the upper left and lower right two points, but by taking the four points of the vertices, the Bounding Box after rotation can be easily calculated. By taking the minimum and maximum values for x and y after rotation, the upper left and lower right coordinates of the Bounding Box after rotation can be obtained.</p>
<p>Rotation is also an affine transformation, and the transformation matrix when rotating $\theta$ counterclockwise about the origin is</p>
<p>$$\begin{bmatrix} \cos\theta &amp; -\sin\theta &amp; 0 \\ \sin\theta &amp; \cos\theta &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag{7 }$$</p>
<p>And when the vertices of the Bounding Box (rectangle) before rotation move to $(x_1&rsquo;, y_1&rsquo;), \cdots, (x_4&rsquo;, y_4&rsquo;)$ after rotation, a new Bounding that circumscribes the tilted rectangle. Box coordinates are</p>
<ul>
<li>Upper left $(\min(x_1&rsquo;, \cdots, x_4&rsquo;), \min(y_1&rsquo;, \cdots, y_4&rsquo;))$</li>
<li>Bottom right $(\max(x_1&rsquo;, \cdots, x_4&rsquo;), \max(y_1&rsquo;, \cdots, y_4&rsquo;))$</li>
</ul>
<p>You can ask at. The reason why this calculation is necessary is that the original vertex after rotation is not suitable as a Bounding Box (because it is not a rectangle parallel to the $xy$ axes), so it needs to be adjusted. See the video below for details.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/232088/45563e4a-f7d2-753d-d35a-03d8814436e8.gif" alt="affine_02.gif"></p>
<p>The plot looks like this: Because of the plot, 5 points have been moved (overlapping the origin), but for calculation only, moving 4 points is OK.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">import</span> matplotlib.patches <span style="color:#f92672">as</span> patches

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rotate_box</span>():
    w, h <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>
    max_wh <span style="color:#f92672">=</span> max(w, h)
    points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0</span>, w, w, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, h, h, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]], np<span style="color:#f92672">.</span>float32) <span style="color:#75715e"># element Bounding Box</span>
    <span style="color:#66d9ef">for</span> theta <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">360</span>, <span style="color:#ae81ff">10</span>):
        rad <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>radians(theta)
        rotate_matrix <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([
            [np<span style="color:#f92672">.</span>cos(rad), <span style="color:#f92672">-</span>np<span style="color:#f92672">.</span>sin(rad), <span style="color:#ae81ff">0</span>],
            [np<span style="color:#f92672">.</span>sin(rad), np<span style="color:#f92672">.</span>cos(rad), <span style="color:#ae81ff">0</span>],
            [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]], np<span style="color:#f92672">.</span>float32)
        dest_points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(rotate_matrix, points)[:<span style="color:#ae81ff">2</span>, :] <span style="color:#75715e"># rotated rectangle</span>
        rectangle <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate((np<span style="color:#f92672">.</span>min(dest_points, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>),
                                    np<span style="color:#f92672">.</span>max(dest_points, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)]) <span style="color:#75715e"># New Bounding Box</span>

        plt<span style="color:#f92672">.</span>clf()
        plt<span style="color:#f92672">.</span>plot(dest_points[<span style="color:#ae81ff">0</span>,:], dest_points[<span style="color:#ae81ff">1</span>,:], linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;o&#34;</span>)

        ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
        rect <span style="color:#f92672">=</span> patches<span style="color:#f92672">.</span>Rectangle(rectangle[:<span style="color:#ae81ff">2</span>], <span style="color:#f92672">*</span>(rectangle[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">-</span>rectangle[:<span style="color:#ae81ff">2</span>]),
                                 linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, edgecolor<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;magenta&#34;</span>, fill<span style="color:#f92672">=</span>False)
        ax<span style="color:#f92672">.</span>add_patch(rect)
        plt<span style="color:#f92672">.</span>ylim(<span style="color:#f92672">-</span>max_wh<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>, max_wh<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
        plt<span style="color:#f92672">.</span>xlim(<span style="color:#f92672">-</span>max_wh <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>, max_wh <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>)
        plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;degree = &#34;</span><span style="color:#f92672">+</span> str(theta))
        plt<span style="color:#f92672">.</span>show()
</code></pre></div><h3 id="synthesis-of-affine-transformation">Synthesis of affine transformation</h3>
<p>Affine transformations can be combined by taking the matrix product. When we transform $A_1-&gt;A_2$, we take the product $A_2A_1P$ ($P$ is a matrix of points). Note that the order is reversed. Also, <strong>the exchange law does not hold</strong>, and the result will be different if the order is changed.For example, suppose $A_1$ doubles $x,y$ and $A_2$ moves 50 in the $x$ direction and 100 in the $y$ direction. At this time, $A_2A_1(A_1 \to A_2)$ is</p>
<p>$$A_2A_1 = \begin{bmatrix}1 &amp; 0 &amp; 50 \\ 0 &amp; 1 &amp; 100 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix}2 &amp; 0 &amp; 0 \\ 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} = \begin{bmatrix} 2 &amp; 0 &amp; 50 \\ 0 &amp; 2 &amp; 100 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag {8}$$</p>
<p>However, $A_1A_2(A_2 \to A_1)$ is</p>
<p>$$A_1A_2 = \begin{bmatrix}2 &amp; 0 &amp; 0 \\ 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix}1 &amp; 0 &amp; 50 \\ 0 &amp; 1 &amp; 100 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} = \begin{bmatrix} 2 &amp; 0 &amp; 100 \\ 0 &amp; 2 &amp; 200 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag {9}$$</p>
<p>The parallel movement size changes. This represents the difference between &ldquo;translation and then enlargement, or enlargement and then translation&rdquo;. If you don&rsquo;t know the order, it&rsquo;s a good idea to try a simple example like this.</p>
<h3 id="example-5-a-person-with-a-bad-head-who-approaches-while-spinning">Example 5: A person with a bad head who approaches while spinning</h3>
<p>Since we can apply the affine transformation to any number of points, it is okay if there are thousands of points. Here, &ldquo;stupid person&rdquo; (from free material)</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/232088/8f53429c-b198-492e-d5fe-cba9c377b876.png" alt="atamanowaruihito.png"></p>
<p>Convert to the point cloud data, and plot it while synthesizing the affine transformation of expansion and rotation. Almost the same as Example 4.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> PIL <span style="color:#f92672">import</span> Image

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">atamanowaruihito</span>():
    <span style="color:#66d9ef">with</span> Image<span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;atamanowaruihito.png&#34;</span>) <span style="color:#66d9ef">as</span> img:
        img <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>resize((img<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>, img<span style="color:#f92672">.</span>height <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>))
        img <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>convert(<span style="color:#e6db74">&#34;L&#34;</span>)<span style="color:#f92672">.</span>point(<span style="color:#66d9ef">lambda</span> x: <span style="color:#ae81ff">255</span> <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">128</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e"># grayed and binarized</span>
        points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>stack(np<span style="color:#f92672">.</span>where(np<span style="color:#f92672">.</span>array(img) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e"># yx -&gt; xy</span>
        points[<span style="color:#ae81ff">1</span>,:] <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>height<span style="color:#f92672">-</span>points[<span style="color:#ae81ff">1</span>,:] <span style="color:#75715e"># Corrects the y-axis from positive down to positive up (2, 5912)</span>
        points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate([points, np<span style="color:#f92672">.</span>ones_like(points[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">1</span>, :])], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e"># Add 1 to the 3rd line (3, 5912)</span>

    <span style="color:#66d9ef">for</span> theta <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">360</span>, <span style="color:#ae81ff">1</span>):
        rad <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>radians(theta)
        rotate_matrix <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([
            [np<span style="color:#f92672">.</span>cos(rad), <span style="color:#f92672">-</span>np<span style="color:#f92672">.</span>sin(rad), <span style="color:#ae81ff">0</span>],
            [np<span style="color:#f92672">.</span>sin(rad), np<span style="color:#f92672">.</span>cos(rad), <span style="color:#ae81ff">0</span>],
            [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]], np<span style="color:#f92672">.</span>float32) <span style="color:#75715e"># rotation matrix</span>
        scale_matrix <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>, dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float32) <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> theta <span style="color:#f92672">/</span> <span style="color:#ae81ff">180</span>)
        <span style="color:#75715e"># Affine transformation composition is matrix product of transformation matrices</span>
        If <span style="color:#75715e">#A1-&gt;A2, multiply by A2A1 (note the order)</span>
        affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(scale_matrix, rotate_matrix) <span style="color:#75715e"># rotate and scale</span>
                
        dest_points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(affine, points)[:<span style="color:#ae81ff">2</span>, :] <span style="color:#75715e"># point cloud after rotation</span>
        rectangle <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate((np<span style="color:#f92672">.</span>min(dest_points, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>),
                                    np<span style="color:#f92672">.</span>max(dest_points, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)]) <span style="color:#75715e"># Bounding Box for point cloud</span>

        plt<span style="color:#f92672">.</span>clf()
        plt<span style="color:#f92672">.</span>scatter(dest_points[<span style="color:#ae81ff">0</span>,:], dest_points[<span style="color:#ae81ff">1</span>,:], s<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)

        ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
        rect <span style="color:#f92672">=</span> patches<span style="color:#f92672">.</span>Rectangle(rectangle[:<span style="color:#ae81ff">2</span>], <span style="color:#f92672">*</span>(rectangle[<span style="color:#ae81ff">2</span>:]<span style="color:#f92672">-</span>rectangle[:<span style="color:#ae81ff">2</span>]),
                                 linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, edgecolor<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;magenta&#34;</span>, fill<span style="color:#f92672">=</span>False)
        ax<span style="color:#f92672">.</span>add_patch(rect)
        plt<span style="color:#f92672">.</span>ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">750</span>, <span style="color:#ae81ff">750</span>)
        plt<span style="color:#f92672">.</span>xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">750</span>, <span style="color:#ae81ff">750</span>)
        plt<span style="color:#f92672">.</span>show()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/232088/8de73652-bc2f-e95c-5c0c-f9eb3924b76a.gif" alt="affine_03.gif"></p>
<p>The Bounding Box can be calculated in the same way as the square example.</p>
<h2 id="apply-multiple-affine-transformations-at-the-same-time">Apply multiple affine transformations at the same time</h2>
<p>The tensor calculation starts from here. Instead of combining affine transformations, let&rsquo;s consider how to apply multiple affine transformations to the same point at the same time. It&rsquo;s hard to express in an expression, so think in code.</p>
<p>If there was one affine transformation, the transformation matrix had the shape <code>(3, 3)</code>. Then how about two transformations, that is, a shape called <code>(2, 3, 3)</code>? That is,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># points: (3, 4), affines: (2, 3, 3)</span>
output <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(affines<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]):
        output[i] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(affines[i], points)
</code></pre></div><p>I want to calculate. Actually this is one liner without using for loop,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">output <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(affines, points)
</code></pre></div><p>Can be calculated with.</p>
<h3 id="example-6-multiple-affine-transformations-of-a-rectangle">Example 6: Multiple affine transformations of a rectangle</h3>
<p>Let&rsquo;s try three affine transformations in Example 3.</p>
<ol>
<li>Original rectangle as it is (identity transformation)</li>
<li>Enlarge $(2, 3)$ times in $(x, y)$ direction and translate $(5, -1)$</li>
<li>Expand $(3, 1)$ times in the direction of $(x, y)$ and translate $(10, 2)$</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> matplotlib <span style="color:#f92672">import</span> cm

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rectangle_multi</span>():
    w, h <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>
    points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0</span>, w, w, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, h, h], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]], np<span style="color:#f92672">.</span>float32) <span style="color:#75715e"># (3, 4)</span>
    a1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>) <span style="color:#75715e"># identity transformation</span>
    a2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]]) <span style="color:#75715e"># (3, 3)</span>
    a3 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]]) <span style="color:#75715e"># (3, 3)</span>
    affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>stack([a1, a2, a3], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e"># (3, 3, 3)</span>
    dest <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(affine, points) <span style="color:#75715e"># (3, 3, 4)</span>

    cmap <span style="color:#f92672">=</span> cm<span style="color:#f92672">.</span>get_cmap(<span style="color:#e6db74">&#34;tab10&#34;</span>)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
        plt<span style="color:#f92672">.</span>scatter(dest[i,<span style="color:#ae81ff">0</span>,:], dest[i, <span style="color:#ae81ff">1</span>,:], color<span style="color:#f92672">=</span>cmap(i))
    plt<span style="color:#f92672">.</span>show()
</code></pre></div><p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/232088/cf763059-4f09-4271-3b7c-d5d9c37ae7b1.png" alt="affine_04.png"></p>
<p>We were able to perform 3 different transformations with just one calculation. In this way, <strong>one-to-many transformation</strong> can also be done by using affine transformation by tensor.</p>
<h3 id="example-7-anchor-box-for-object-detection">Example 7: Anchor Box for object detection</h3>
<p>In object detection, the Bounding Box seen from each point (Anchor) of the output of the neural network is predicted. Bounding Box corresponds to the (coordinates) of the raw image, but many coordinates appear in object detection. For example,</p>
<ul>
<li>The scale of the axis changes because the image is scaled according to the input size of the neural network.</li>
<li>In order to predict the value of the Bounding Box seen from the anchor, the same operation as parallel movement is entered for each anchor</li>
<li>When using RoI Pooling, there is a concept of coordinates in RoI (there is scale and translation for crop).</li>
</ul>
<p>In other words, flexible point conversion from “coordinates to coordinates” is required. This coordinate transformation can be unified by affine transformation using a tensor.</p>
<p>Now consider the following:</p>
<ul>
<li>The output resolution of the neural network is 4x4, and there are also 4x4 Anchor Boxes.</li>
<li>From input to output of neural network, the resolution becomes 1/16. In other words, one point of Anchor Box corresponds to the resolution of 16x16.</li>
<li>The image is resized by 1.5 times in the horizontal direction and 0.8 times in the vertical direction in the preprocessing, and the data of the Ground Truth Bounding Box is based on the pixel value before transformation.</li>
<li>Do not rotate or flip the image horizontally (thus only the upper left and lower right of the Bounding Box should be considered)</li>
<li>When the Bounding Box is in the format of <code>(ymin, xmin, ymax, xmax)</code>, Ground Truth gives ```(10, 20, 30, 40), (30, 30, 50, 50)`. There are two. At this time, I would like to find the coordinates of the Bounding Box of Ground Truth as seen from each Anchor Box. However, each Anchor is at the midpoint of a 1x1 pixel, and the point where both $x and y$ are offset by 0.5 minutes is the origin of each anchor.</li>
</ul>
<p>Consider two affine transformations as a policy.</p>
<ol>
<li>Pre-processing (original image → input image) affine transformation. 1.5x in the $x$ direction and 0.8x in the $y$ direction. The shape of <code>(3, 3)</code>.2. Input image → anchor affine transformation. The shape of <code>(4, 4, 3, 3)</code>, with the affine transformation of <code>(3, 3)</code> stacked vertically and horizontally 4x4. The affine transformation at the position of <code>(i, j, :, :)</code>$(0\leq i,j \leq 3)$ is as follows. The sign is negative because it is a parallel movement as seen from the Anchor Box.</li>
</ol>
<p>$$\begin{bmatrix}1/16 &amp; 0 &amp; -0.5+i \\ 0 &amp; 1/16 &amp; -0.5+j \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag{10}$$</p>
<p>All you have to do is to combine the two, 1 and 2. This is delicious. If you want to perform the inverse transformation (anchor → original image), take the inverse matrix of the composite tensor of 1 and 2, that is,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">inv_transform <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(combined_affine)
</code></pre></div><p>The tensor of the inverse transformation can be taken just by doing. If the input of <code>np.linalg.inv</code> is a tensor, stack the inverse matrices of the last two axes.</p>
<p>In object detection, notation of $(x, y)$ is more convenient than notation of $(y, x)$ (because the image tensor is $(B, H, W, C)$), so translation The affine transformation of $t_x, t_y$ and scaling $s_x, s_y$ is</p>
<p>$$\begin{bmatrix}s_y &amp; 0 &amp; t_y \\ 0 &amp; s_x &amp; t_X \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \tag{11}$$</p>
<p>It is represented by. Even if the axes are exchanged, it works as an affine transformation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">anchor_box</span>():
    bounding_boxes <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>], [<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>]]) <span style="color:#75715e"># (2, 4)</span>
    points <span style="color:#f92672">=</span> bounding_boxes<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>T <span style="color:#75715e"># (4, 2) -&gt; (2, 4)</span>
    points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate([points, np<span style="color:#f92672">.</span>ones_like(points[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">1</span>,:])], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e"># (3, 4)</span>
    <span style="color:#75715e"># Think in yx coordinates</span>
    a1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0.8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1.5</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]]) <span style="color:#75715e"># 0.8 times in y direction and 1.5 times in x direction</span>
    <span style="color:#75715e">#Anchor</span>
    offset_x, offset_y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>meshgrid(<span style="color:#f92672">-</span>(np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>), <span style="color:#f92672">-</span>(np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>)) <span style="color:#75715e"># See the origin of the input image from the anchor, so move in parallel</span>
    Broadcast to a2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>)) <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>)<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">16.0</span> <span style="color:#75715e"># (4, 4, 3, 3)</span>
    a2[:,:,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> offset_y
    a2[:,:, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> offset_x
    a2[:,:, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
    <span style="color:#75715e">#Affine synthesis</span>
    affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(a2, a1)
    <span style="color:#75715e">#Affine transformation</span>
    raw_dest <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(affine, points) <span style="color:#75715e"># (4, 4, 3, 4)</span>
    dest <span style="color:#f92672">=</span> raw_dest<span style="color:#f92672">.</span>swapaxes(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)[:,:,:,:<span style="color:#ae81ff">2</span>] <span style="color:#75715e"># (4, 4, 4, 3) transposition tensor version -&gt; (4, 4, 4, 2)</span>
    dest <span style="color:#f92672">=</span> dest<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Coordinates after affine transformation when seeing Bounding Box of original image at each anchor&#34;</span>)
    <span style="color:#66d9ef">print</span>(dest)

    <span style="color:#75715e"># Reverse conversion and check</span>
    raw_inv <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(affine), raw_dest)
    inv <span style="color:#f92672">=</span> raw_inv<span style="color:#f92672">.</span>swapaxes(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)[:,:,:,:<span style="color:#ae81ff">2</span>]
    inv <span style="color:#f92672">=</span> inv<span style="color:#f92672">.</span>reshape(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>) matches <span style="color:#75715e"># bounding boxes</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Revert the coordinates after conversion to the original values&#34;</span>)
    <span style="color:#66d9ef">print</span>(inv)

    <span style="color:#75715e">#Inverse transformation affine (confirmation)</span>
    inv_transoform <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(affine)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Inverse transformation affine (for debugging)&#34;</span>)
    <span style="color:#66d9ef">print</span>(inv_transoform)
</code></pre></div><details><summary>Click to view output</summary><div>
<pre><code class="language-console" data-lang="console">Coordinates after affine transformation when the Bounding Box of the original image is seen at each anchor
[[[[ 0. 1.375 1. 3.25]
   [1. 2.3125 2. 4.1875]]

  [[ 0. 0.375 1. 2.25]
   [1. 1.3125 2. 3.1875]]

  [[ 0. -0.625 1.1.25]
   [1. 0.3125 2. 2.1875]]

  [[ 0. -1.625 1.0.25]
   [1.-0.6875 2. 1.1875]]]


 [[[-1. 1.375 0. 3.25]
   [0. 2.3125 1. 4.1875]]

  [[-1. 0.375 0.2.25]
   [0. 1.3125 1. 3.1875]]

  [[-1. -0.625 0.1.25]
   [0. 0.3125 1. 2.1875]]

  [[-1. -1.625 0. 0.25]
   [0. -0.6875 1. 1.1875]]]


 [[[-2. 1.375 -1. 3.25]
   [-1. 2.3125 0. 4.1875]]

  [[-2. 0.375 -1. 2.25]
   [-1. 1.3125 0. 3.1875]]

  [[-2. -0.625 -1. 1.25]
   [-1. 0.3125 0.2.1875]]

  [[-2. -1.625 -1. 0.25]
   [-1. -0.6875 0. 1.1875]]]


 [[[-3. 1.375 -2. 3.25]
   [-2. 2.3125 -1. 4.1875]]

  [[-3. 0.375 -2. 2.25]
   [-2. 1.3125 -1. 3.1875]]

  [[-3. -0.625 -2. 1.25]
   [-2. 0.3125 -1. 2.1875]]

  [[-3. -1.625 -2. 0.25]
   [-2. -0.6875 -1. 1.1875]]]]
When the converted coordinates are converted back, the original values are restored.
[[[[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]]


 [[[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]]


 [[[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]]


 [[[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]

  [[10. 20. 30. 40.]
   [30. 30. 50. 50.]]]]
Inverse transformation affine (for debugging)
[[[[20. 0. 10.]
   [0. 10.66666667 5.33333333]
   [0. 0. 1.]]

  [[20. 0. 10.]
   [0. 10.66666667 16.]
   [0. 0. 1.]]

  [[20. 0. 10.]
   [0. 10.66666667 26.66666667]
   [0. 0. 1.]]

  [[20. 0. 10.]
   [0. 10.66666667 37.33333333]
   [0. 0. 1. ]]]


 [[[20. 0. 30.]
   [0. 10.66666667 5.33333333]
   [0. 0. 1.]]

  [[20. 0. 30.]
   [0. 10.66666667 16.]
   [0. 0. 1.]]

  [[20. 0. 30.]
   [0. 10.66666667 26.66666667]
   [0. 0. 1.]][[20.          0.         30.        ]
   [ 0.         10.66666667 37.33333333]
   [ 0.          0.          1.        ]]]


 [[[20.          0.         50.        ]
   [ 0.         10.66666667  5.33333333]
   [ 0.          0.          1.        ]]

  [[20.          0.         50.        ]
   [ 0.         10.66666667 16.        ]
   [ 0.          0.          1.        ]]

  [[20.          0.         50.        ]
   [ 0.         10.66666667 26.66666667]
   [ 0.          0.          1.        ]]

  [[20.          0.         50.        ]
   [ 0.         10.66666667 37.33333333]
   [ 0.          0.          1.        ]]]


 [[[20.          0.         70.        ]
   [ 0.         10.66666667  5.33333333]
   [ 0.          0.          1.        ]]

  [[20.          0.         70.        ]
   [ 0.         10.66666667 16.        ]
   [ 0.          0.          1.        ]]

  [[20.          0.         70.        ]
   [ 0.         10.66666667 26.66666667]
   [ 0.          0.          1.        ]]

  [[20.          0.         70.        ]
   [ 0.         10.66666667 37.33333333]
   [ 0.          0.          1.        ]]]]
</code></pre></div></details>
<p>元画像→アンカー、アンカー→元画像の逆変換をしても元のBounding Boxの座標に戻っているのが確認できます。逆変換が行列計算で1本なのは強いです。アンカーの変換がうまく行ってるか見たいときは、逆変換のアフィン（逆行列）を確認するのがわかりやすいです。</p>
<h3 id="具体例8とにかく頭の悪そうな頭の悪い人">具体例8：とにかく頭の悪そうな”頭の悪い人”</h3>
<p>テンソルによるアフィン変換を活用するとこのようなこともできます。以下の動画を見てください。</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/232088/0c973941-3f69-a95e-ae44-65414a3b3c16.gif" alt="affine_05.gif"></p>
<p>解説は割愛しますが気になる方はコードを見てみてください。</p>
<details><summary>クリックしてコードを表示</summary><div>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">atamanowaruihito2</span>():
    <span style="color:#66d9ef">with</span> Image<span style="color:#f92672">.</span>open(<span style="color:#e6db74">&#34;atamanowaruihito.png&#34;</span>) <span style="color:#66d9ef">as</span> img:
        img <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>resize((img<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>, img<span style="color:#f92672">.</span>height <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>))        
        img <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>convert(<span style="color:#e6db74">&#34;L&#34;</span>)<span style="color:#f92672">.</span>point(<span style="color:#66d9ef">lambda</span> x: <span style="color:#ae81ff">255</span> <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">128</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>)  <span style="color:#75715e"># グレー化、二値化</span>
        points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>stack(np<span style="color:#f92672">.</span>where(np<span style="color:#f92672">.</span>array(img) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)  <span style="color:#75715e"># yx -&gt; xyして点群の行列化</span>
        points[<span style="color:#ae81ff">1</span>,:] <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>height <span style="color:#f92672">-</span> points[<span style="color:#ae81ff">1</span>,:]  <span style="color:#75715e"># y軸を下向きが正から上向きが正に修正 (2, 5912)</span>
        points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate([points, np<span style="color:#f92672">.</span>ones_like(points[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">1</span>, :])], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e"># 3行目に1をつける (3, 5912)</span>

    <span style="color:#75715e"># 回転行列用乱数</span>
    a <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">5.0</span>, size<span style="color:#f92672">=</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>))
    b <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">180</span>, <span style="color:#ae81ff">180</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    <span style="color:#75715e"># 拡大行列用乱数</span>
    c <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">1.5</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    d <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">5.0</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    e <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">180</span>, <span style="color:#ae81ff">180</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    f <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">1.0</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape) <span style="color:#f92672">+</span> c
    <span style="color:#75715e"># 平行移動用乱数</span>
    e <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">200</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    g <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">5.0</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    h <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#f92672">-</span><span style="color:#ae81ff">180</span>, <span style="color:#ae81ff">180</span>, size<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span>shape)
    
    <span style="color:#66d9ef">for</span> theta <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">360</span>, <span style="color:#ae81ff">10</span>):
        <span style="color:#75715e"># 回転変換</span>
        rad <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>radians(a <span style="color:#f92672">*</span> theta <span style="color:#f92672">+</span> b)
        rotate_tensor <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>broadcast_to(np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>)[None, None,:], (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>))<span style="color:#f92672">.</span>copy()
        rotate_tensor[:,:, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>cos(rad)
        rotate_tensor[:,:, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>np<span style="color:#f92672">.</span>sin(rad)
        rotate_tensor[:,:, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sin(rad)
        rotate_tensor[:,:, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>cos(rad)
        <span style="color:#75715e"># 拡大変換</span>
        rad <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>radians(d <span style="color:#f92672">*</span> theta <span style="color:#f92672">+</span> e)
        scale_tensor <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>broadcast_to(np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>)[None, None,:], (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>))<span style="color:#f92672">.</span>copy()
        scale_tensor[:,:, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sin(rad) <span style="color:#f92672">+</span> f
        scale_tensor[:,:, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> c <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sin(rad) <span style="color:#f92672">+</span> f
        <span style="color:#75715e"># 個別の平行移動</span>
        rad <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>radians(g <span style="color:#f92672">*</span> theta <span style="color:#f92672">+</span> h)
        transform_tensor <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>broadcast_to(np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>)[None, None,:], (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>))<span style="color:#f92672">.</span>copy()
        transform_tensor[:,:, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> e <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>cos(rad)        
        transform_tensor[:,:, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> e <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sin(rad)
        <span style="color:#75715e"># 全体の平行移動</span>
        shift_x, shift_y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>meshgrid(np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">4</span>), np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">4</span>))
        anchor_tensor <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>broadcast_to(np<span style="color:#f92672">.</span>eye(<span style="color:#ae81ff">3</span>)[None, None,:], (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>))<span style="color:#f92672">.</span>copy()
        anchor_tensor[:,:, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> shift_x <span style="color:#f92672">*</span> <span style="color:#ae81ff">500</span>
        anchor_tensor[:,:, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> shift_y <span style="color:#f92672">*</span> <span style="color:#ae81ff">500</span>

        <span style="color:#75715e"># 回転→拡大→平行移動→全体の平行移動</span>
        affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(anchor_tensor, transform_tensor)
        affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(affine, scale_tensor)
        affine <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(affine, rotate_tensor)
        dest_points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>matmul(affine, points)[:, :, :<span style="color:#ae81ff">2</span>, :] <span style="color:#75715e"># 回転後の点群</span>
        rectangle <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate([np<span style="color:#f92672">.</span>min(dest_points, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>),
                                    np<span style="color:#f92672">.</span>max(dest_points, axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)], axis<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># 点群に対するBounding Box</span>
                                    
        dest_points <span style="color:#f92672">=</span> dest_points<span style="color:#f92672">.</span>swapaxes(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
        rectangle <span style="color:#f92672">=</span> rectangle<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)

        plt<span style="color:#f92672">.</span>clf()
        plt<span style="color:#f92672">.</span>scatter(dest_points[:, <span style="color:#ae81ff">0</span>], dest_points[:, <span style="color:#ae81ff">1</span>], s<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)

        ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>gca()
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(rectangle<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]):
            rect <span style="color:#f92672">=</span> patches<span style="color:#f92672">.</span>Rectangle(rectangle[i, :<span style="color:#ae81ff">2</span>], <span style="color:#f92672">*</span>(rectangle[i, <span style="color:#ae81ff">2</span>:] <span style="color:#f92672">-</span> rectangle[i, :<span style="color:#ae81ff">2</span>]),
                                    linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, edgecolor<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;magenta&#34;</span>, fill<span style="color:#f92672">=</span>False)
            ax<span style="color:#f92672">.</span>add_patch(rect)
        plt<span style="color:#f92672">.</span>ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">750</span>, <span style="color:#ae81ff">2500</span>)
        plt<span style="color:#f92672">.</span>xlim(<span style="color:#f92672">-</span><span style="color:#ae81ff">750</span>, <span style="color:#ae81ff">2500</span>)
        plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;theta = &#34;</span> <span style="color:#f92672">+</span> str(theta))
        plt<span style="color:#f92672">.</span>show()
</code></pre></div></div></details>
    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
