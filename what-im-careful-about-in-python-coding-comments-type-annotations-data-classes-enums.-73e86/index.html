<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>What I&#39;m careful about in Python coding: comments, type annotations, data classes, enums. | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>What I&rsquo;m careful about in Python coding: comments, type annotations, data classes, enums.</h1>
<p>
  <small class="text-secondary">
  
  
  Mar 10, 2020
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>

</p>
<pre><code>## Overview
</code></pre>
<p>I usually code in Python.
Even if I write Python roughly, it often works for some reason, so I just overwrote it properly.
However, when reviewing such code later or showing it to others, it will be &ldquo;What are you doing&hellip;&rdquo; or &ldquo;How do you use this function&hellip;&rdquo;.
So, as a memorandum, I will enumerate the matter that &ldquo;If you take care of these things for the time being, it will be easier to understand to some extent&rdquo;.</p>
<h2 id="comment">Comment</h2>
<p>** Describe the processing purpose, not commenting the processing contents **</p>
<p>The content of the process is set so that it can be tracked by the function name and variable name, and I am conscious of commenting the processing purpose in natural language that is difficult to follow alone ~~ I often forget ~~.</p>
<p>For example, the code is as follows.</p>
<pre><code class="language-python:" data-lang="python:"># Reduce to 1/4 ← Can be imagined from function names and variable names
small_image = resize(image, scale=1/4)
</code></pre><pre><code class="language-python:" data-lang="python:"># Shrink to fit in memory stably when pouring into model
small_image = resize(image, scale=1/4)
</code></pre><p>I don&rsquo;t think it&rsquo;s wrong to comment out what&rsquo;s going on. I&rsquo;m very happy to have a comment on the processing content when it spans multiple lines or the code is not understandable at first glance due to optimization.</p>
<p>However, I think it is redundant to comment the same contents as the code when it is not a hassle to read the code, as in the above example.</p>
<p>If you write a comment with the awareness that the motivation and purpose of processing are difficult to follow from the code, I think that the code will be easy to remember even if you look back over time.</p>
<h2 id="type-annotation">type annotation</h2>
<p>** It is safe to do just the function arguments and return values **</p>
<p>The type annotation in Python is comment + α, which does not guarantee type matching at runtime, but I still think it should be annotated as much as possible.</p>
<h3 id="good-place-to-type-annotate">good place to type annotate</h3>
<pre><code class="language-python:" data-lang="python:">The annotation for the argument and return value of #method is very good (you don't have to see the contents of the method)
class Person:
    def __init__(self, first_name: str, last_name: str, age: int): # annotation for method argument
        self._name: str = first_name +'' + last_name # Annotation for variable
        self._age = age

    def is_older_than(self, age: int) -&gt; bool: # annotation for the return value of the method
        return self._age&gt; age
</code></pre><p>Especially, I don&rsquo;t know how to use the function arguments and return values that are open to the public unless they are type-annotated. Of course, I think that you can describe it in <code>docstring</code>. A highly functional editor should parse <code>docstring</code>.</p>
<h3 id="type-annotations-used-on-a-daily-basis">Type annotations used on a daily basis</h3>
<p>Here&rsquo;s how to type annotate variables with built-in types like <code>int</code> and <code>float</code>, or variables that instantiate a class.</p>
<pre><code class="language-python:" data-lang="python:">age: int = 0
weight: float = 0.0
name: str ='string'
is_student: bool = True

taro: Person = Person('taro','suzuki', 20)
</code></pre><p>Other built-in types that are often used include <code>list</code>, <code>dict</code> and <code>tuple</code>.
Same for these</p>
<pre><code class="language-python:" data-lang="python:">friends: list = [daisuke, tomoko]
parents: tuple = (mother, father)
contacts: dict = {'email':'xxx@mail','phone_number':'XXXX'}
</code></pre><p>You can annotate like this, but if you use <a href="https://docs.python.org/3/library/typing.html">typing module</a>, you can annotate more finely.
For example, in the above example, I know that <code>friends</code> is a list, but I don&rsquo;t know what kind of element should be included. Here is how to annotate elements using <code>typing</code>.</p>
<h3 id="detailed-annotation-of-everyday-type-using-typing">Detailed annotation of everyday type using typing</h3>
<pre><code class="language-Detailed" data-lang="Detailed">from typing import List, Tuple, Dict # import for type annotation

friends: List[Person] = [daisuke, tomoko] #A list with Person instances as elements
parents: Tuple[Person, Person] = (mother, father) #Tuple with two Person instances
contacts: Dict[str, str] = {'email':'xxx@mail','phone_number':'XXXX'} # dictionary with key str and value str
</code></pre><p><code>typing</code> allows for more detailed type annotations.
Personally, I am very relieved to know what kind of dictionary type I expect, especially if there are annotations on the key and value with the type annotation of <code>Dict</code>.</p>
<p>It is also possible to annotate these with a nested structure. For example, some people may have multiple email addresses or phone numbers. Then you will want the value of <code>contacts</code> to be <code>List[str]</code> instead of <code>str</code>. At that time</p>
<pre><code class="language-python:" data-lang="python:">A dictionary in which # key is str and value is str
contacts: Dict[str, List[str]] =
    {
        'email':
            ['xxx@mail','yyy@mail'],
        'phone_number':
            ['XXXX','YYYY']
     }
</code></pre><p>It is possible to annotate like.</p>
<p>Convenient type annotation using ### typing</p>
<p><code>typing</code> allows various annotations other than the ones listed above. We will introduce <code>Union</code> and <code>Optional</code> as the ones we often use.</p>
<h4 id="uniona-b-c-any-of-a-b-c">Union[A, B, C]: Any of A, B, C</h4>
<p>Consider writing a function that changes the weight of a <code>Person</code> instance. It&rsquo;s a very simple implementation, but it changes the weight by the amount of weight received.</p>
<pre><code class="language-python:" data-lang="python:">class Person:
    ...
    def update_weight(self, weight: float) -&gt; float
        self.weight += weight
        return self.weight
</code></pre><p>It seems good at first glance, but I feel a bit sad that only <code>float</code> is accepted as a change. It might be a little convenient if you also receive an <code>int</code>. I would like to have a type annotation of OK if it is an <code>int</code> or a <code>float</code>. You can use <code>Union</code> when you say &ldquo;OK if any of these types&rdquo;.</p>
<pre><code class="language-python:" data-lang="python:">class Person:
    ...
    def update_weight(self, weight: Union[int, float]) -&gt; float
        self.weight += weight
        return self.weight
</code></pre><p>This allows both <code>int</code> and <code>float</code> to be included in the <code>update_weight</code> argument.</p>
<h4 id="optionala-a-or-none">Optional[A]: A or None</h4>
<p>You may find that when you use <code>Union</code>, you often see the notation <code>Union[A, None]</code> in your code.</p>
<p>For example, suppose you have defined an <code>Occupation</code> class that represents a profession. Let&rsquo;s give the <code>Person</code> class its own occupation. However, perhaps <code>Person</code> is a student and may not have a profession. I would like to say that my occupation is <code>Occupation</code> or <code>None</code>. You can use <code>Union</code> at this time.</p>
<pre><code class="language-python:" data-lang="python:">class Person:
    def __init__(..., occupation: Union[Occupation, None]):
        self._occupation = occupation
</code></pre><p>As another example, suppose you want to speed up a function that retrieves a person&rsquo;s passport ID as a string. But you may not have your passport. One way would be to return an empty string. But if you want to make it clear that it doesn&rsquo;t exist, you might consider returning <code>None</code>.</p>
<pre><code class="language-python:" data-lang="python:">class Person:
    def get_passport_id(self) -&gt; Union[str, None]:
        if self.has_passport:
            return self._passport._id
        else:
            return None
</code></pre><p>The more frequently you do such type annotations, the more difficult it becomes. In such a case, an <code>Optional</code> is prepared. <code>Optional</code> is used like <code>Optional[A]</code> and means <code>A</code> or <code>None</code>. <code>Optional[A] = Union[A, None]</code>.</p>
<p>Using <code>Optional</code>, the previous example looks like this:</p>
<pre><code class="language-python:" data-lang="python:">class Person:
    def __init__(..., occupation: Optional[Occupation]):
        self._occupation = occupation

    def get_passport_id(self) -&gt; Optional[str]:
        if self.has_passport:
            return self._passport._id
        else:
            return None
</code></pre><p>It seems that the intention of the code is a little easier to convey, probably because the word <code>Optional</code> is assigned.</p>
<h3 id="type-annotations-that-may-be-useful-with-typing">Type annotations that may be useful with typing</h3>
<p>I&rsquo;m not going to use that much, but it might be useful#### NewType: Create a new type</p>
<p>You can define a new type. For example, as a function that finds the corresponding <code>Person</code> instance from the <code>int_type</code> <code>person_id</code>,</p>
<pre><code class="language-python:" data-lang="python:">def find_by_id(person_id: int) -&gt; Person:
    ...
</code></pre><p>I think you can write something like this. The argument name here is <code>person_id</code>, which is easy to understand, so it may not be confused too much, but you may inadvertently make a mistake of passing <code>occupation_id</code> defined in the same <code>int</code> type as an argument. not.
To prevent such inadvertent mistakes, I dare define the <code>PersonId</code> class</p>
<pre><code class="language-python:" data-lang="python:">class PersonId(int):
    pass


def find_by_id(person_id: PersonId) -&gt; Person:
    ...

p = find_by_id(PersonId(10))
</code></pre><p>However, this incurs the instance creation overhead.
Using <code>NewType</code>,</p>
<pre><code class="language-python:" data-lang="python:">from typing import NewType


PersonId = NewType('PersonId', int)

def find_by_id(person_id: PersonId) -&gt; Person:
    ...

p = find_by_id(PersonId(10))
</code></pre><p>You can write, but this has a small overhead because at runtime the function that returns 10 is called without doing anything. Also, as the meaning of the code, it is easy to see that it is an <code>int</code>, but it prevents human error by redefining it as another type.</p>
<h4 id="typealias-alias-for-complex-types">TypeAlias: Alias for complex types</h4>
<p>For example, if it is about <code>Dict[str, List[str]]</code>, you may read &ldquo;Well, it&rsquo;s a dictionary where <code>str</code> is a key and <code>str</code> is a list of elements, but this is <code>List[Dict [str, Union[int, float, None]]]</code> becomes difficult to understand, and it is a pain to add such type annotations every time in a function that exchanges this type. In that case, if you use TypeAlias,</p>
<pre><code class="language-python:TypeAlias" data-lang="python:TypeAlias">TypeReportCard = List[Dict[str, Union[int, float, None]]]]

def set_report_card(report_card: TypeReportCard):
    ...

set_report_card([{'math': 9.5}, {'english': 7}, {'science': None}])
# Mistakes -&gt; set_report_card(TypeReportCard([{'math': 9.5}, {'english': 7}, {'science': None}]))
</code></pre><p>You can write clearly like. Just make an alias, no special import is needed. Unlike <code>NewType</code>, since it is an alias, it is not necessary to wrap it with an alias name when actually using it as an argument.</p>
<p>It may be interesting to read <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a></p>
<h2 id="data-class">Data class</h2>
<p><strong>When using dictionary type, consider data class once</strong></p>
<p>I wanted to have a person&rsquo;s contact information as data, so I&rsquo;ll use a dictionary.</p>
<pre><code class="language-python:contacts_dictionary" data-lang="python:contacts_dictionary">
contacts: Dict[str, Optional[str]] =
    {
        'email':'xxx@mail',
        'phone_number': None
     }
</code></pre><p>It&rsquo;s a common code that looks nothing like this.
Suppose one day you want to know if a contact has a phone number.</p>
<pre><code class="language-python:" data-lang="python:">def has_phone_number(contacts: Dict[str, Optional[str]]) -&gt; bool:
    return contacts.get('phone_number', None) is not None
# return'phone_number' in contacts and contacts['phone_number'] is not None
</code></pre><p>I think it works without any problems. Two weeks later, this function is needed again. Thanks to the type annotations we can remember what the <code>contacts</code> data is and we can successfully call the function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">has_phone_number({<span style="color:#e6db74">&#39;email&#39;</span>:<span style="color:#e6db74">&#39;xxx@mail&#39;</span>,<span style="color:#e6db74">&#39;phone-number&#39;</span>:<span style="color:#e6db74">&#39;XXXX&#39;</span>})
</code></pre></div><p>However, the return value of this function is <code>False</code>. If you look closely, you have changed the <code>phone_number</code> to <code>phone-number</code>. Because of that, the <code>phone_number</code> doesn&rsquo;t exist and the result is <code>False</code>. With the type annotation of <code>Dict[str, Optional[str]]</code>, I didn&rsquo;t know the name of the required key, so I couldn&rsquo;t remember exactly the key name I decided two weeks ago.</p>
<p>This example may be easier to understand as the implementation of <code>has_phone_number</code> is written just above. But what if the implementation of this function is far away? What if you don&rsquo;t immediately notice that the result is <code>False</code>? I think debugging will be difficult.</p>
<p>It is a standard practice to avoid constants embedded directly in the code as much as possible, but be careful about dictionary keys.</p>
<p>In that case, you may want to consider <a href="https://docs.python.org/3/library/dataclasses.html">data classes</a> once.</p>
<h4 id="dictionary-replacement-by-data-class">Dictionary replacement by data class</h4>
<pre><code class="language-python:" data-lang="python:">Replace with #dataclass
import dataclasses


@dataclasses.dataclass
class Contacts:
    email: Optional[str]
    phone_number: Optional[str]
</code></pre><p><code>dataclasses.dataclass</code> will automatically generate <code>__init__</code>, so the description as a class is sufficient.
Besides, it has various functions such as automatic generation of <code>__eq__</code> and automatic generation of <code>__repr__</code>, but I will omit it this time.</p>
<p>Defining contacts as the data class above, you can implement <code>has_phone_number</code> as below.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">c <span style="color:#f92672">=</span> Contacts(email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;xxx@mail&#39;</span>, phone_number<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;XXXX&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">has_phone_number</span>(contacts: Contacts) <span style="color:#f92672">-&gt;</span> bool:
    <span style="color:#66d9ef">return</span> contacts<span style="color:#f92672">.</span>phone_number <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> None
</code></pre></div><p>This way you access it as a field in the data class, so you don&rsquo;t have to make a typo (since the editor will support the checks and suggestions).</p>
<p>Also, unlike when it was defined in <code>Dict[str, Optional[str]]</code>, the key name (field name) was fixed and a type was added for each key. Is more concrete.</p>
<h4 id="supplement-named-tuple-dictionary-replacement">Supplement: Named Tuple dictionary replacement</h4>
<p>The data class is a feature of Python 3.7, so if you use 3.6 or lower, you may consider <code>typing</code> <code>NamedTuple</code>. <code>NamedTuple</code> is used like this.</p>
<pre><code class="language-python:NamedTuple" data-lang="python:NamedTuple">Replace with # Named Tuple
from typing import NamedTuple


class Contacts(NamedTuple):
    email: Optional[str]
    phone_number: Optional[str]

c = Contacts(email='xxx@mail', phone_number='XXXX')

def has_phone_number(contacts: Contacts) -&gt; bool:
    return contacts.phone_number is not None
</code></pre><p>The description is almost the same as <code>dataclass</code>, but <code>dataclass</code> has the power to enable more detailed settings, whereas <code>NamedTuple</code> is just a named tuple.</p>
<h2 id="enumerated-type-enum">Enumerated type (enum)</h2>
<p>The last is <a href="https://docs.python.org/3/library/enum.html">Enum</a>.</p>
<p>It&rsquo;s very useful when a variable can only have A, B or C&hellip; For example, I often write code like this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">display</span>(object_shape: str):
    <span style="color:#66d9ef">if</span> object_shape <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;circle&#39;</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">elif</span> object_shape <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;rectangle&#39;</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">elif</span> object_shape <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;triangle&#39;</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">NotImplementedError</span>

display(<span style="color:#e6db74">&#39;circle&#39;</span>)
</code></pre></div><p>When you divide the processing according to the state, you write like this, the management of the state becomes complicated later, or you do not know the state name and search for implementation &hellip; Also, if you look only at the type, it looks like anything is possible with <code>str</code>, but in fact it will be an error except for some strings.</p>
<p>At such time, it may be easier to write by using enumeration type (<code>enum</code>).</p>
<pre><code class="language-python:" data-lang="python:">from enum import Enum


class ObjectShape(Enum):
    CIRCLE = 0
    RECTANGLE = 1
    TRIANGLE = 2

def display(object_shape: ObjectShape):
    if object_shape is ObjectShape.CIRCLE:
        ...
    elif object_shape is ObjectShape.RECTANGLE:
        ...
    elif object_shape is ObjectShape.TRIANGLE:
        ...
    else:
        raise NotImplementedError

display(ObjectShape.CIRCLE)
</code></pre><p>Now you don&rsquo;t have to worry about typos, and you can see what is allowed by looking at the type.Also, this time, all numbers were manually assigned to the <code>Enum</code> identifiers, but this number should have no special meaning, so</p>
<pre><code class="language-python:auto" data-lang="python:auto">import enum


class ObjectShape(enum.Enum):
     CIRCLE = enum.auto()
     RECTANGLE = enum.auto()
     TRIANGLE = enum.auto()
</code></pre><p>I think it&rsquo;s best to have a unique value automatically assigned like this.</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
