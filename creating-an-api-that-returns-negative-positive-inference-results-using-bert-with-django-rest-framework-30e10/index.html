<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>Creating an API that returns negative/positive inference results using BERT with Django REST framework | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Creating an API that returns negative/positive inference results using BERT with Django REST framework</h1>
<p>
  <small class="text-secondary">
  
  
  Dec 20, 2019
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/django"> Django</a></code></small>


<small><code><a href="https://memotut.com/tags/natural-language-processing"> natural language processing</a></code></small>


<small><code><a href="https://memotut.com/tags/drf"> DRF</a></code></small>


<small><code><a href="https://memotut.com/tags/bert"> bert</a></code></small>

</p>
<pre><code>This post is the 20th day of &quot;Django Advent Calendar 2019-Qiita&quot;.
</code></pre>
<p><a href="https://twitter.com/shinya_hd">siny</a>.</p>
<p>In this article, I summarized the content of the challenge to create a Rest API that returns negative/positive inference results using <strong>Django REST framework</strong> and <strong>BERT model</strong>.</p>
<ul>
<li>Since DRF and BERT were implemented for the first time this time, I would appreciate it if you could point out any mistakes or points such as &ldquo;It&rsquo;s better to do this more!&rdquo;</li>
</ul>
<p>#Introduction
For the purposes of this article, Django does not explain the parts involved in implementing the BERT model.
For the implementation and learning of the BERT model using the Japanese dataset used in this article, <a href="https://qiita.com/ysiny/items/b01250228e0c5cc0e647">** Natural Language Processing Advent Calendar 2019 25th day (Creating a negative/positive classifier using BERT)**</a>&rdquo;.</p>
<p>First of all, it is a schematic diagram of the overall processing of the DRF environment assumed this time.</p>
<img width="680" alt="drf_bert.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/215810/5e224c02-5b9e-bb70-7b25-9cd5e4a02701.png">
<p>The operation itself is simple, it is a REST API that infers (binary classification) whether the sentence given as input data is negative or positive, and returns the result to the client side.</p>
<p>*In the overview diagram, we use Azure data science environment (DSVM), but this time we will build using a local development server.</p>
<p>[API demo video]
<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/215810/711906b1-d785-a5c6-f850-f4fe18fcb384.gif" alt="BERT_DRF.gif"></p>
<p>The module implemented in this article is in <a href="https://github.com/sinjorjob/django-drf-dl.git">this git repository</a>, so please download and use it accordingly.</p>
<p>Regarding BERT, [Book &ldquo;Learn while making! Development deep learning with PyTorch&rdquo;](<a href="https://www.amazon.co.jp/%E3%81%A4%E3%81%8F%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6-PyTorch%E3%81%AB%E3%82%88%E3%82%8B%E7%99%BA%E5%B1%95%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%83%A9%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0-%E5%B0%8F%E5%B7%9D%E9%9B%84%E5%A4%AA%E9%83%8E/dp/Createdwithreferenceto(4839970254)">https://www.amazon.co.jp/%E3%81%A4%E3%81%8F%E3%82%8A%E3%81%AA%E3%81%8C%E3%82%89%E5%AD%A6%E3%81%B6-PyTorch%E3%81%AB%E3%82%88%E3%82%8B%E7%99%BA%E5%B1%95%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%83%A9%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0-%E5%B0%8F%E5%B7%9D%E9%9B%84%E5%A4%AA%E9%83%8E/dp/Createdwithreferenceto(4839970254)</a>.
In the above book, the negative/positive classification of the BERT model was based on English data, so we have improved to enable negative/positive classification based on the Japanese data set based on the book.</p>
<p>#table of contents</p>
<ol>
<li>Assumption</li>
<li>Environmental construction</li>
<li>Creating Django REST framework</li>
<li>Inference using REST API</li>
<li>Simple tool</li>
<li>Summary</li>
<li>Reference books</li>
</ol>
<h1 id="1-assumption">1. Assumption</h1>
<p>The contents of this article have been confirmed to work in the following environments.</p>
<h2 id="local-environment">Local environment</h2>
<table>
<thead>
<tr>
<th align="left">Item</th>
<th align="left">Meaning</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">OS</td>
<td align="left">Ubuntu for Windows 10</td>
<td></td>
</tr>
<tr>
<td align="left">BERT model</td>
<td align="left">Kyoto University&rsquo;s <a href="http://nlp.ist.i.kyoto-u.ac.jp/index.php?BERT%E6%97%A5%FinetuningbasedonE6%9C%AC%E8%AA%9EPretrained%E3%83%A2%E3%83%87%E3%83%AB">pytorch-pretrained-BERT model</a>.</td>
<td></td>
</tr>
<tr>
<td align="left">Morphological analysis</td>
<td align="left">Juman++ (v2.0.0-rc2) or (v2.0.0-rc3)</td>
<td></td>
</tr>
<tr>
<td align="left">Django</td>
<td align="left">2.2.5</td>
<td></td>
</tr>
<tr>
<td align="left">djangorest framework</td>
<td align="left">3.10.3</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="2-environment-construction">2. Environment construction</h1>
<p>This time we will build a DRF that operates in the Ubuntu environment of Windows 10.
First of all, use conda to create a virtual environment and install the required modules.</p>
<h2 id="installation-of-various-modules">Installation of various modules</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
conda create <span style="color:#f92672">-</span>n drf python<span style="color:#f92672">=</span><span style="color:#ae81ff">3.6</span>
conda activate drf
conda install pytorch<span style="color:#f92672">=</span><span style="color:#ae81ff">0.4</span> torchvision <span style="color:#f92672">-</span>c pytorch
conda install pytorch<span style="color:#f92672">=</span><span style="color:#ae81ff">0.4</span> torchvision cudatoolkit <span style="color:#f92672">-</span>c pytorch
conda install pandas scikit<span style="color:#f92672">-</span>learn django
</code></pre></div><p>If conda doesn&rsquo;t work, install with pip.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
pip install mojimoji
pip install attrdict
pip install torchtext
pip install pyknp
pip install djangorestframework
</code></pre></div><h2 id="install-juman">Install Juman++</h2>
<p>Since the BERT Japanese Pretrained model used this time performs morphological analysis with Juman++ (v2.0.0-rc2) for the input text, I will match the morphological analysis tool with <strong>Juman++</strong> in this article.
The Juman++ installation procedure is summarized in another article, so please refer to the following.</p>
<p>[<strong>Summary of JUMAN++ installation procedure</strong>] <a href="https://sinyblog.com/deaplearning/juman/">https://sinyblog.com/deaplearning/juman/</a></p>
<p>After Juman++ is installed, it is OK if the morphological analysis is performed in the local environment as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># JUMAN operation check</span>
<span style="color:#f92672">from</span> pyknp <span style="color:#f92672">import</span> Juman
text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I am learning about natural language processing.&#34;</span>
juman <span style="color:#f92672">=</span> Juman()
result <span style="color:#f92672">=</span>juman<span style="color:#f92672">.</span>analysis(text)
result <span style="color:#f92672">=</span> [mrph<span style="color:#f92672">.</span>midasi <span style="color:#66d9ef">for</span> mrph <span style="color:#f92672">in</span> result<span style="color:#f92672">.</span>mrph_list()]
<span style="color:#66d9ef">print</span>(text)
I am learning about natural language processing<span style="color:#f92672">.</span>
<span style="color:#66d9ef">print</span>(result)
[<span style="color:#e6db74">&#39;Nature&#39;</span>,<span style="color:#e6db74">&#39;Language&#39;</span>,<span style="color:#e6db74">&#39;Processing&#39;</span>,<span style="color:#e6db74">&#39;To&#39;</span>,<span style="color:#e6db74">&#39;About&#39;</span>,<span style="color:#e6db74">&#39;Learning&#39;</span>,<span style="color:#e6db74">&#39;Medium&#39;</span>,<span style="color:#e6db74">&#39;Is&#39;</span>,<span style="color:#e6db74">&#39;. &#39;</span>]
</code></pre></div><h1 id="3-create-django-rest-framework">3. Create Django REST framework</h1>
<h2 id="project-creation">Project creation</h2>
<p>First, create a django project. (Project name: drf)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">django<span style="color:#f92672">-</span>admin startproject drf
</code></pre></div><h2 id="application-creation">Application creation</h2>
<p>Then create an application (application name: appv1)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">cd drf
python manage<span style="color:#f92672">.</span>py startapp appv1
</code></pre></div><h2 id="customize-settingspy">Customize settings.py</h2>
<p>Add rest_framework and application (appv1) to INSTALLED_APPS in settings.py.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">INSTALLED_APPS <span style="color:#f92672">=</span> [
    <span style="color:#e6db74">&#39;django.contrib.admin&#39;</span>,
    <span style="color:#e6db74">&#39;django.contrib.auth&#39;</span>,
    <span style="color:#e6db74">&#39;django.contrib.contenttypes&#39;</span>,
    <span style="color:#e6db74">&#39;django.contrib.sessions&#39;</span>,
    <span style="color:#e6db74">&#39;django.contrib.messages&#39;</span>,
    <span style="color:#e6db74">&#39;django.contrib.staticfiles&#39;</span>,
    <span style="color:#e6db74">&#39;rest_framework&#39;</span>, <span style="color:#75715e">#add</span>
    <span style="color:#e6db74">&#39;appv1.apps.Appv1Config&#39;</span>, <span style="color:#75715e">#add</span>

]
</code></pre></div><h2 id="placement-of-bert-related-modules">Placement of BERT related modules</h2>
<p>Create the following folder directly under the application folder (appv1) and place the module as specified.</p>
<table>
<thead>
<tr>
<th align="left">Folder name</th>
<th align="left">Placement module</th>
<th align="left">Purpose</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">vocab</td>
<td align="left">vocab.txt</td>
<td align="left">BERT&rsquo;s dictionary file</td>
<td></td>
</tr>
<tr>
<td align="left">weights</td>
<td align="left">bert_config.json</td>
<td align="left">BERT configuration file</td>
<td></td>
</tr>
<tr>
<td align="left">weights</td>
<td align="left">pytorch_model.bin WEB</td>
<td align="left"><a href="http://nlp.ist.i.kyoto-u.ac.jp/index.php?BERT%E6%97%A5%E6%9C%AC">Kyoto University public HP</a>File(learnedmodel)downloadedfrom%E8%AA%9EPretrained%E3%83%A2%E3%83%87%E3%83%AB)</td>
<td></td>
</tr>
<tr>
<td align="left">weights</td>
<td align="left">bert_fine_tuning_chABSA.pth</td>
<td align="left">BERT fine tuning learned model</td>
<td></td>
</tr>
<tr>
<td align="left">data</td>
<td align="left">**.tsv files 4</td>
<td align="left">learning data, test data, etc.</td>
<td></td>
</tr>
</tbody>
</table>
<p>*For those who want to use the learned model file (bert_fine_tuning_chABSA.pth) for the time being, download the learned model file from <a href="https://drive.google.com/drive/folders/1EKTcda0ktz9xxLsXshvEbgszBMOe7bAv?usp=sharing">here</a> Please arrange.
*Vocab.txt, bert_config.json, pytorch_model.bin are <a href="http://nlp.ist.i.kyoto-u.ac.jp/index.php?BERT%E6%97%A5%E6%9C%AC%E8%AA%9EPretrained%E3%83%A2%E3%83%87%E3%83%AB">HP open to Kyoto University</a>.</p>
<p>Place the following files directly under the application (appv1).</p>
<table>
<thead>
<tr>
<th align="left">File name</th>
<th align="left">Meaning</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">config.py</td>
<td align="left">Various configuration files</td>
<td></td>
</tr>
<tr>
<td align="left">dataloader.py</td>
<td align="left">torchtext Data loader generation file</td>
<td></td>
</tr>
<tr>
<td align="left">predict.py</td>
<td align="left">For inference</td>
<td></td>
</tr>
<tr>
<td align="left">tokenizer.py</td>
<td align="left">BERT word division related shell</td>
<td></td>
</tr>
<tr>
<td align="left">bert.py</td>
<td align="left">BERT model definition</td>
<td></td>
</tr>
</tbody>
</table>
<p>Start Django&rsquo;s shell mode and generate a dictionary data file to use for inference.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">python manage<span style="color:#f92672">.</span>py shell
<span style="color:#f92672">from</span> appv1.config <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> appv1.predict <span style="color:#f92672">import</span> create_vocab_text
TEXT <span style="color:#f92672">=</span> create_vocab_text()
<span style="color:#e6db74">``</span><span style="color:#960050;background-color:#1e0010">`</span>Executing the above will generate appv1<span style="color:#f92672">/</span>data<span style="color:#f92672">/</span>text<span style="color:#f92672">.</span>pkl<span style="color:#f92672">.</span>


The overall directory structure <span style="color:#f92672">is</span> <span style="color:#66d9ef">as</span> follows<span style="color:#f92672">.</span>


</code></pre></div><p>├─drf
│ │ db.sqlite3
│ │ manage.py
│ │ │
│ ├─appv1
│ │ │ admin.py
│ │ │ apps.py
│ │ │ bert.py # BERT model definition
│ │ │ config.py # Various configuration files
│ │ │ dataloader.py # torchtext Data loader generation file
│ │ │ models.py
│ │ │ predict.py # for inference
│ │ │ │ serializers.py # serializer
│ │ │ tests.py
│ │ │ tokenizer.py # BERT word division related shell
│ │ │ views.py
│ │ ├─data</p>
<p>│ │ │ test_dumy.tsv # dummy data
│ │ │ train_dumy.tsv # dummy data
│ │ │ text.pkl # Dictionary data used for inference
│ │ │
│ │ ├─vocab
│ │ │ vocab.txt # Bert dictionary data
│ │ │
│ │ ├─weights
│ │ │ bert_config.json
│ │ │ bert_fine_tuning_chABSA.pth # Fine-tuned Bert model
│ │ │ pytorch_model.bin
│ │ │
│ ├─drf
│ │ │ settings.py
│ │ │ urls.py
│ │ │ wsgi.py</p>
<pre><code>


## Inference operation check

Confirm that the inference process works properly using the BERT trained model on the django environment.

After starting Django's shell mode, execute the following command and give a sample sentence data to confirm that negative or positive judgment can be performed.

*Refer to the comments for the processing performed by each command.

```python
python manage.py shell
- ------------------------------------------------- ---------------------------
# Shell mode from here
In [1]: from appv1.config import *
In [2]: from appv1.predict import predict2, create_vocab_text, build_bert_model
In [3]: from appv1.bert import get_config, BertModel,BertForchABSA, set_learned_params
In [4]: import torch
In [5]: config = get_config(file_path=BERT_CONFIG) # Load BERT config settings
In [6]: net_bert = BertModel(config) #BERT model generation
In [7]: net_trained = BertForchABSA(net_bert) #Negative/Positive classifier combined with the BERT model
In [8]: net_trained.load_state_dict(torch.load(MODEL_FILE, map_location='cpu')) # load the trained weights
   ...: Do
Out[8]: IncompatibleKeys(missing_keys=[], unexpected_keys=[])
In [9]: net_trained.eval() # set to inference mode
Out[9]:
BertForchABSA(
  (bert): BertModel(
    (embeddings): BertEmbeddings(
      (word_embeddings): Embedding(32006, 768, padding_idx=0)
      (position_embeddings): Embedding(512, 768)
      (token_type_embeddings): Embedding(2, 768)
      (LayerNorm): BertLayerNorm()
      (dropout): Dropout(p=0.1)
    )
    (encoder): BertEncoder(
      (layer): ModuleList(
        (0): BertLayer(
          (attention): BertAttention(
            (selfattn): BertSelfAttention(
              (query): Linear(in_features=768, out_features=768, bias=True)
              (key): Linear(in_features=768, out_features=768, bias=True)
              (value): Linear(in_features=768, out_features=768, bias=True)
              (dropout): Dropout(p=0.1)
            )

 ~~Some output is omitted~

    (pooler): BertPooler(
      (dense): Linear(in_features=768, out_features=768, bias=True)
      (activation): Tanh()
    )
  )
  (cls): Linear(in_features=768, out_features=2, bias=True)
)

In [10]: input_text = &quot;In terms of profit and loss, recurring revenues declined due to a decrease in interest rates on loans and gains on the sale of securities.
    ...: A decrease of 7,273 million yen to 67,413 million yen&quot;
In [11]: result = predict2(input_text, net_trained).numpy()[0] # Perform inference (return value is negative or positive)
    ...: Tib)
['[UNK]','Face','To','Ok','Let's','is',',','[UNK]','Revenue','is',',',' Lending','Finance','Interest','Or','Valuable','Securities','Sale','Profit','In','Decrease','To','More',',' ,'Early period','ratio','[UNK]','yen','decrease','no','[UNK]','yen','and','nari','was']
[2, 1, 534, 8, 7779, 26207, 9, 6, 1, 7919, 9, 6, 15123, 306, 28611, 34, 27042, 4190, 3305, 8995, 5, 1586, 8, 52, 6 , 4523, 2460, 1, 387, 1586, 5, 1, 387, 12, 105, 4561, 3]
In [12]: print(result)
0
</code></pre><p>As mentioned above, if negative (0) or positive (1) is returned as the return value to the result variable without error, the operation is OK.</p>
<h2 id="creating-a-serializer">Creating a serializer</h2>
<p>Next, create the DRF serializer.
The serialization and deserialization in DRF are as follows.</p>
<table>
<thead>
<tr>
<th align="left">Processing</th>
<th align="left">Meaning</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Serialize</td>
<td align="left">Convert JSON strings etc. into Django model objects</td>
<td></td>
</tr>
<tr>
<td align="left">Deserialize</td>
<td align="left">Convert model object to JSON format etc.</td>
<td></td>
</tr>
</tbody>
</table>
<p>In this case, Django model is not handled, so it is not converted to a model object.
Instead, create a serializer that &ldquo;** Receives the input sentence you want to judge negative/positive and inputs it to the BERT trained model and outputs the inference result **&rdquo;.</p>
<p>There are three major types of DRF serializers, but this time we want to implement customized processing that does not depend on the model, so we will use the <strong>Serializer class</strong> of rest_framework.</p>
<table>
<thead>
<tr>
<th align="left">Serializer processing</th>
<th align="left">Meaning</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">ModelSerializer</td>
<td align="left">Uses a single model object</td>
<td></td>
</tr>
<tr>
<td align="left">Serializer</td>
<td align="left">Handles a single resource or implements custom processing that does not depend on the model</td>
<td></td>
</tr>
<tr>
<td align="left">ListSerializer</td>
<td align="left">Handling multiple resources</td>
<td></td>
</tr>
</tbody>
</table>
<p>Create a file called serializers.py directly under appv1 and add the following code.</p>
<p><strong>appv1\serializers.py</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> rest_framework <span style="color:#f92672">import</span> serializers
<span style="color:#f92672">from</span> appv1.config <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">from</span> appv1.predict <span style="color:#f92672">import</span> predict2
<span style="color:#f92672">from</span> appv1.bert <span style="color:#f92672">import</span> get_config, BertModel,BertForchABSA
<span style="color:#f92672">import</span> torch


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BertPredictSerializer</span>(serializers<span style="color:#f92672">.</span>Serializer):
    <span style="color:#e6db74">&#34;&#34;&#34;Serializer to get negative/positive classification result of BERT&#34;&#34;&#34;</span>

    input_text <span style="color:#f92672">=</span> serializers<span style="color:#f92672">.</span>CharField()
    neg_pos <span style="color:#f92672">=</span> serializers<span style="color:#f92672">.</span>SerializerMethodField()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_neg_pos</span>(self, obj):
        config <span style="color:#f92672">=</span> get_config(file_path<span style="color:#f92672">=</span>BERT_CONFIG) <span style="color:#75715e">#bert Load config file</span>
        net_bert <span style="color:#f92672">=</span> BertModel(config) <span style="color:#75715e">#BERT model generation</span>
        net_trained <span style="color:#f92672">=</span> BertForchABSA(net_bert) <span style="color:#75715e"># Combines negative/positive classifier with #BERT model</span>
        net_trained<span style="color:#f92672">.</span>load_state_dict(torch<span style="color:#f92672">.</span>load(MODEL_FILE, map_location<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cpu&#39;</span>)) <span style="color:#75715e"># load trained weights</span>
        net_trained<span style="color:#f92672">.</span>eval() <span style="color:#75715e"># set to inference mode</span>
        label <span style="color:#f92672">=</span> predict2(obj[<span style="color:#e6db74">&#39;input_text&#39;</span>], net_trained)<span style="color:#f92672">.</span>numpy()[<span style="color:#ae81ff">0</span>] <span style="color:#75715e"># Get inference result</span>
        <span style="color:#66d9ef">return</span> label

</code></pre></div><p>First, inherit the <strong>serializers.Serializer</strong> of rest_framework and create a serializer called <strong>BertPredictSerializer</strong>.```python
class BertPredictSerializer(serializers.Serializer):
&ldquo;&ldquo;&ldquo;Serializer to get negative/positive classification result of BERT&rdquo;&rdquo;&rdquo;</p>
<pre><code>input_text = serializers.CharField()
neg_pos = serializers.SerializerMethodField()
</code></pre>
<pre><code>
String type CharField is defined as an input (**input_text**).
Since the output will be a dynamic value (inference result), the field value can be determined according to the result of the method **serializers.SerializerMethodField()** is used to define the field **neg_pos** ..

When using SerializerMethodField(), define the applied method name as **get_ + field name**.
In this case, we will define the **get_neg_pos** method.

If you define such a serializer, get_neg_pos method will be executed and the processing result will be returned as a JSON string when the input sentence is POST-sent to the API view that uses BertPredictSerializer.


This time, I want to obtain the negative/positive judgment result by giving the input sentence data to the BERT learning model, so the following processing is described in the get_neg_pos method.

```python
    def get_neg_pos(self, obj):
        config = get_config(file_path=BERT_CONFIG) #bert Load config file
        net_bert = BertModel(config) #BERT model generation
        net_trained = BertForchABSA(net_bert) # Combines negative/positive classifier with #BERT model
        net_trained.load_state_dict(torch.load(MODEL_FILE, map_location='cpu')) # load trained weights
        net_trained.eval() # set to inference mode
        label = predict2(obj['input_text'], net_trained).numpy()[0] # Get inference result
        return label
</code></pre><p>I think you can understand what we are doing by looking at the comments, but here is a supplement.</p>
<ul>
<li><strong>get_config</strong> method: Read from bert_config.json and convert JSON dictionary variable to object variable</li>
<li><strong>BertModel</strong> class: a class that creates a BERT model</li>
<li><strong>BertForchABSA</strong> class: BERT model (BertModel) with a part that determines the negative/positive of chABSA.</li>
<li><strong>predict2</strong> method: A method that infers whether the input sentence is negative or positive and returns 0 or 1</li>
</ul>
<p>The above 4 method classes are defined in <strong>bert.py</strong>.
Load the trained model parameters with <strong>net_trained.load_state_dict</strong>.
The <strong>predict2</strong> method is defined in <strong>predict.py</strong>, and if you pass the input sentence ** to the first argument ** and the trained model instance ** to the second argument ** It is a method ** that returns the result (0 or 1).</p>
<p>This completes the serializer creation.</p>
<h2 id="creating-a-view">Creating a view</h2>
<p>It is OK to implement the view of DRF as either class-based view or function-based view.</p>
<p>This time, I tried using the class-based view called GenericAPIView.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> django.shortcuts <span style="color:#f92672">import</span> render
<span style="color:#f92672">from</span> rest_framework <span style="color:#f92672">import</span> generics, status
<span style="color:#f92672">from</span> rest_framework.response <span style="color:#f92672">import</span> Response
<span style="color:#f92672">from</span> appv1.serializers <span style="color:#f92672">import</span> BertPredictSerializer


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BertPredictAPIView</span>(generics<span style="color:#f92672">.</span>GenericAPIView):
    <span style="color:#e6db74">&#34;&#34;&#34;BERT negative-positive classification prediction class&#34;&#34;&#34;</span>
    serializer_class <span style="color:#f92672">=</span> BertPredictSerializer

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">post</span>(self, request, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):

        serializer <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_serializer(request<span style="color:#f92672">.</span>data)
        <span style="color:#66d9ef">return</span> Response(serializer<span style="color:#f92672">.</span>data, status<span style="color:#f92672">=</span>status<span style="color:#f92672">.</span>HTTP_200_OK)

</code></pre></div><p>It inherits <strong>GenericAPIView</strong> and defines <strong>BertPredictAPIView</strong>.
Specify serialization class (BertPredictSerialzer) defined in serializer.py in <strong>serializer_class</strong> attribute.
Next, define a <strong>post</strong> method in BertPredictAPIView, and internally use the <strong>get_serializer</strong> method of GenericAPIView to get the serializer instance used for Validation.
Specify <strong>request.data</strong> in the argument.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">serializer <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_serializer(request<span style="color:#f92672">.</span>data)
</code></pre></div><p><strong>request.data</strong> works with &ldquo;POST&rdquo;, &ldquo;PUT&rdquo;, and &ldquo;PATCH&rdquo; methods to handle arbitrary data. (Similar function to request.POST)
Finally, if you specify <strong>serializer.data</strong> as the argument of <strong>Response</strong>, the view that returns the inference result will be completed.</p>
<h2 id="urlspy-definition">urls.py definition</h2>
<p>Finally, add the URL definition in drf\urlspy.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> django.contrib <span style="color:#f92672">import</span> admin
<span style="color:#f92672">from</span> django.urls <span style="color:#f92672">import</span> path
<span style="color:#f92672">from</span> appv1 <span style="color:#f92672">import</span> views <span style="color:#75715e">#add</span>


urlpatterns <span style="color:#f92672">=</span> [
    path(<span style="color:#e6db74">&#39;admin/&#39;</span>, admin<span style="color:#f92672">.</span>site<span style="color:#f92672">.</span>urls),
    path(<span style="color:#e6db74">&#39;api/v1/predict/&#39;</span>, views<span style="color:#f92672">.</span>BertPredictAPIView<span style="color:#f92672">.</span>as_view()), <span style="color:#75715e">#add</span>
]

</code></pre></div><p>BertPredictAPIView defined in views.py is defined as a URL pattern called api/v1/predict.
Now you have defined <strong>http://127.0.0.1/api/v1/predict</strong> as the endpoint for RestAPI.</p>
<p>Now, execute djagno migration and run server.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">python manage<span style="color:#f92672">.</span>py migrate
python manage<span style="color:#f92672">.</span>py runserver
</code></pre></div><p>After that, when you access <strong>http://127.0.0.1:8000/api/v1/predict/</strong>, the following screen will be displayed.</p>
<img width="650" alt="drf_bert_02.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/215810/d3c6410c-4020-7dcd-fb4f-aae74b03dce3.png">
<p>Enter the text you want to judge negative/positive in the &ldquo;<strong>input text</strong>&rdquo; at the bottom of the screen and press the <strong>POST</strong> button to infer using the BERT fine tuning learned model and return the result. ..</p>
<p>The following screen shows the result of inputting the text &ldquo;Tokyu Community Co., Ltd. expanded the sales and profits of both condominiums and buildings and increasing profits&rdquo; in the input text and pressing the POST button.</p>
<img width="650" alt="drf_bert_03.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/215810/7e5f5522-c1d6-6b98-dbca-64fb39702de0.png">
<p>As the return value, <strong>input_text (input text)</strong> and <strong>neg_pos(0 or 1)</strong> representing negative/positive are returned.</p>
<p>In the above example, positive (=1) is returned as the inference result.</p>
<h1 id="4-inference-using-rest-api">4. Inference using REST API</h1>
<p>Next, CALL the created REST API from the local client and receive the inference result.
This time, simply run the client and server on the same PC.</p>
<p>Once the development server is started with python manage.py runserver, open the DOS screen etc. in another window and execute the python command to make the python code executable, and execute the following code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> urllib.request
<span style="color:#f92672">import</span> urllib.parse
<span style="color:#f92672">import</span> json
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predict</span>(input_text):
    URL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://127.0.0.1:8000/api/v1/predict/&#34;</span>
    values <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;format&#34;</span>: <span style="color:#e6db74">&#34;json&#34;</span>,
        <span style="color:#e6db74">&#34;input_text&#34;</span>: input_text,
        }
    data <span style="color:#f92672">=</span> urllib<span style="color:#f92672">.</span>parse<span style="color:#f92672">.</span>urlencode({<span style="color:#e6db74">&#39;input_text&#39;</span>: input_text})<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
    request <span style="color:#f92672">=</span> urllib<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>Request(URL, data)
    response <span style="color:#f92672">=</span> urllib<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>urlopen(request)
    result<span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(response<span style="color:#f92672">.</span>read())
    <span style="color:#66d9ef">return</span> result

input_text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;In terms of profit and loss, ordinary income decreased by 7,273 million yen from the previous fiscal year to 67,413 million yen due to a decrease in interest on loans and a gain on sale of securities.&#34;</span>
result <span style="color:#f92672">=</span> predict(input_text)
<span style="color:#66d9ef">print</span>(result)
{<span style="color:#e6db74">&#39;input_text&#39;</span>:<span style="color:#e6db74">&#39;In terms of profit and loss, ordinary income decreased by ¥7,273 million year on year to ¥67,413 million due to a decrease in interest rates on loans and gains on sale of securities.&#39;</span>,<span style="color:#e6db74">&#39;neg_pos &#39;</span>: <span style="color:#ae81ff">0</span>}
<span style="color:#66d9ef">print</span>(result[<span style="color:#e6db74">&#39;input_text&#39;</span>])
In terms of profit <span style="color:#f92672">and</span> loss, ordinary income decreased by <span style="color:#960050;background-color:#1e0010">¥</span><span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">273</span> million year on year to <span style="color:#960050;background-color:#1e0010">¥</span><span style="color:#ae81ff">67</span>,<span style="color:#ae81ff">413</span> million due to a decrease <span style="color:#f92672">in</span> interest on loans <span style="color:#f92672">and</span> gain on sale of securities<span style="color:#f92672">.</span>
<span style="color:#66d9ef">print</span>(result[<span style="color:#e6db74">&#39;neg_pos&#39;</span>])
<span style="color:#ae81ff">0</span>
</code></pre></div><p>Specify <strong>&ldquo;http://127.0.0.1:8000/api/v1/predict/&quot;</strong> as the endpoint.Give json as format and input_text as input data to dictionary variable values.</p>
<p>After that, if you throw it with the POST method together with the text data encoded for the endpoint using urllib.request.Request, the BertPredictAPIView class defined in views.py is called and the process moves in the sequence of serialization → inference execution. To go.
I will convert the processing result with json.loads so that it can be handled as dictionary type data on python side.</p>
<p>Then, it will be converted into dictionary type data as follows, so you can access the information you want with the key name (input_text, neg_pos).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">{<span style="color:#e6db74">&#39;input_text&#39;</span>:<span style="color:#e6db74">&#39;In terms of profit and loss, ordinary income decreased by ¥7,273 million year on year to ¥67,413 million due to a decrease in interest rates on loans and gains on sale of securities.&#39;</span>,<span style="color:#e6db74">&#39;neg_pos &#39;</span>: <span style="color:#ae81ff">0</span>}
</code></pre></div><h1 id="5-simple-tool">5. Simple tool</h1>
<p>Finally, create a simple command that automatically throws a large amount of input data to the REST API and outputs the inference result.
The csv file and program used below are in <a href="https://github.com/sinjorjob/django-drf-dl">git repository</a> under django-drf-dl/drf/tools/.</p>
<p>Prepare the test.csv file you want to predict as follows. (Column name is INPUT)</p>
<img width="777" alt="bert_testdata.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/215810/0fa961b3-2bc1-f99c-e1fe-8ea87ae0999e.png">
<p>Place predict.py with the following code in the same folder as test.csv.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> pandas <span style="color:#f92672">as</span> pd
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> urllib.request
<span style="color:#f92672">import</span> urllib.parse
<span style="color:#f92672">import</span> json

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predict</span>(input_text):
    URL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://127.0.0.1:8000/api/v1/predict/&#34;</span>
    values <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;format&#34;</span>: <span style="color:#e6db74">&#34;json&#34;</span>,
        <span style="color:#e6db74">&#34;input_text&#34;</span>: input_text,
            }
    data <span style="color:#f92672">=</span> urllib<span style="color:#f92672">.</span>parse<span style="color:#f92672">.</span>urlencode({<span style="color:#e6db74">&#39;input_text&#39;</span>: input_text})<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
    request <span style="color:#f92672">=</span> urllib<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>Request(URL, data)
    response <span style="color:#f92672">=</span> urllib<span style="color:#f92672">.</span>request<span style="color:#f92672">.</span>urlopen(request)
    result<span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(response<span style="color:#f92672">.</span>read())
    <span style="color:#66d9ef">return</span> result[<span style="color:#e6db74">&#39;neg_pos&#39;</span>][<span style="color:#ae81ff">1</span>]

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main__&#39;</span>:
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Start if __name__ ==&#39;__main__&#39;&#34;</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;load csv file ....&#39;</span>)
    df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#34;test.csv&#34;</span>, engine<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;python&#34;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;utf-8-sig&#34;</span>)
    df[<span style="color:#e6db74">&#34;PREDICT&#34;</span>] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>nan <span style="color:#75715e"># add prediction column</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Getting prediction results ....&#39;</span>)
    <span style="color:#66d9ef">for</span> index, row <span style="color:#f92672">in</span> df<span style="color:#f92672">.</span>iterrows():
        df<span style="color:#f92672">.</span>at[index, <span style="color:#e6db74">&#34;PREDICT&#34;</span>] <span style="color:#f92672">=</span> predict(row[<span style="color:#e6db74">&#39;INPUT&#39;</span>])
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;save results to csv file&#39;</span>)
    df<span style="color:#f92672">.</span>to_csv(<span style="color:#e6db74">&#34;predicted_test .csv&#34;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;utf-8-sig&#34;</span>, index<span style="color:#f92672">=</span>False)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Processing terminated normally.&#39;</span>)

</code></pre></div><p>When you start the DOS screen etc. and execute the following command, test.csv is read line by line and thrown to the REST API to receive the inference result.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">python predict<span style="color:#f92672">.</span>py
<span style="color:#f92672">-</span> <span style="color:#f92672">---------------------------------</span>
Start <span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main__&#39;</span>
load csv file <span style="color:#f92672">....</span>
Getting prediction results <span style="color:#f92672">....</span>
save results to csv file
Processing terminated normally<span style="color:#f92672">.</span>
</code></pre></div><p>When the last data is completed, predicted_test.csv with inference results will be generated in the same folder.</p>
<img width="650" alt="bert_predict.png" src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/215810/66b8fe6d-cd60-c40e-1a99-543d7d751e31.png">
<h1 id="6-summary">6. Summary</h1>
<p>This time, I tried to create a REST API that determines a simple negative and positive using a binary classification model of DRF and BERT in the local environment.
In the future, I would like to build a REST API on the Azure platform and apply it to tasks such as multi-classification and FAQ instead of binary classification.</p>
<h1 id="7-reference-books">7. Reference books</h1>
<p>The DRF created in this article was created by slightly applying the content in <a href="https://www.amazon.co.jp/dp/B07XWL8FPM/">Textbook of Django REST Framework that can be used in the field</a> as a base.
This time, I learned DRF with this book for the first time, but it is a very helpful book, so it is recommended for those who want to learn DRF from now on.</p>
<p>Tomorrow is <a href="https://twitter.com/ssh22_">ssh22</a>&rsquo;s &ldquo;Django Advent Calendar 2019-Qiita&rdquo; 21st day article. Thank you!</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
