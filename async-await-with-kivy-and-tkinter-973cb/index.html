<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>Async/await with Kivy and tkinter | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Async/await with Kivy and tkinter</h1>
<p>
  <small class="text-secondary">
  
  
  Dec 12, 2019
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/python3"> Python3</a></code></small>


<small><code><a href="https://memotut.com/tags/tkinter"> Tkinter</a></code></small>


<small><code><a href="https://memotut.com/tags/depressed"> Depressed</a></code></small>

</p>
<pre><code>2018 was a shock to me. I used to play around with [Kivy][kivy] of GUI Framekwork, but I found that using a generator can make ugly code full of callback functions surprisingly readable. Then, while trying various things, I became able to understand async/await asynchronous processing, which was a magic that was unfamiliar to me until then, and I was able to create a little asynchronous processing library. In this article
</code></pre>
<ul>
<li>The process until I realized the wonderfulness of the generator and the native coroutine born from it</li>
<li>How to implement async/await with Kivy and tkinter using it</li>
</ul>
<p>I want to write it down.</p>
<p>(To reduce the amount of text, generator is abbreviated as gen and coroutine is abbreviated as coro.)</p>
<p>#gen&rsquo;s hidden power</p>
<p>##Gen as a device that produces values</p>
<p>I think many introductory books introduce gen as a device that produces value.
(To avoid confusion with the meaning of return as &ldquo;return&rdquo;, yield is expressed as &ldquo;create&rdquo;)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fibonacci</span>():
    a, b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
        <span style="color:#66d9ef">yield</span> a
        a, b <span style="color:#f92672">=</span> b, b<span style="color:#f92672">+</span>a

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> fibonacci():
    print(i, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
    <span style="color:#f92672">import</span> time; time<span style="color:#f92672">.</span>sleep(<span style="color:#f92672">.</span><span style="color:#ae81ff">1</span>)
</code></pre></div><pre><code>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 ...
</code></pre><p>Considering that it is called &ldquo;generator&rdquo;, it may have originally been for that purpose. In fact, until 2018, I had only seen that kind of thing, and I think it was difficult for me to get out of that concept, because most of the time I fetched values with <code>for-in</code>.</p>
<h2 id="get-value-without-using-for-in">Get value without using for-in</h2>
<p>Some introductory books also show examples of using <code>send()</code> to retrieve values from gen.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3">gen <span style="color:#f92672">=</span> fibonacci()
print(gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>))
print(gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>))
print(<span style="color:#e6db74">&#39;a little break&#39;</span>)
<span style="color:#f92672">import</span> time;time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
print(<span style="color:#e6db74">&#39;End of break&#39;</span>)
print(gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>))
print(gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>))
</code></pre></div><pre><code>0
1
A little break
Break end
1
2
</code></pre><p>I think this gives a glimpse of gen&rsquo;s &ldquo;hidden power&rdquo;, but I didn&rsquo;t notice it even at this stage. But what about the next example?</p>
<h2 id="gen-that-produces-nothing">gen that produces nothing</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sub_task</span>():
    print(<span style="color:#e6db74">&#39;sub: process 1&#39;</span>)
    <span style="color:#66d9ef">yield</span>
    print(<span style="color:#e6db74">&#39;sub: process 2&#39;</span>)
    <span style="color:#66d9ef">yield</span>
    print(<span style="color:#e6db74">&#39;sub: process 3&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main_task</span>():
    gen <span style="color:#f92672">=</span> sub_task()
    <span style="color:#66d9ef">try</span>:
        print(<span style="color:#e6db74">&#39;main: Process 1&#39;</span>)
        gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>)
        print(<span style="color:#e6db74">&#39;main: process 2&#39;</span>)
        gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>)
        print(<span style="color:#e6db74">&#39;main: Process 3&#39;</span>)
        gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>)
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">StopIteration</span>:
        <span style="color:#66d9ef">pass</span>

main_task()
</code></pre></div><pre><code>main: Process 1
sub: Process 1
main: Process 2
sub: Process 2
main: Process 3
sub: Process 3
</code></pre><p>You can see that both tasks are progressing little by little with <code>gen.send()</code> and <code>yield</code> as switching points. This is <strong>concurrency</strong> itself!</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/144673/8bae8d02-0c1b-239f-61c6-0628fce483de.png" alt="multi_tasking.svg.png"></p>
<h2 id="hidden-power">hidden power</h2>
<p>This was gen&rsquo;s &ldquo;secret power&rdquo;. gen means</p>
<ul>
<li>It can be paused&hellip; (Stops at the place where you yielded, and starts by <code>gen.send()</code>)</li>
<li>It is possible to communicate with the user side at the stop point&hellip;(You can send a value from the gen side with yield, and from the user side with <code>gen.send()</code>)</li>
</ul>
<p>It was a function-like thing, and it was possible to perform parallel processing ** without relying on <code>multi threading</code> because of its feature of being able to stop.</p>
<h2 id="expectations-for-gen">Expectations for gen</h2>
<p>This made me hope I was suffering from ugly code full of callback functions. For example, if you want to do the following with Kivy</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    print(<span style="color:#e6db74">&#39;Process 1&#39;</span>)
    wait until button <span style="color:#f92672">is</span> pressed
    print(<span style="color:#e6db74">&#39;Process 2&#39;</span>)
    Wait <span style="color:#ae81ff">1</span> second
    print(<span style="color:#e6db74">&#39;Process 3&#39;</span>)
</code></pre></div><p>The actual code is</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#f92672">from</span> kivy.clock <span style="color:#66d9ef">import</span> Clock

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>(button):
    print(<span style="color:#e6db74">&#39;Process 1&#39;</span>)
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">callback2</span>(button):
        button<span style="color:#f92672">.</span>unbind(on_press<span style="color:#f92672">=</span>callback2)
        print(<span style="color:#e6db74">&#39;Process 2&#39;</span>)
        Clock<span style="color:#f92672">.</span>schedule_once(callback3, <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">callback3</span>(__):
        print(<span style="color:#e6db74">&#39;Process 3&#39;</span>)
    button<span style="color:#f92672">.</span>bind(on_press<span style="color:#f92672">=</span>callback2)
</code></pre></div><p>It becomes ugly that you can not even notice. <code>I need to wait for something</code> =&gt; <code>I need to pause the process until something happens</code> =&gt; <code>The following process needs to be separated into different functions</code>. But I want you to recall the <code>sub_task()</code> that came out earlier.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sub_task</span>():
    print(<span style="color:#e6db74">&#39;sub: process 1&#39;</span>)
    <span style="color:#66d9ef">yield</span>
    print(<span style="color:#e6db74">&#39;sub: process 2&#39;</span>)
    <span style="color:#66d9ef">yield</span>
    print(<span style="color:#e6db74">&#39;sub: process 3&#39;</span>)
</code></pre></div><p>Similarly, the callback function does not appear anywhere even though it stopped halfway. That&rsquo;s why I started thinking that if I could use gen, I could get rid of the callback function in Kivy.</p>
<p>#Remove the callback function (Kivy)</p>
<p>I will think about the method from now on, but I would like to say that the current Kivy master branch can already do full-scale asynchronous programming using [asyncio][asyncio_doc] and [trio][trio_doc]. So what I do here is [reinvent the wheel] [wheel]. However, at that time, it was not so, and I was simply interested in gen, so I chose to do something myself.</p>
<h2 id="stop-for-a-certain-time">Stop for a certain time</h2>
<p>I thought that I would put aside the button once and realize the function to stop gen for the time when a numerical value is sent from gen. That&rsquo;s because I happened to see <a href="https://www.youtube.com/watch?v=qaPzlIJ57dk#t=18m34s">BeeWare video</a> doing such a thing and thought it was cool.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    print(<span style="color:#e6db74">&#39;Process 1&#39;</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># wait 2 seconds</span>
    print(<span style="color:#e6db74">&#39;Process 2&#39;</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e"># wait 1 second</span>
    print(<span style="color:#e6db74">&#39;Process 3&#39;</span>)
</code></pre></div><p>Consider how to get gen like above to work as expected. With previous knowledge</p>
<ul>
<li>It is necessary to pass a function to <code>Clock.schedule_once()</code> to reserve the processing to be performed after a certain time on Kivy</li>
<li>You need to call <code>gen.send()</code> to resume gen</li>
</ul>
<p>I know things. Then, &ldquo;Should I pass the function that resumes gen to <code>Clock.schedule_once()</code>?&rdquo;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#f92672">from</span> kivy.clock <span style="color:#66d9ef">import</span> Clock
<span style="color:#f92672">from</span> kivy.app <span style="color:#66d9ef">import</span> App
<span style="color:#f92672">from</span> kivy.uix.widget <span style="color:#66d9ef">import</span> Widget


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">start_gen</span>(gen):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">step_gen</span>(dt):
        <span style="color:#66d9ef">try</span>:
            Clock<span style="color:#f92672">.</span>schedule_once(step_gen, gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>)) <span style="color:#75715e"># C</span>
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">StopIteration</span>:
            <span style="color:#66d9ef">pass</span>
    step_gen(<span style="color:#66d9ef">None</span>) <span style="color:#75715e"># B</span>


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    print(<span style="color:#e6db74">&#39;Process 1&#39;</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e"># D</span>
    print(<span style="color:#e6db74">&#39;Process 2&#39;</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># E</span>
    print(<span style="color:#e6db74">&#39;Process 3&#39;</span>)


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SampleApp</span>(App):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build</span>(self):
        <span style="color:#66d9ef">return</span> Widget()
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_start</span>(self):
        start_gen(some_task()) <span style="color:#75715e">#A</span>

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;__main__&#39;</span>:
    SampleApp()<span style="color:#f92672">.</span>run()
</code></pre></div><p>It was the correct answer. This code works as follows.</p>
<ol>
<li>When the application starts, gen is created and passed to <code>start_gen()</code> (line A)</li>
<li><code>start_gen()</code> immediately calls <code>step_gen()</code> (line B)</li>
<li><code>step_gen()</code> calls <code>gen.send()</code>, so gen starts working (line C)</li>
<li>gen stops at the first yield expression and sends 1 (line D)</li>
<li>Since <code>gen.send(None)</code> evaluates to 1, <code>step_gen()</code> reserves itself to be called again after 1 second (line C).</li>
<li>Since there is nothing more to do, processing returns to the event loop of kivy</li>
<li>One second later, <code>step_gen()</code> is called and <code>gen.send()</code> is called, so gen starts moving from the position where it stopped last time. (C line)</li>
<li>gen stops at the second yield expression and sends 2 (line E)</li>
<li>(Omitted below)</li>
</ol>
<p>It was a shock to be able to wait for a time without using the callback function just by preparing a function of only 7 lines (<code>start_gen()</code>). I am motivated and will improve this more and more.</p>
<h2 id="use-the-value-passed-to-the-callback-functionthe-actual-elapsed-time-is-passed-to-the-callback-function-passed-to-clockschedule_once-since-its-a-big-deal-the-some_task-side-can-receive-it-all-you-have-to-do-is-change-the-gensendnone-part-in-start_gen-to-gensenddt-now-the-some_task-side-can-get-the-actual-elapsed-time-as-follows-entire-codehttpsgistgithubcomgottadiveintopythonf8faea8231f86d74b5e56c459232a986">Use the value passed to the callback functionThe actual elapsed time is passed to the callback function passed to <code>Clock.schedule_once()</code>. Since it&rsquo;s a big deal, the <code>some_task()</code> side can receive it. All you have to do is change the <code>gen.send(None)</code> part in <code>start_gen()</code> to <code>gen.send(dt)</code>. Now the <code>some_task()</code> side can get the actual elapsed time as follows (<a href="https://gist.github.com/gottadiveintopython/f8faea8231f86d74b5e56c459232a986">entire code</a>).</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    print(<span style="color:#e6db74">&#39;Process 1&#39;</span>)
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>
    print(f <span style="color:#e6db74">&#34;When I asked to stop for 1 second, it actually stopped for </span><span style="color:#e6db74">{s:.03f}</span><span style="color:#e6db74"> seconds&#34;</span>)
    print(<span style="color:#e6db74">&#39;Process 2&#39;</span>)
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">2</span>
    print(f <span style="color:#e6db74">&#34;I asked to stop for 2 seconds, but actually stopped for </span><span style="color:#e6db74">{s:.03f}</span><span style="color:#e6db74"> seconds&#34;</span>)
    print(<span style="color:#e6db74">&#39;Process 3&#39;</span>)
</code></pre></div><pre><code>Processing 1
When asked to stop for 1 second, it actually stopped for 1.089 seconds
Process 2
When asked to stop for 2 seconds, it actually stopped for 2.003 seconds
Processing 3
</code></pre><h2 id="wait-for-event">Wait for event</h2>
<p>Next is waiting for event, ideally if the gen side writes as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>(button):
    print(<span style="color:#e6db74">&#39;Process 1&#39;</span>)
    <span style="color:#66d9ef">yield</span> event(button,<span style="color:#e6db74">&#39;on_press&#39;</span>) <span style="color:#75715e"># wait until button is pressed</span>
    print(<span style="color:#e6db74">&#39;Process 2&#39;</span>)
</code></pre></div><p>In the case of event, it is a little complicated because the callback function linked is <ruby><rb>solution</rb><rt> </rt></ruby>, but it is a little complicated, but the procedure is the same, It was realized by passing a function that restarts gen as a callback function for event.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">start_gen</span>(gen):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">step_gen</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        <span style="color:#66d9ef">try</span>:
            gen<span style="color:#f92672">.</span>send((args, kwargs, ))(step_gen)
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">StopIteration</span>:
            <span style="color:#66d9ef">pass</span>
    <span style="color:#66d9ef">try</span>:
        gen<span style="color:#f92672">.</span>send(<span style="color:#66d9ef">None</span>)(step_gen)
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">StopIteration</span>:
        <span style="color:#66d9ef">pass</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">event</span>(ed, name):
    bind_id <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    step_gen <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bind</span>(step_gen_):
        <span style="color:#66d9ef">nonlocal</span> bind_id, step_gen
        bind_id <span style="color:#f92672">=</span> ed<span style="color:#f92672">.</span>fbind(name, callback) <span style="color:#75715e"># Bind the callback function</span>
        <span style="color:#66d9ef">assert</span> bind_id <span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#75715e"># Check if binding succeeded</span>
        step_gen <span style="color:#f92672">=</span> step_gen_

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">callback</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        ed<span style="color:#f92672">.</span>unbind_uid(name, bind_id) <span style="color:#75715e"># solve callback function</span>
        step_gen(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs) <span style="color:#75715e"># resume gen</span>

    <span style="color:#66d9ef">return</span> bind
</code></pre></div><p><a href="https://gist.github.com/gottadiveintopython/bd47909fc010fc17ee552a9db77449a1">Entire code</a></p>
<p>The big difference from the time of stop is that all the processing related to event can be hidden in <code>event()</code>. Thanks to that, <code>start_gen()</code> does not depend on kivy at all, and it is only a simple process of passing <code>step_gen</code> to the callable sent from gen.</p>
<h2 id="generalization">Generalization</h2>
<p>I feel that the above design is very good, so I have hidden the process related to kivy from <code>start_gen()</code> and hidden it in another function because time stop also waits for event.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sleep</span>(duration):
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">lambda</span> step_gen: Clock<span style="color:#f92672">.</span>schedule_once(step_gen, duration)
</code></pre></div><p>Now you can mix <code>sleep()</code> and <code>event()</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>(button):
    <span style="color:#66d9ef">yield</span> event(button,<span style="color:#e6db74">&#39;on_press&#39;</span>) <span style="color:#75715e"># wait until button is pressed</span>
    button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Pressed&#39;</span>
    <span style="color:#66d9ef">yield</span> sleep(<span style="color:#ae81ff">1</span>) <span style="color:#75715e"># wait 1 second</span>
    button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Bye&#39;</span>
</code></pre></div><p><a href="https://gist.github.com/gottadiveintopython/d40b5d71ed03fc8370a541e3fe8263b0">Entire code</a></p>
<p>How gen restarts is entirely up to the callable that gen sends, so if you send something like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sleep_forever</span>():
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">lambda</span> step_gen: <span style="color:#66d9ef">None</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    <span style="color:#66d9ef">yield</span> sleep_forever() <span style="color:#75715e"># wait forever</span>
</code></pre></div><p>It is possible to not restart it.</p>
<p>Wait for ### thread</p>
<p>To check the versatility, I also dealt with things that are not related to Kivy, thread.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">thread</span>(func, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
    <span style="color:#f92672">from</span> threading <span style="color:#66d9ef">import</span> Thread
    return_value <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    is_finished <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        <span style="color:#66d9ef">nonlocal</span> return_value, is_finished
        return_value <span style="color:#f92672">=</span> func(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
        is_finished <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
    Thread(target<span style="color:#f92672">=</span>wrapper, args<span style="color:#f92672">=</span>args, kwargs<span style="color:#f92672">=</span>kwargs)<span style="color:#f92672">.</span>start()
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_finished:
        <span style="color:#66d9ef">yield</span> sleep(<span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">return</span> return_value
</code></pre></div><p>It became a dull way of looking around whether it was terminated regularly, but now the gen side can wait for its termination by executing the passed function on another thread.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SampleApp</span>(App):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_start</span>(self):
        start_gen(self<span style="color:#f92672">.</span>some_task())
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>(self):
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">heavy_task</span>():
            <span style="color:#f92672">import</span> time
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>):
                time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
                print(i)
        button <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root
        button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;start heavy task&#39;</span>
        <span style="color:#66d9ef">yield</span> event(button,<span style="color:#e6db74">&#39;on_press&#39;</span>) <span style="color:#75715e"># wait until button is pressed</span>
        button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;running...&#39;</span>
        <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> thread(heavy_task) <span style="color:#75715e"># execute heavy_task() on another thread and wait for its end</span>
        button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;done&#39;</span>
</code></pre></div><p><a href="https://gist.github.com/gottadiveintopython/d8669d98bd84dd0394d52ac451e60088">Entire code</a></p>
<h3 id="yield-or-yield-from-which-one">yield or yield from, which one?</h3>
<p>It seems that things are going well here, but some problems have become apparent. One is that you have to use yield and yield from differently depending on what you are waiting for. (<code>sleep()</code> and <code>event()</code> are yielded, and <code>thread()</code> is yielded from). Moreover, this depends on the implementation, and if <code>threading.Thread</code> had a mechanism that tells the thread termination with the callback function, <code>thread()</code> could also be implemented so that it could wait in the yield. It is not good to use them differently, so I decided to unify them.</p>
<p>Which one should be unified, but I think the only option is <code>yield from</code>. Because it&rsquo;s easy to make something that you can wait on yield from waiting on yield from, but not the other way around. For example</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_gen</span>():
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p><code>1</code> is</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_gen</span>():
    <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> one()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">one</span>():
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>I can wait with <code>yield from</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_gen</span>():
    <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> another_gen()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">another_gen</span>():
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">4</span>
</code></pre></div><p><code>another_gen()</code> can&rsquo;t possibly wait with <code>yield another_gen()</code>.</p>
<p>Unified to ### yield from</p>
<p>That&rsquo;s why I rewrote <code>sleep()</code> and <code>event()</code> so that they can wait in yield from.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sleep</span>(duration):
    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">lambda</span> step_coro: Clock<span style="color:#f92672">.</span>schedule_once(step_gen, duration))

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">event</span>(ed, name):
    <span style="color:#75715e">#Omitted</span>
    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">yield</span> bind)
</code></pre></div><p>Now the user does not have to distinguish between yield and yield from.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#75715e"># Always yield from</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> sleep(<span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> event(button,<span style="color:#e6db74">&#39;on_press&#39;</span>)
    <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> thread(heavy_task)
</code></pre></div><p><a href="https://gist.github.com/gottadiveintopython/c45184d6312a576c76399b0b6658c834">Entire code</a></p>
<h2 id="problems-with-using-arguments-passed-to-callback-function">Problems with using arguments passed to callback function</h2>
<p>The other problem was that the gen was originally using the argument passed to the callback function as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#ae81ff">1</span>print(f <span style="color:#e6db74">&#34;When I asked to stop for 1 second, it actually stopped for </span><span style="color:#e6db74">{s:.03f}</span><span style="color:#e6db74"> seconds&#34;</span>)
</code></pre></div><p>What&rsquo;s going on now is actually</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    args, kwargs <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> sleep(<span style="color:#ae81ff">1</span>)
    s <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">0</span>]
    print(f <span style="color:#e6db74">&#34;When I asked to stop for 1 second, it actually stopped for </span><span style="color:#e6db74">{s:.03f}</span><span style="color:#e6db74"> seconds&#34;</span>)
</code></pre></div><p>It becomes difficult to get the required value. This is because the dummy argument is <code>def step_gen(*args, **kwargs):</code> so that <code>step_gen()</code> can receive any argument. Fortunately, however, thanks to the unification of yield from now, such processing can be completed on the <code>sleep()</code> side.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sleep</span>(duration):
    args, kwargs <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">lambda</span> step_coro: Clock<span style="color:#f92672">.</span>schedule_once(step_coro, duration)
    <span style="color:#66d9ef">return</span> args[<span style="color:#ae81ff">0</span>]
</code></pre></div><p>Now the user side</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>():
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#f92672">from</span> sleep(<span style="color:#ae81ff">1</span>)
    print(f <span style="color:#e6db74">&#34;When I asked to stop for 1 second, it actually stopped for </span><span style="color:#e6db74">{s:.03f}</span><span style="color:#e6db74"> seconds&#34;</span>)
</code></pre></div><p>I&rsquo;m done now.</p>
<h2 id="introduction-of-asyncawait-syntax">Introduction of async/await syntax</h2>
<p>Next, I decided to convert what I have created so far so that it can be handled by the async/await syntax introduced in Python 3.5. This was because it was written in various documents that it was a replacement for gen as a coro. For me, I tried to use <code>await</code> with one word because it was shorter and easier to read than <code>yield from</code> with two words. See [Official] [pep492].</p>
<h3 id="conversion-procedure">Conversion procedure</h3>
<p>First, I added <code>@types.coroutine</code> to gen functions such as <code>sleep()</code> and <code>event()</code> which include a yield without from. This is because I didn&rsquo;t know how to rewrite a gen function containing return statements like these as an async function. (If the async function has a yield expression and a value is returned by the return statement, it will be a syntax error: <code>SyntaxError:'return' with value in async generator</code>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#f92672">import</span> types

<span style="color:#a6e22e">@types</span><span style="color:#f92672">.</span>coroutine
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sleep</span>(duration):
    <span style="color:#75715e">#Omitted</span>

<span style="color:#a6e22e">@types</span><span style="color:#f92672">.</span>coroutine
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">event</span>(ed, name):
    <span style="color:#75715e">#Omitted</span>
</code></pre></div><p>On the other hand, <code>thread()</code> and <code>some_task()</code> could be rewritten as pure async functions. In particular</p>
<ul>
<li>change <code>yield from</code> to <code>await</code></li>
<li><code>def</code> to <code>async def</code></li>
</ul>
<p>Replaced.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">thread</span>(func, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
    <span style="color:#75715e">#Omitted</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_finished:
        <span style="color:#66d9ef">await</span> sleep(<span style="color:#ae81ff">3</span>)
    <span style="color:#75715e">#Omitted</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SampleApp</span>(App):
    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>(self):
        <span style="color:#75715e">#Omitted</span>
        <span style="color:#66d9ef">await</span> event(button,<span style="color:#e6db74">&#39;on_press&#39;</span>)
        button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;running...&#39;</span>
        <span style="color:#66d9ef">await</span> thread(heavy_task)
        button<span style="color:#f92672">.</span>text <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;done&#39;</span>
</code></pre></div><p>Finally, replace the character string <code>gen</code> included in the identifier with <code>coro</code> and complete.</p>
<p><a href="https://gist.github.com/gottadiveintopython/dfa155f894c0758702cbfd046497a7fc">Entire code</a></p>
<p>That concludes the Kivy edition. As I forgot to mention, coro can be executed at the same time by <code>start_coro(another_task())</code>. If you want to wait for completion, you can use <code>await another_task()</code>, and if you want it to run in parallel without waiting, use <code>start_coro(another_task())</code>.</p>
<p>Remove the # callback function (tkinter)</p>
<p>Then, when I tried the same thing with tkinter, the procedure was exactly the same as kivy (passing a function that restarts gen/coro as a callback function), so it went smoothly.</p>
<h2 id="wait-for-time-sleep">Wait for time (sleep)</h2>
<p>What is different from Kivy is that Kivy uses a single object called <code>kivy.clock.Clock</code>, whereas tkinter uses a method called <code>.after()</code> for each widget. So in addition to the time you want to stop, you need to specify which widget&rsquo;s <code>.after()</code> is called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#a6e22e">@types</span><span style="color:#f92672">.</span>coroutine
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sleep</span>(widget, duration):
    <span style="color:#66d9ef">yield</span> <span style="color:#66d9ef">lambda</span> step_coro: widget<span style="color:#f92672">.</span>after(duration, step_coro)
</code></pre></div><p>So it is necessary to pass the widget to <code>thread()</code> which uses <code>sleep()</code> internally.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">thread</span>(func, <span style="color:#f92672">*</span>, watcher):
    <span style="color:#75715e">#Omitted</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_finished:
        <span style="color:#66d9ef">await</span> sleep(watcher, <span style="color:#ae81ff">3000</span>) <span style="color:#75715e"># 3000ms stop</span>
    <span style="color:#66d9ef">return</span> return_value
</code></pre></div><h2 id="wait-for-event-1">Wait for event</h2>
<p>Next is event. Before implementation, tkinter&rsquo;s <code>unbind()</code> seems to have [defect] [tkinter_issue], so I modified it as follows, relying on the information at the link destination.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_new_unbind</span>(self, sequence, funcid<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> funcid:
        self<span style="color:#f92672">.</span>tk<span style="color:#f92672">.</span>call(<span style="color:#e6db74">&#39;bind&#39;</span>, self<span style="color:#f92672">.</span>_w, sequence, <span style="color:#960050;background-color:#1e0010">``</span>)
        <span style="color:#66d9ef">return</span>
    func_callbacks <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>tk<span style="color:#f92672">.</span>call(<span style="color:#e6db74">&#39;bind&#39;</span>, self<span style="color:#f92672">.</span>_w, sequence, <span style="color:#66d9ef">None</span>)<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>)
    new_callbacks <span style="color:#f92672">=</span> [l <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> func_callbacks <span style="color:#66d9ef">if</span> l[<span style="color:#ae81ff">6</span>:<span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span> len(funcid)] <span style="color:#f92672">!=</span> funcid]
    self<span style="color:#f92672">.</span>tk<span style="color:#f92672">.</span>call(<span style="color:#e6db74">&#39;bind&#39;</span>, self<span style="color:#f92672">.</span>_w, sequence,<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>join(new_callbacks))
    self<span style="color:#f92672">.</span>deletecommand(funcid)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">patch_unbind</span>():
    <span style="color:#f92672">from</span> tkinter <span style="color:#66d9ef">import</span> Misc
    Misc<span style="color:#f92672">.</span>unbind <span style="color:#f92672">=</span> _new_unbind
</code></pre></div><p>It is replaced with the modified <code>unbind()</code> by calling <code>patch_unbind()</code>. The problem is when to call it, but I think that it is better not to do it arbitrarily because it is modifying tkinter itself. So I decided to have the user explicitly call me. And the implementation of <code>event()</code> is</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#a6e22e">@types</span><span style="color:#f92672">.</span>coroutine
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">event</span>(widget, name):
    bind_id <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    step_coro <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bind</span>(step_coro_):
        <span style="color:#66d9ef">nonlocal</span> bind_id, step_coro
        bind_id <span style="color:#f92672">=</span> widget<span style="color:#f92672">.</span>bind(name, callback,<span style="color:#e6db74">&#39;+&#39;</span>)
        step_coro <span style="color:#f92672">=</span> step_coro_

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">callback</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        widget<span style="color:#f92672">.</span>unbind(name, bind_id)
        step_coro(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)

    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">yield</span> bind)[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]
</code></pre></div><p>Became.</p>
<h2 id="how-to-use">How to use</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#75715e"># Install asynctkinter in advance</span>
<span style="color:#75715e"># pip install git+https://github.com/gottadiveintopython/asynctkinter#egg=asynctkinter</span>

<span style="color:#f92672">from</span> tkinter <span style="color:#66d9ef">import</span> Tk, Label
<span style="color:#f92672">import</span> asynctkinter <span style="color:#66d9ef">as</span> at
fix bug <span style="color:#f92672">in</span> at<span style="color:#f92672">.</span>patch_unbind() <span style="color:#75715e"># unbind()</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">heavy_task</span>():
    <span style="color:#f92672">import</span> time
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">5</span>):
        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
        print(<span style="color:#e6db74">&#39;heavy task:&#39;</span>, i)

root <span style="color:#f92672">=</span> Tk()
label <span style="color:#f92672">=</span> Label(root, text<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Hello&#39;</span>, font<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#ae81ff">60</span>))
label<span style="color:#f92672">.</span>pack()

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">some_task</span>(label):
    label[<span style="color:#e6db74">&#39;text&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;start heavy task&#39;</span>
    event <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> at<span style="color:#f92672">.</span>event(label,<span style="color:#e6db74">&#39;&lt;Button&gt;&#39;</span>) <span style="color:#75715e"># wait for the label to be pressed</span>
    print(event<span style="color:#f92672">.</span>x, event<span style="color:#f92672">.</span>y)
    label[<span style="color:#e6db74">&#39;text&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;running...&#39;</span>
    <span style="color:#66d9ef">await</span> at<span style="color:#f92672">.</span>thread(heavy_task, watcher<span style="color:#f92672">=</span>label) <span style="color:#75715e"># execute heavy_task() on another thread and wait for its end</span>
    label[<span style="color:#e6db74">&#39;text&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;done&#39;</span>
    <span style="color:#66d9ef">await</span> at<span style="color:#f92672">.</span>sleep(label, <span style="color:#ae81ff">2000</span>) <span style="color:#75715e"># wait 2 seconds</span>
    label[<span style="color:#e6db74">&#39;text&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;close the window&#39;</span>

at<span style="color:#f92672">.</span>start(some_task(label))
root<span style="color:#f92672">.</span>mainloop()
</code></pre></div><h1 id="in-conclusion">in conclusion</h1>
<p>Many people may have known that the idea of using gen for parallel processing was [already existed] [video_curious_course] about 10 years ago, but for me it was a fresh knowledge of 1 to 2 years ago and it was a shock. So I ended up writing this article. Perhaps though, if the library side implements the event loop like tkinter, this way, if you entrust the event side implementation to the user side like pygame, you can change the event loop to <code>asyncio</code> or If you implement it as a task on the <code>trio</code>, you can introduce async/await to any basic. Goodbye ugly callback function.</p>
<h1 id="link-collection">link collection</h1>
<ul>
<li><a href="https://github.com/gottadiveintopython/asynckivy">asynckivy</a> &hellip; The latest version of the product made this time</li>
<li><a href="https://github.com/gottadiveintopython/asynctkinter">asynctkinter</a> &hellip; The latest version of the product made this time-<a href="https://www.youtube.com/watch?v=cKPlPJyQrt4">So you want to be a Python expert?</a> &hellip; the video that made me realize the greatness of gen</li>
<li><a href="https://youtu.be/XEkuqe7tSlA">Make You An Async For Great Good!</a> &hellip; <code>asyncio</code> A video to make your own</li>
<li><a href="https://www.oreilly.co.jp/books/9784873118178/">Fluent Python</a> &hellip; The most detailed gen/coro in Japanese literature I know. The python version I&rsquo;m using is low on the ball.</li>
</ul>
<p>[wheel]:https://ja.wikipedia.org/wiki/%E8%BB%8A%E8%BC%AA%E3%81%AE%E5%86%8D%E7%99%BA%E6%98 %8E
[trio_doc]:https://trio.readthedocs.io/
[asyncio_doc]:https://docs.python.org/ja/3/library/asyncio.html
[pep492]:https://www.python.org/dev/peps/pep-0492/
[tkinter_issue]:https://stackoverflow.com/questions/6433369/deleting-and-changing-a-tkinter-event-binding
[video_curious_course]:https://youtu.be/Z_OAlIhXziw</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
