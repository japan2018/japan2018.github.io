<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>numpy on Some Title</title>
    <link>https://japan2018.github.io/tags/numpy/</link>
    <description>Recent content in numpy on Some Title</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://japan2018.github.io/tags/numpy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Numpy 2-D matrix calculation and performance comparison with for</title>
      <link>https://japan2018.github.io/numpy-2-d-matrix-calculation-and-performance-comparison-with-for-fde10/</link>
      <pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/numpy-2-d-matrix-calculation-and-performance-comparison-with-for-fde10/</guid>
      <description>How does this article write the following two-dimensional matrix calculation in Python numpy? That is.  for i in range(0, ni-1): for j in range(0, nj-1): y[i, j] = x[i, j] + x[i+1, j]-x[i+1, j+1] * x[i, j+1] Later, we will compare the performance. The Python version is 3.7.4. You are using anaconda3-2019.10.
Preface COVID-19 + With the change of job, I decided to learn a new language because I had a lot of spare time as I was stuck in my home in Tokyo.</description>
    </item>
    
    <item>
      <title>Python Basic - Pandas, Numpy -</title>
      <link>https://japan2018.github.io/python-basic-pandas-numpy-fc9e2/</link>
      <pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/python-basic-pandas-numpy-fc9e2/</guid>
      <description># 0. Introduction of Numpy  NumPy is a Python package. It stands for &amp;lsquo;Numerical Python&amp;rsquo;, and Numpy is a linear algebra library to work with dimensional arrays, which contains useful linear algebra routines and random number capabilities.
1. Numpy arrange() method The arange() method in the Numpy module in Python is used to generate linear sequence of numbers. If does it on the basis of the pre-provide starting and ending points along with a constant step size.</description>
    </item>
    
    <item>
      <title>Mathematical puzzles to train programmer brains Q05 Still paying cash?</title>
      <link>https://japan2018.github.io/mathematical-puzzles-to-train-programmer-brains-q05-still-paying-cash-f7f6c/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/mathematical-puzzles-to-train-programmer-brains-q05-still-paying-cash-f7f6c/</guid>
      <description># Problem overview  Exchange 1000 yen into a combination of 500 yen coin, 100 yen coin, 50 yen coin and 10 yen coin. However, the total number of coins is 15 or less.
#Code Solve without thinking
#Q05 Still cash payment? combinations = [] # list of combinations for c500 in range(3): for c100 in range(11): for c50 in range(16): for c10 in range(16): if c500 + c100 + c50 + c10 &amp;lt;= 15: if c500 * 500 + c100 * 100 + c50 * 50 + c10 *10 == 1000: combinations.</description>
    </item>
    
    <item>
      <title>Implementing logistic regression with NumPy</title>
      <link>https://japan2018.github.io/implementing-logistic-regression-with-numpy-fb4cd/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/implementing-logistic-regression-with-numpy-fb4cd/</guid>
      <description>It is a moment if you use scikit-learn, but you can also implement it yourself as a study.  In the original article, multi-class classification and train_test_split were out of scope, so
It is simplified to a 2-class problem and evaluated with the same data as the training data.
Please refer to the following article for details. Machine learning starting from scratch #4 &amp;ldquo;Logistic regression&amp;rdquo;
from sklearn.datasets import load_iris import numpy as np iris = load_iris() X_org = iris.</description>
    </item>
    
    <item>
      <title>[Pandas 1.0.1 Memorial] Fierce battle with Cookbook</title>
      <link>https://japan2018.github.io/pandas-1.0.1-memorial-fierce-battle-with-cookbook-faf24/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/pandas-1.0.1-memorial-fierce-battle-with-cookbook-faf24/</guid>
      <description>#Background   Every time there is a Google search, it is bloody and not flesh due to temporary understanding. Fragmental knowledge alone is not enough to apply when it is difficult to apply. In order to overcome the weakened memory, it is necessary to move it, understand it, and explain it to the brain. I would like to carry out a dictum from the predecessors, &amp;ldquo;Please read the official manual&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Broadcast calculation by increasing dimension with np.newaxis</title>
      <link>https://japan2018.github.io/broadcast-calculation-by-increasing-dimension-with-np.newaxis-faf38/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/broadcast-calculation-by-increasing-dimension-with-np.newaxis-faf38/</guid>
      <description>This is an article where I wrote down my own understanding from the question that the image of the three-dimensional np.array is grabbed and what is np.newaxis. [Here](https://qiita.com/yoshi_san/items/4cbe3abb7d46c5252fdd) for the first half article that wrote the basics of np.array image and np.newaxis.  In this article, I will explain how to use np.newaxis. Specifically, when the two-dimensional array in which two or more two-dimensional vectors are lined up is first mentioned in the first half of the article, the calculation of the square of the distance between the vectors included in both is performed by brute force.</description>
    </item>
    
    <item>
      <title>Gradation image generation with Python [1]｜np.linspace</title>
      <link>https://japan2018.github.io/gradation-image-generation-with-python-1np.linspace-ff031/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/gradation-image-generation-with-python-1np.linspace-ff031/</guid>
      <description>#Introduction  This time, I will try to generate a gradient image with python, referring to this article.
#Gradation image generation This time we will generate an image using two functions.
def gradation_2d_color(start, stop, size, is_horizontal): if is_horizontal: return np.tile(np.linspace(start, stop, size[1]), (size[0], 1)) else: return np.tile(np.linspace(start, stop, size[0]), (size[1], 1)).T Use np.linspace to create a one-dimensional array of length height (or width) that stores the values of the arithmetic progression obtained by dividing the range from start to stop by the number of height (or width).</description>
    </item>
    
    <item>
      <title>How to make random numbers with NumPy&#39;s random module</title>
      <link>https://japan2018.github.io/how-to-make-random-numbers-with-numpys-random-module-fc349/</link>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/how-to-make-random-numbers-with-numpys-random-module-fc349/</guid>
      <description>NumPy can generate random numbers with the np.random module.   Np.random.rand() that generates a uniform random number between 0 and 1 Generate random numbers for the number of integers specified in ().  ・Np.random.randint(x, y, z) that generates z integers between x and less than y Note that it will generate an integer between x and y. Furthermore, if you specify an argument such as (2,3) for z, you can generate a 2×3 matrix.</description>
    </item>
    
    <item>
      <title>How to speed up Pandas apply method with just one sentence (with verification calculation)</title>
      <link>https://japan2018.github.io/how-to-speed-up-pandas-apply-method-with-just-one-sentence-with-verification-calculation-fc4d2/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/how-to-speed-up-pandas-apply-method-with-just-one-sentence-with-verification-calculation-fc4d2/</guid>
      <description>#Conclusion  Just add swifter method before Pandas apply method
Concrete example import pandas as pd import numpy as np import swifter # Create a suitable DataFrame df = pd.DataFrame({&amp;#39;col&amp;#39;: np.random.normal(size=10000000)}) # Add swifter method before apply method. %time df[&amp;#39;col2&amp;#39;] = df[&amp;#39;col&amp;#39;].swifter.apply(lambda x: x**2) # Wall time: 50 ms # For comparison (normal pandas apply method) %time df[&amp;#39;col2&amp;#39;] = df[&amp;#39;col&amp;#39;].apply(lambda x: x**2) # Wall time: 3.48 s How to install $ pip install -U pandas # upgrade pandas $ pip install swifter In case of ```terminal:conda $ conda update pandas # upgrade pandas $ conda install -c conda-forge swifter</description>
    </item>
    
    <item>
      <title>Calculation of mutual information (continuous value) with numpy</title>
      <link>https://japan2018.github.io/calculation-of-mutual-information-continuous-value-with-numpy-ffaab/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/calculation-of-mutual-information-continuous-value-with-numpy-ffaab/</guid>
      <description>#Motivation  I want to calculate the mutual information $I(X;Y)$ of continuous random variables $X$ and $Y$ with Python. $$ I(X;Y) = \int_Y \int_X p(x, y) \log \frac{p(x,y)}{p(x)p(y)} dx dy $$
#Code
import numpy def mutual_information(X, Y, bins=10): # Compute joint probability distribution p(x,y) p_xy, xedges, yedges = np.histogram2d(X, Y, bins=bins, density=True) #p(x)p(y) calculation p_x, _ = np.histogram(X, bins=xedges, density=True) p_y, _ = np.histogram(Y, bins=yedges, density=True) p_x_y = p_x[:, np.newaxis] * p_y #dx and dy dx = xedges[1]-xedges[0] dy = yedges[1]-yedges[0] # Integral element elem = p_xy * np.</description>
    </item>
    
  </channel>
</rss>