<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> image processing on Some Title</title>
    <link>https://japan2018.github.io/tags/image-processing/</link>
    <description>Recent content in  image processing on Some Title</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://japan2018.github.io/tags/image-processing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>I tried morphological conversion of the image with Python &#43; OpenCV</title>
      <link>https://japan2018.github.io/i-tried-morphological-conversion-of-the-image-with-python-opencv-f87cc/</link>
      <pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/i-tried-morphological-conversion-of-the-image-with-python-opencv-f87cc/</guid>
      <description>## Introduction  With image processing, it is not always possible to prepare beautiful images. Images often contain noise. If there is noise, it may be removed using a method called &amp;ldquo;smoothing&amp;rdquo; or &amp;ldquo;morphological transformation&amp;rdquo;.
This time, we will use Python to perform morphological transformation of the image using OpenCV.
*For details on &amp;ldquo;smoothing&amp;rdquo;, refer to the following. I tried &amp;ldquo;smoothing&amp;rdquo; the image with Python + OpenCV
What is morphological conversion Morphological transformation is mainly the process of &amp;ldquo;shrink&amp;rdquo; and &amp;ldquo;expansion&amp;rdquo; for binary images.</description>
    </item>
    
    <item>
      <title>Image Processing with PIL</title>
      <link>https://japan2018.github.io/image-processing-with-pil-fcb12/</link>
      <pubDate>Thu, 26 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/image-processing-with-pil-fcb12/</guid>
      <description>In this project, we&#39;ll load and process the image with PIL.   PIL This library provides extensive file format support, an efficient internal representation, and fairly powerful image processing capabilities. The core image library is designed for fast access to data stored in a few basic pixel formats. It should provide a solid foundation for a general image processing tool.
Image Processing The library contains basic image processing functionality, including point operations, filtering with a set of built-in convolution kernels, and colour space conversions.</description>
    </item>
    
    <item>
      <title>Install dlib for Python (Windows)</title>
      <link>https://japan2018.github.io/install-dlib-for-python-windows-fd84f/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/install-dlib-for-python-windows-fd84f/</guid>
      <description>I&#39;m stumbled upon soberly, so I will explain with a lot of images.  There may be unnecessary steps, but I will introduce the method that will definitely be tried after various trials. I would like to gradually edit to reduce waste.
0. Assumption The environment is as follows. ・Windows 10 Home 64 bit
1. Install Python You can download it from the following. https://www.python.org/downloads/windows/
This time, install &amp;ldquo;Python 3.8.1 64bit&amp;rdquo; On the installation screen, check &amp;ldquo;Add Python 3.</description>
    </item>
    
    <item>
      <title>Gradation image generation with Python [1]｜np.linspace</title>
      <link>https://japan2018.github.io/gradation-image-generation-with-python-1np.linspace-ff031/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://japan2018.github.io/gradation-image-generation-with-python-1np.linspace-ff031/</guid>
      <description>#Introduction  This time, I will try to generate a gradient image with python, referring to this article.
#Gradation image generation This time we will generate an image using two functions.
def gradation_2d_color(start, stop, size, is_horizontal): if is_horizontal: return np.tile(np.linspace(start, stop, size[1]), (size[0], 1)) else: return np.tile(np.linspace(start, stop, size[0]), (size[1], 1)).T Use np.linspace to create a one-dimensional array of length height (or width) that stores the values of the arithmetic progression obtained by dividing the range from start to stop by the number of height (or width).</description>
    </item>
    
  </channel>
</rss>