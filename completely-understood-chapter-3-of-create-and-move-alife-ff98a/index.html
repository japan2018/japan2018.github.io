<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://japan2018.github.io/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://japan2018.github.io/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://japan2018.github.io/favicon-16x16.png">

  
  <link rel="manifest" href="https://japan2018.github.io/site.webmanifest">

  
  <link rel="mask-icon" href="https://japan2018.github.io/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://japan2018.github.io/css/bootstrap.min.css" />

  
  <title>Completely understood Chapter 3 of Create and Move ALife | Some Title</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Completely understood Chapter 3 of Create and Move ALife</h1>
<p>
  <small class="text-secondary">
  
  
  Dec 17, 2019
  </small>
  

<small><code><a href="https://japan2018.github.io/tags/python">Python</a></code></small>


<small><code><a href="https://japan2018.github.io/tags/alife"> ALife</a></code></small>


<small><code><a href="https://japan2018.github.io/tags/making-and-moving-alife"> making and moving ALife</a></code></small>

</p>
<pre><code># Emergence
</code></pre>
<ul>
<li>How the pieces are defined</li>
<li>&ldquo;Open and close&rdquo; is required for each individual
-Open to receive changes in the environment and lock in changes to sustain yourself</li>
<li>&ldquo;Opening and closing&rdquo; is a structure that recursively refers to itself and is necessary for emergence of a lifelike individual</li>
<li>A system that has the mechanism of &ldquo;the smallest unit of life&rdquo; that can create and maintain itself is called &ldquo;autopoiesis&rdquo;</li>
</ul>
<h1 id="scl-model">SCL model</h1>
<ul>
<li>One of the models that creates the concept of autopoiesis is the &ldquo;SCL (Substrate Catalyst Link)&rdquo; model</li>
<li>This question of &ldquo;what is emergence?&rdquo; shows one way of understanding that &ldquo;it is the process that constitutes itself that determines the existence of self.&rdquo;</li>
</ul>
<h2 id="model-overview">Model overview</h2>
<ul>
<li>Consisting of various molecules that move in a two-dimensional lattice and their chemical reaction formulas</li>
<li>There are 3 kinds of molecules in the lattice cell
-Substrate: Substrate: Green circle
-Catalyst molecule (Catalyst): Purple circle
-Membrane molecule (Link): Blue square</li>
</ul>
<img width="300" alt="Screenshots 2019-12-13 10.56.11.png (69.9 kB)" src="https://img.esa.io/uploads/production/attachments/14184/2019/12/13/59339/20265de0-03c8-418b-92d3-9b9f93f3aeba.png">
<ul>
<li>Each molecule moves between cells and undergoes chemical reactions such as binding and decomposition with other adjacent molecules
-1) 2S + C → L + C
-One substrate molecule (L) is generated from two substrate molecules (S) by catalyst molecule (C)
-2) L + L → L-L
-Generated membrane molecule (L) is fixed in space by binding with adjacent membrane molecule (L)
-3) L → 2S
-Membrane molecule (L) is again decomposed into substrate molecule (S) with a certain probability</li>
<li>In the process of chemical reaction, the formation and maintenance of the membrane are carried out as a whole.</li>
</ul>
<p>Now let&rsquo;s look at how the &ldquo;individual&rdquo; is formed and how it is maintained.</p>
<h3 id="state-of-formation">State of formation</h3>
<ul>
<li>Catalyst molecules start to form membrane molecules in the neighborhood</li>
<li>Membrane molecules combine to form a link, enclosing the catalyst molecules and starting to form a membrane</li>
<li>Start to create a unit called &ldquo;individual&rdquo; just like a cell</li>
</ul>
<h3 id="self-maintenance">Self-maintenance</h3>
<ul>
<li>Substrate molecules move in and out of the membrane</li>
<li>When a substrate molecule in the membrane is converted into a membrane molecule by a catalyst molecule, a link is created inside the membrane</li>
<li>By doing so, even if the link making the membrane is disassembled and a hole is created, the link in the membrane fills the hole and repairs the broken membrane</li>
</ul>
<h2 id="model-implementation">Model implementation</h2>
<p>The SCL model is implemented as a kind of two-dimensional cellular automaton. The cell can take five states:</p>
<ul>
<li>CATALYST (Catalyst molecule)</li>
<li>SUBSTRATE (Substrate molecule)</li>
<li>LINK (membrane molecule)</li>
<li>LINK-SUBSTRATE (membrane molecule and substrate molecule coexist)</li>
<li>HOLE (empty)</li>
</ul>
<p>The cell state is described in Python as follows. Items other than <code>type</code> will be described later.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">{<span style="color:#e6db74">&#39;type&#39;</span>:<span style="color:#e6db74">&#39;LINK&#39;</span>,<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>: False,<span style="color:#e6db74">&#39;bonds&#39;</span>: [(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>)]}
</code></pre></div><p>Molecular reactions and bonds can be expressed by the following six reactions. Details will be explained in the calculation part.</p>
<ul>
<li>production
-Two substrate molecules come into contact with catalyst molecules to become membrane molecules</li>
<li>disintegration
-Membrane molecule reverts to two substrate molecules</li>
<li>bonding
-Membrane molecules bind to each other</li>
<li>bond decay
-The bond between membrane molecules is broken</li>
<li>absorption
-Membrane molecule absorbs substrate molecule</li>
<li>emission
-Membrane molecule releases substrate molecule</li>
</ul>
<p>The model parameters are:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">MOBILITY_FACTOR <span style="color:#f92672">=</span> {
    <span style="color:#e6db74">&#39;HOLE&#39;</span>: <span style="color:#ae81ff">0.1</span>,
    <span style="color:#e6db74">&#39;SUBSTRATE&#39;</span>: <span style="color:#ae81ff">0.1</span>,
    <span style="color:#e6db74">&#39;CATALYST&#39;</span>: <span style="color:#ae81ff">0.0001</span>,
    <span style="color:#e6db74">&#39;LINK&#39;</span>: <span style="color:#ae81ff">0.05</span>,
    <span style="color:#e6db74">&#39;LINK_SUBSTRATE&#39;</span>: <span style="color:#ae81ff">0.05</span>,}
PRODUCTION_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.95</span>
DISINTEGRATION_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0005</span>
BONDING_CHAIN_INITIATE_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>
BONDING_CHAIN_EXTEND_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.6</span>
BONDING_CHAIN_SPLICE_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.9</span>
BOND_DECAY_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0005</span>
ABSORPTION_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>
EMISSION_PROBABILITY <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>
</code></pre></div><p><code>MOBILITY_FACTOR</code> is the ease of movement of each molecule. <code>_PROBABILITY</code> is the ease of each reaction.</p>
<p>The SCL model implementation can be divided into three parts:</p>
<ul>
<li>
<ol>
<li>Initialization</li>
</ol>
</li>
<li>
<ol start="2">
<li>Movement of molecules</li>
</ol>
</li>
<li>
<ol start="3">
<li>Reaction of molecules</li>
</ol>
</li>
</ul>
<p>Let&rsquo;s look at each one in turn.</p>
<h3 id="initialization">Initialization</h3>
<p>In the initialization phase, prepare a two-dimensional array that stores cell information and arrange molecules.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Initialization</span>
particles <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>empty((SPACE_SIZE, SPACE_SIZE), dtype<span style="color:#f92672">=</span>object)
Place SUBSTRATE <span style="color:#f92672">and</span> HOLE according to <span style="color:#75715e">#INITIAL_SUBSTRATE_DENSITY.</span>
<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(SPACE_SIZE):
    <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(SPACE_SIZE):
        <span style="color:#66d9ef">if</span> evaluate_probability(INITIAL_SUBSTRATE_DENSITY):
            p <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;type&#39;</span>:<span style="color:#e6db74">&#39;SUBSTRATE&#39;</span>,<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>: False,<span style="color:#e6db74">&#39;bonds&#39;</span>: []}
        <span style="color:#66d9ef">else</span>:
            p <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;type&#39;</span>:<span style="color:#e6db74">&#39;HOLE&#39;</span>,<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>: False,<span style="color:#e6db74">&#39;bonds&#39;</span>: []}
        particles[x,y] <span style="color:#f92672">=</span> p
Place CATALYST <span style="color:#f92672">in</span> <span style="color:#75715e">#INITIAL_CATALYST_POSITIONS.</span>
<span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> INITIAL_CATALYST_POSITIONS:
    particles[x, y][<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;CATALYST&#39;</span>
</code></pre></div><p>First, we prepare a two-dimensional array of SPACE_SIZE × SPACE_SIZE.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">particles <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>empty((SPACE_SIZE, SPACE_SIZE), dtype<span style="color:#f92672">=</span>object)
particles
<span style="color:#75715e"># =&gt; array([[None, None, None, None, None, None, None, None, None, None, None,</span>
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],
       [None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None],[None, None, None, None, None, None, None, None, None, None, None,
        None, None, None, None, None]], dtype<span style="color:#f92672">=</span>object)
</code></pre></div><p>Then, with a certain probability, type is set to SUBSTRATE or HOLE for the case cell. <code>evaluate_probability( possibility )</code> returns TRUE or FALSE with the probability of the argument. This sets the type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(SPACE_SIZE):
    <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(SPACE_SIZE):
        <span style="color:#66d9ef">if</span> evaluate_probability(INITIAL_SUBSTRATE_DENSITY):
            p <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;type&#39;</span>:<span style="color:#e6db74">&#39;SUBSTRATE&#39;</span>,<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>: False,<span style="color:#e6db74">&#39;bonds&#39;</span>: []}
        <span style="color:#66d9ef">else</span>:
            p <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;type&#39;</span>:<span style="color:#e6db74">&#39;HOLE&#39;</span>,<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>: False,<span style="color:#e6db74">&#39;bonds&#39;</span>: []}
        particles[x,y] <span style="color:#f92672">=</span> p

<span style="color:#75715e"># Returns True or False according to probability probability</span>
<span style="color:#75715e">#probability must be between 0 and 1</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">evaluate_probability</span>(probability):
    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand() <span style="color:#f92672">&lt;</span>probability
</code></pre></div><p>Finally, place the catalyst molecule.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> INITIAL_CATALYST_POSITIONS:
    particles[x, y][<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;CATALYST&#39;</span>
</code></pre></div><h3 id="move-molecule">Move molecule</h3>
<p>Next, we explain the movement of molecules. Molecule transfer is achieved by exchanging information in two adjacent cells. Randomly select a cell from the Neumann neighborhood of a cell and decide whether to move according to MOBILITY_FACTOR.</p>
<p>To explain the Neumann neighborhood as a supplement, the four cells above, below, left, and right are considered adjacent. On the other hand, in the vicinity of Moore, eight cells including diagonal lines are adjacent.</p>
<p><img src="https://img.esa.io/uploads/production/attachments/14184/2019/12/13/59339/6cd995d0-00ef-4452-b1e1-404c1129fec2.png" alt="noiman.png (16.8 kB)"></p>
<p>The method to actually represent the neighborhood is as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_neumann_neighborhood_list</span>(x, y):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    Gets a list containing the four coordinates in the vicinity of Neumann at the specified coordinates.
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">    Parameters
</span><span style="color:#e6db74">    ----------
</span><span style="color:#e6db74">    x: int
</span><span style="color:#e6db74">        The x coordinate of the target.
</span><span style="color:#e6db74">    y: int
</span><span style="color:#e6db74">        The y coordinate of the target.
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">    Returns
</span><span style="color:#e6db74">    -------
</span><span style="color:#e6db74">    neumann_neighborhood_list: list of tuple
</span><span style="color:#e6db74">        A list containing the four coordinates near Neumann. Right/left/bottom/upper order
</span><span style="color:#e6db74">        Is stored.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    neumann_neighborhood_list <span style="color:#f92672">=</span> [
        ((x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span>SPACE_SIZE, y),
        ((x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span>SPACE_SIZE, y),
        (x, (y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span>SPACE_SIZE),
        (x, (y<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span>SPACE_SIZE),
    ]
    <span style="color:#66d9ef">return</span> neumann_neighborhood_list
</code></pre></div><p>Now let&rsquo;s look at the implementation of the move.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">moved <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>full(particles<span style="color:#f92672">.</span>shape, False, dtype<span style="color:#f92672">=</span>bool)
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(SPACE_SIZE):
        <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(SPACE_SIZE):
            p <span style="color:#f92672">=</span> particles[x,y]
            n_x, n_y <span style="color:#f92672">=</span> get_random_neumann_neighborhood(x, y, SPACE_SIZE)
            n_p <span style="color:#f92672">=</span> particles[n_x, n_y]
            mobility_factor <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sqrt(MOBILITY_FACTOR[p[<span style="color:#e6db74">&#39;type&#39;</span>]] <span style="color:#f92672">*</span> MOBILITY_FACTOR[n_p[<span style="color:#e6db74">&#39;type&#39;</span>]])
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> moved[x, y] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> moved[n_x, n_y] <span style="color:#f92672">and</span> \
               len(p[<span style="color:#e6db74">&#39;bonds&#39;</span>]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> len(n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> \
               evaluate_probability(mobility_factor):
                    particles[x,y], particles[n_x,n_y] <span style="color:#f92672">=</span> n_p, p
                    moved[x, y] <span style="color:#f92672">=</span> moved[n_x, n_y] <span style="color:#f92672">=</span> True
</code></pre></div><p>After selecting one cell ([x, y] ), <code>get_random_neumann_neighborhood(x, y, SPACE_SIZE)</code> randomly selects the destination cell.</p>
<p>In the first line there is a variable called <code>moved</code>. What is this? Actually, <code>None</code> was stored in particles, but <code>False</code> was stored in moved.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">moved <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>full(particles<span style="color:#f92672">.</span>shape, False, dtype<span style="color:#f92672">=</span>bool)
moved
<span style="color:#75715e"># =&gt; array([[False, False, False, False, False, False, False, False, False,</span>
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False],
       [False, False, False, False, False, False, False, False, False,
        False, False, False, False, False, False, False]])
</code></pre></div><p>moved looks to see if the selected cell has already moved. It is assumed that the change of cells is made minute by setting the rule that &ldquo;the cell can be moved only once in one loop&rdquo;. The cells that have been moved are set to True, and the cells that have not been moved are set to False so that they can be referenced.In the for statement, the move is set only when the following conditions are met.</p>
<ul>
<li>Is the moved variable of the two moving cells False?</li>
<li>Is the molecule to be transferred bound to another molecule?</li>
<li>Whether the return value of the evaluate_probability function is True</li>
</ul>
<h3 id="molecular-reaction">Molecular reaction</h3>
<p>Finally, I will explain the main reaction program. The function is created for each reaction as follows. The function is imported from another file, so let&rsquo;s look at that.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(SPACE_SIZE):
        <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(SPACE_SIZE):
            production(particles, x, y, PRODUCTION_PROBABILITY)
            disintegration(particles, x, y, DISINTEGRATION_PROBABILITY)
            bonding(particles, x, y, BONDING_CHAIN_INITIATE_PROBABILITY,
                                     BONDING_CHAIN_SPLICE_PROBABILITY,
                                     (BONDING_CHAIN_EXTEND_PROBABILITY)
            bond_decay(particles, x, y, BOND_DECAY_PROBABILITY)
            absorption(particles, x, y, ABSORPTION_PROBABILITY)
            emission(particles, x, y, EMISSION_PROBABILITY)
</code></pre></div><h4 id="production">production</h4>
<p>A production is a reaction in which two neighboring substrates are catalyzed into a single membrane. The reaction formula is as follows.</p>
<pre><code class="language-math" data-lang="math">2S + C → L + C
</code></pre><p>Let&rsquo;s see how this is actually programmed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">production</span>(particles, x, y, probability):
    p <span style="color:#f92672">=</span> particles[x,y]
    <span style="color:#75715e"># Randomly select two target neighboring particles</span>
    n0_x, n0_y, n1_x, n1_y <span style="color:#f92672">=</span> get_random_2_moore_neighborhood(x, y, particles<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
    n0_p <span style="color:#f92672">=</span> particles[n0_x, n0_y]
    n1_p <span style="color:#f92672">=</span> particles[n1_x, n1_y]
    <span style="color:#66d9ef">if</span> p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;CATALYST&#39;</span> <span style="color:#f92672">or</span> n0_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;SUBSTRATE&#39;</span> <span style="color:#f92672">or</span> n1_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;SUBSTRATE&#39;</span>:
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">if</span> evaluate_probability(probability):
        n0_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;HOLE&#39;</span>
        n1_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;LINK&#39;</span>
</code></pre></div><p>Randomly select two from neighboring particles of interest, and with a certain probability (= <code>evaluate_probability (probability)</code> ), one substrate molecule will be a membrane molecule and the other substrate molecule will be empty with a constant probability (= <code>evaluate_probability (probability)</code> ). ..</p>
<ul>
<li>The particles you are looking at are catalyst molecules</li>
<li>Two randomly selected neighboring particles are substrate molecules</li>
</ul>
<p>By the way, the <code>get_random_2_moore_neighborhood</code> method that randomly selects two neighboring particles is as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_random_2_moore_neighborhood</span>(x, y, space_size):
    n0_x, n0_y <span style="color:#f92672">=</span> get_random_moore_neighborhood(x, y, space_size)
    <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> n0_x:
        n1_x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>choice([(n0_x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>space_size, (n0_x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>space_size])
        n1_y <span style="color:#f92672">=</span> n0_y
    <span style="color:#66d9ef">elif</span> y <span style="color:#f92672">==</span> n0_y:
        n1_x <span style="color:#f92672">=</span> n0_y
        n1_y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>choice([(n0_y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>space_size, (n0_y<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>space_size])
    <span style="color:#66d9ef">else</span>:
        n<span style="color:#f92672">=</span> [(x, n0_y), (n0_x, y)]
        n1_x, n1_y <span style="color:#f92672">=</span> n[np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randint(len(n))]
    <span style="color:#66d9ef">return</span> n0_x, n0_y, n1_x, n1_y
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_random_moore_neighborhood</span>(x, y, space_size):
    neighborhood <span style="color:#f92672">=</span> get_moore_neighborhood(x, y, space_size)
    nx, ny <span style="color:#f92672">=</span> neighborhood[np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randint(len(neighborhood))]
    <span style="color:#66d9ef">return</span> nx, ny
</code></pre></div><h4 id="disintegration">disintegration</h4>
<p>Disintegration is a reaction in which a membrane molecule collapses and returns to two substrates. Membrane molecules collapse with a certain probability, but may not be able to collapse immediately depending on the surrounding conditions. Specifically, the situation is as follows.</p>
<ul>
<li>There is no space around the substrate molecule to release the cohabiting substrate molecule</li>
<li>There is no space around the two split molecule molecules</li>
</ul>
<p>Therefore, if the membrane molecule is evaluated to collapse with a certain probability, set <code>disintegrating_flag</code> to True. When disintegrating_flag is False, no collapse will occur. As a result, even if the membrane molecule does not collapse due to the surrounding conditions, it will try to collapse again in the subsequent reactions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">disintegration</span>(particles, x, y, probability):
    p <span style="color:#f92672">=</span> particles[x,y]
    <span style="color:#75715e"># disintegration may not happen immediately, so flag it once</span>
    <span style="color:#66d9ef">if</span> p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">in</span> (<span style="color:#e6db74">&#39;LINK&#39;</span>,<span style="color:#e6db74">&#39;LINK_SUBSTRATE&#39;</span>) <span style="color:#f92672">and</span> evaluate_probability(probability):
        p[<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>] <span style="color:#f92672">=</span> True

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> p[<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>]:
        <span style="color:#66d9ef">return</span>
    If <span style="color:#75715e">#LINK contains SUBSTRATE, execute emission with probability 1 to forcefully release</span>
    emission(particles, x, y, <span style="color:#ae81ff">1.0</span>)
    <span style="color:#75715e"># Randomly select target neighboring particles</span>
    n_x, n_y <span style="color:#f92672">=</span> get_random_moore_neighborhood(x, y, particles<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
    n_p <span style="color:#f92672">=</span> particles[n_x, n_y]
    <span style="color:#66d9ef">if</span> p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;LINK&#39;</span> <span style="color:#f92672">and</span> n_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">==</span><span style="color:#e6db74">&#39;HOLE&#39;</span>:
        Execute bond_decay <span style="color:#66d9ef">with</span> probability <span style="color:#ae81ff">1</span> to erase all mutual connections of <span style="color:#75715e"># LINK</span>
        bond_decay(particles, x, y, <span style="color:#ae81ff">1.0</span>)
        <span style="color:#75715e"># disintegration</span>
        p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;SUBSTRATE&#39;</span>
        n_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;SUBSTRATE&#39;</span>
        p[<span style="color:#e6db74">&#39;disintegrating_flag&#39;</span>] <span style="color:#f92672">=</span> False
</code></pre></div><p>Details of <code>bond_decay</code> and <code>emission</code> will be described later.</p>
<h4 id="bonding">bonding</h4>
<p>Bonding is a reaction in which a membrane molecule binds to neighboring membrane molecules. This program is longer than others, so I&rsquo;ll show you the whole first.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bonding</span>(particles, x, y,
            chain_initiate_probability, chain_splice_probability, chain_extend_probability,
            chain_inhibit_bond_flag<span style="color:#f92672">=</span>True, catalyst_inhibit_bond_flag<span style="color:#f92672">=</span>True):
    p <span style="color:#f92672">=</span> particles[x,y]
    <span style="color:#75715e"># Randomly select target neighboring particles</span>
    n_x, n_y <span style="color:#f92672">=</span> get_random_moore_neighborhood(x, y, particles<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
    <span style="color:#75715e"># Check the type of two molecules, number of bonds, angle, intersection</span>
    n_p <span style="color:#f92672">=</span> particles[n_x, n_y]
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">in</span> (<span style="color:#e6db74">&#39;LINK&#39;</span>,<span style="color:#e6db74">&#39;LINK_SUBSTRATE&#39;</span>):
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> n_p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">in</span> (<span style="color:#e6db74">&#39;LINK&#39;</span>,<span style="color:#e6db74">&#39;LINK_SUBSTRATE&#39;</span>):
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">if</span> (n_x, n_y) <span style="color:#f92672">in</span> p[<span style="color:#e6db74">&#39;bonds&#39;</span>]:
        <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">if</span> len(p[<span style="color:#e6db74">&#39;bonds&#39;</span>]) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">or</span> len(n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>]) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>:
        <span style="color:#66d9ef">return</span>
    an0_x, an0_y, an1_x, an1_y <span style="color:#f92672">=</span> get_adjacent_moore_neighborhood(x, y, n_x, n_y, particles<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
    <span style="color:#66d9ef">if</span> (an0_x, an0_y) <span style="color:#f92672">in</span> p[<span style="color:#e6db74">&#39;bonds&#39;</span>] <span style="color:#f92672">or</span> (an1_x, an1_y) <span style="color:#f92672">in</span> p[<span style="color:#e6db74">&#39;bonds&#39;</span>]:
        <span style="color:#66d9ef">return</span>
    an0_x, an0_y, an1_x, an1_y <span style="color:#f92672">=</span> get_adjacent_moore_neighborhood(n_x, n_y, x, y, particles<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
    <span style="color:#66d9ef">if</span> (an0_x, an0_y) <span style="color:#f92672">in</span> n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>] <span style="color:#f92672">or</span> (an1_x, an1_y) <span style="color:#f92672">in</span> n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>]:
        <span style="color:#66d9ef">return</span>
    an0_x, an0_y, an1_x, an1_y <span style="color:#f92672">=</span> get_adjacent_moore_neighborhood(x, y, n_x, n_y, particles<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
    <span style="color:#66d9ef">if</span> (an0_x, an0_y) <span style="color:#f92672">in</span> particles[an1_x,an1_y][<span style="color:#e6db74">&#39;bonds&#39;</span>]:
        <span style="color:#66d9ef">return</span>
    <span style="color:#75715e"># Bonding does not occur in the following two cases</span>
    <span style="color:#75715e">#1) When there is a membrane chain near the moore (chain_inhibit_bond_flag)</span>
    <span style="color:#75715e">#2) When catalyst molecules exist near moore (catalyst_inhibit_bond_flag)mn_list = get_moore_neighborhood(x, y, particles.shape[0]) + get_moore_neighborhood(n_x, n_y, particles.shape[0])</span>
    <span style="color:#66d9ef">if</span> catalyst_inhibit_bond_flag:
        <span style="color:#66d9ef">for</span> mn_x, mn_y <span style="color:#f92672">in</span> mn_list:
            <span style="color:#66d9ef">if</span> particles[mn_x,mn_y][<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">is</span><span style="color:#e6db74">&#39;CATALYST&#39;</span>:
                <span style="color:#66d9ef">return</span>
    <span style="color:#66d9ef">if</span> chain_inhibit_bond_flag:
        <span style="color:#66d9ef">for</span> mn_x, mn_y <span style="color:#f92672">in</span> mn_list:
            <span style="color:#66d9ef">if</span> len(particles[mn_x,mn_y][<span style="color:#e6db74">&#39;bonds&#39;</span>]) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>:
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> (x, y) <span style="color:#f92672">in</span> particles[mn_x,mn_y][<span style="color:#e6db74">&#39;bonds&#39;</span>] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> (n_x, n_y) <span style="color:#f92672">in</span> particles[mn_x,mn_y][<span style="color:#e6db74">&#39;bonds&#39;</span>]:
                    <span style="color:#66d9ef">return</span>
    <span style="color:#75715e"># Bonding</span>
    <span style="color:#66d9ef">if</span> len(p[<span style="color:#e6db74">&#39;bonds&#39;</span>])<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> len(n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>])<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>:
        prob <span style="color:#f92672">=</span> chain_initiate_probability
    <span style="color:#66d9ef">elif</span> len(p[<span style="color:#e6db74">&#39;bonds&#39;</span>])<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> len(n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>])<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>:
        prob <span style="color:#f92672">=</span> chain_splice_probability
    <span style="color:#66d9ef">else</span>:
        prob <span style="color:#f92672">=</span> chain_extend_probability
    <span style="color:#66d9ef">if</span> evaluate_probability(prob):
        p[<span style="color:#e6db74">&#39;bonds&#39;</span>]<span style="color:#f92672">.</span>append((n_x, n_y))
        n_p[<span style="color:#e6db74">&#39;bonds&#39;</span>]<span style="color:#f92672">.</span>append((x, y))
</code></pre></div><p>Before taking a closer look, there are some conditions for membrane molecule binding, so let&rsquo;s first check them.</p>
<ul>
<li>Up to 2 bonds that can make a membrane molecule</li>
<li>The angle between two bonds is 90 degrees or more (45 degrees are prohibited)</li>
<li>Crossing joins prohibited</li>
<li>Use different binding probabilities of two membrane molecules in the following three cases
-When two membrane molecules have no bond (chain_initiate_probability argument)
-If one membrane molecule already has a bond (chain_extend_probability argument)
-If two membrane molecules already have a bond (chain_extend_probability argument)</li>
</ul>
<p>In addition, the following restrictions have been added to facilitate film formation.</p>
<ul>
<li>Restricted by join chain
-Cannot bond when there are two bond membrane molecules near Moore (controlled by chain_inhibit_bond_flag)</li>
<li>Suppression by catalyst molecule
-Bonding is not possible when catalyst molecules exist near Moore (controlled by catalyst_inhibit_bond_flag)</li>
</ul>
<p>When I first read this, I was very strange. Why are membranes easily formed, while limiting or suppressing the binding of membrane molecules?</p>
<h4 id="bond_decay">bond_decay</h4>
<p>This is a reaction in which the bond of the membrane molecule disappears with a certain probability due to the reverse reaction of bonding. The interesting thing about autopoiesis is that the membrane is maintained even though the generation and disappearance occur with a certain probability.</p>
<p>The implementation is as follows. When the target particle is a membrane molecule, information is erased from the bonds of that cell and the cell to which it is bound with a certain probability.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bond_decay</span>(particles, x, y, probability):
    p <span style="color:#f92672">=</span> particles[x,y]
    <span style="color:#66d9ef">if</span> p[<span style="color:#e6db74">&#39;type&#39;</span>] <span style="color:#f92672">in</span> (<span style="color:#e6db74">&#39;LINK&#39;</span>,<span style="color:#e6db74">&#39;LINK_SUBSTRATE&#39;</span>) <span style="color:#f92672">and</span> evaluate_probability(probability):
        <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> p[<span style="color:#e6db74">&#39;bonds&#39;</span>]:
            particles[b[<span style="color:#ae81ff">0</span>], b[<span style="color:#ae81ff">1</span>]][<span style="color:#e6db74">&#39;bonds&#39;</span>]<span style="color:#f92672">.</span>remove((x, y))
        p[<span style="color:#e6db74">&#39;bonds&#39;</span>] <span style="color:#f92672">=</span> []
</code></pre></div><h4 id="absorption-emission">absorption, emission</h4>
<p>Membrane molecules are permeable to substrate molecules. In the SCL model, this movement is achieved by the membrane absorbing and releasing adjacent substrates.</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-123456789-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
