<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>Memory-saving conversion of log data into sequential category features considering time series | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Memory-saving conversion of log data into sequential category features considering time series</h1>
<p>
  <small class="text-secondary">
  
  
  Dec 2, 2019
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/machine-learning"> machine learning</a></code></small>


<small><code><a href="https://memotut.com/tags/preprocessing"> preprocessing</a></code></small>

</p>
<pre><code>#Introduction
</code></pre>
<p>Hi, I&rsquo;m a machine learning engineer. I&rsquo;m Kawamoto. I had a cold because it was too cold.
Today, I will write about how to perform preprocessing while suppressing memory consumption for log data that needs to consider time series information.</p>
<h1 id="thing-you-want-to-do">Thing you want to do</h1>
<p>Assuming there is a data set containing behavior logs for each user like this,</p>
<pre><code>    userid itemid categoryid timestamp
0 0 3 1 2019-01-04
1 0 4 1 2019-01-08
2 0 4 1 2019-01-19
3 0 5 1 2019-01-02
4 0 7 2 2019-01-17
5 0 8 2 2019-01-07
6 1 0 0 2019-01-06
7 1 1 0 2019-01-14
8 1 2 0 2019-01-20
9 1 6 2 2019-01-01
10 1 7 2 2019-01-12
11 1 8 2 2019-01-18
12 2 3 1 2019-01-16
13 2 4 1 2019-01-15
14 2 5 1 2019-01-10
15 2 5 1 2019-01-13
16 2 6 2 2019-01-03
17 2 7 2 2019-01-05
18 2 8 2 2019-01-11
19 2 8 2 2019-01-21
20 2 9 3 2019-01-09
</code></pre><p>Variable length series data sorted by time for each user as follows,</p>
<pre><code>Itemids contacted by each user (in chronological order)
[[5, 3, 8, 4, 7, 4],
 [6, 0, 7, 1, 8, 2],
 [6, 7, 9, 5, 8, 5, 4, 3, 8]]
Categoryid contacted by each user (chronological order)
[[1, 1, 2, 1, 2, 1],
 [2, 0, 2, 0, 2, 0],
 [2, 2, 3, 1, 2, 1, 1, 1, 2]]
</code></pre><p>I want to create a categorical variable that considers the following time series.
Here, suppose you use the latest record for itemid and categoryid.</p>
<pre><code>The latest itemid contacted by each user
[4, 2, 8]
The latest categoryid contacted by each user
[1, 0, 2]
</code></pre><p>*Here, as an example, we assume a log of which product in which category you saw in EC. Replace each column.</p>
<p>For series data, if you can create such a list, you can input it as sequential data by padding each with Keras (functional API) as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> tensorflow <span style="color:#f92672">as</span> tf
inputs <span style="color:#f92672">=</span> []
inputs<span style="color:#f92672">.</span>append(tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>preprocessing<span style="color:#f92672">.</span>sequence<span style="color:#f92672">.</span>pad_sequences(
    df[<span style="color:#e6db74">&#39;itemid&#39;</span>]<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>tolist(), padding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;post&#39;</span>, truncating<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;post&#39;</span>, maxlen<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>))
inputs<span style="color:#f92672">.</span>append(tf<span style="color:#f92672">.</span>keras<span style="color:#f92672">.</span>preprocessing<span style="color:#f92672">.</span>sequence<span style="color:#f92672">.</span>pad_sequences(
    df[<span style="color:#e6db74">&#39;categoryid&#39;</span>]<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>tolist(), padding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;post&#39;</span>, truncating<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;post&#39;</span>, maxlen<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>))
</code></pre></div><h2 id="how-to-write-in-pandas">How to write in Pandas</h2>
<p>Regarding series data, in pandas, if you write as follows,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Sort by user id, chronological order</span>
df <span style="color:#f92672">=</span> df<span style="color:#f92672">.</span>sort_values(by<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;userid&#39;</span>,<span style="color:#e6db74">&#39;timestamp&#39;</span>])
<span style="color:#75715e"># Groupby as a list by user</span>
df <span style="color:#f92672">=</span> df<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;userid&#39;</span>)<span style="color:#f92672">.</span>agg(list)<span style="color:#f92672">.</span>reset_index(drop<span style="color:#f92672">=</span>False)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;itemid that each user touched (in chronological order)&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(df[<span style="color:#e6db74">&#39;itemid&#39;</span>]<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>tolist())
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;category id contacted by each user (in chronological order)&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(df[<span style="color:#e6db74">&#39;categoryid&#39;</span>]<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>tolist()
</code></pre></div><p>You will get the above result.</p>
<pre><code>Itemids contacted by each user (in chronological order)
[[5, 3, 8, 4, 7, 4],
 [6, 0, 7, 1, 8, 2],
 [6, 7, 9, 5, 8, 5, 4, 3, 8]]
Categoryid contacted by each user (chronological order)
[[1, 1, 2, 1, 2, 1],
 [2, 0, 2, 0, 2, 0],
 [2, 2, 3, 1, 2, 1, 1, 1, 2]]
</code></pre><p>Regarding category data,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Groupby to get the latest by user</span>
df_cate <span style="color:#f92672">=</span> df<span style="color:#f92672">.</span>loc[df<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;userid&#39;</span>)[<span style="color:#e6db74">&#39;timestamp&#39;</span>]<span style="color:#f92672">.</span>idxmax()]

<span style="color:#66d9ef">print</span>(df_cate)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Latest itemid contacted by each user&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(df_cate[<span style="color:#e6db74">&#39;itemid&#39;</span>]<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>tolist())
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;latest categoryid contacted by each user&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(df_cate[<span style="color:#e6db74">&#39;categoryid&#39;</span>]<span style="color:#f92672">.</span>values<span style="color:#f92672">.</span>tolist())
</code></pre></div><p>You can get the above result by writing</p>
<pre><code>The latest itemid contacted by each user
[4, 2, 8]
The latest categoryid contacted by each user
[1, 0, 2]
</code></pre><h2 id="possible-problems-with-pandas">Possible problems with Pandas</h2>
<p>If the above data set becomes large, a memory error will occur in Pandas and it will not be possible to perform batch conversion.
In addition, if the dataset itself does not fit in memory, it cannot be processed as well.
On the other hand, when processing datasets in pieces, it is necessary to retain the time series information of records that are not included in each dataset.</p>
<h2 id="what-i-want-to-do-again">What I want to do again</h2>
<p>From the background as above,</p>
<ul>
<li>** Reduce memory consumption in preprocessing **</li>
<li>** Supports divided loading of datasets **</li>
</ul>
<p>A method that can create series data in chronological order like this was needed and dealt with.</p>
<p>Below, I will write about specific methods.</p>
<h1 id="method">Method</h1>
<p>Here, create a list that holds the time series information, and based on that,</p>
<ul>
<li>Series feature considering time series</li>
<li>Category features considering time series</li>
</ul>
<p>I will write about how to create.</p>
<p>After that, I will explain what to do with the split dataset.</p>
<h2 id="creating-a-sort-target-list">Creating a sort target list</h2>
<p>First, create the list from which you want to operate in chronological order.
If you set the value you want to have as series data in chronological order and in user units as <code>item</code>, the time series information of that value is <code>timestamp</code>,</p>
<pre><code>[[[item,timestamp],[item,timestamp]...[item,timestamp]],
 [[item,timestamp],[item,timestamp]...[item,timestamp]],
 ...
 [[item,timestamp],[item,timestamp]...[item,timestamp]]]
</code></pre><p>Create a three-dimensional list called.
Here, the first dimension uses the user id as an index.</p>
<p>The processing is as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_list</span>(df, user_index_col, sort_col, target_col, user_num):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    :param user_index_col: User ID column
</span><span style="color:#e6db74">    :param sort_col: Column containing the value to be used for sort
</span><span style="color:#e6db74">    :param target_col: column to sort
</span><span style="color:#e6db74">    :param user_num: Number of users (acquire from encoder etc.)
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    inputs <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(user_num)]
    <span style="color:#66d9ef">for</span> _, user_index, sort_value, target_value <span style="color:#f92672">in</span> df[[user_index_col, sort_col, target_col]]<span style="color:#f92672">.</span>itertuples():
        inputs[user_index]<span style="color:#f92672">.</span>append([target_value, sort_value])

    <span style="color:#66d9ef">return</span> inputs
</code></pre></div><p>If you do this for the first dataset,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">itemid_inputs <span style="color:#f92672">=</span> create_list(df, user_index_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;userid&#39;</span>, sort_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;timestamp&#39;</span>, target_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;itemid&#39;</span>, user_num<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
categoryid_inputs <span style="color:#f92672">=</span> create_list(df, user_index_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;userid&#39;</span>, sort_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;timestamp&#39;</span>, target_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;categoryid&#39;</span>, user_num<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;itemid&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(itemid_inputs)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;categoryid&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(categoryid_inputs)
</code></pre></div><p>The following list is created.</p>
<pre><code>itemid
[[[3, Timestamp('2019-01-04 00:00:00')],
  [4, Timestamp('2019-01-08 00:00:00')],
  [4, Timestamp('2019-01-19 00:00:00')],
  [5, Timestamp('2019-01-02 00:00:00')],
  [7, Timestamp('2019-01-17 00:00:00')],
  [8, Timestamp('2019-01-07 00:00:00')]],
 [[0, Timestamp('2019-01-06 00:00:00')],
  [1, Timestamp('2019-01-14 00:00:00')],[2, Timestamp('2019-01-20 00:00:00')],
  [6, Timestamp('2019-01-01 00:00:00')],
  [7, Timestamp('2019-01-12 00:00:00')],
  [8, Timestamp('2019-01-18 00:00:00')]],
 [[3, Timestamp('2019-01-16 00:00:00')],
  [4, Timestamp('2019-01-15 00:00:00')],
  [5, Timestamp('2019-01-10 00:00:00')],
  [5, Timestamp('2019-01-13 00:00:00')],
  [6, Timestamp('2019-01-03 00:00:00')],
  [7, Timestamp('2019-01-05 00:00:00')],
  [8, Timestamp('2019-01-11 00:00:00')],
  [8, Timestamp('2019-01-21 00:00:00')],
  [9, Timestamp('2019-01-09 00:00:00')]]]
categoryid
[[[1, Timestamp('2019-01-04 00:00:00')],
  [1, Timestamp('2019-01-08 00:00:00')],
  [1, Timestamp('2019-01-19 00:00:00')],
  [1, Timestamp('2019-01-02 00:00:00')],
  [2, Timestamp('2019-01-17 00:00:00')],
  [2, Timestamp('2019-01-07 00:00:00')]],
 [[0, Timestamp('2019-01-06 00:00:00')],
  [0, Timestamp('2019-01-14 00:00:00')],
  [0, Timestamp('2019-01-20 00:00:00')],
  [2, Timestamp('2019-01-01 00:00:00')],
  [2, Timestamp('2019-01-12 00:00:00')],
  [2, Timestamp('2019-01-18 00:00:00')]],
 [[1, Timestamp('2019-01-16 00:00:00')],
  [1, Timestamp('2019-01-15 00:00:00')],
  [1, Timestamp('2019-01-10 00:00:00')],
  [1, Timestamp('2019-01-13 00:00:00')],
  [2, Timestamp('2019-01-03 00:00:00')],
  [2, Timestamp('2019-01-05 00:00:00')],
  [2, Timestamp('2019-01-11 00:00:00')],
  [2, Timestamp('2019-01-21 00:00:00')],
  [3, Timestamp('2019-01-09 00:00:00')]]]
</code></pre><h2 id="時系列順にソート">時系列順にソート</h2>
<p>次に、作成したリストを時系列順にソートする処理を加えます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sort_list</span>(inputs, is_descending):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    :param is_descending: 降順かどうか
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> [sorted(i_input, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> i: i[<span style="color:#ae81ff">1</span>], reverse<span style="color:#f92672">=</span>is_descending) <span style="color:#66d9ef">for</span> i_input <span style="color:#f92672">in</span> inputs]
</code></pre></div><p>この処理を行うと、</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">itemid_inputs <span style="color:#f92672">=</span> sort_list(itemid_inputs, is_descending<span style="color:#f92672">=</span>False)
categoryid_inputs <span style="color:#f92672">=</span> sort_list(categoryid_inputs, is_descending<span style="color:#f92672">=</span>False)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;itemid&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(itemid_inputs)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;categoryid&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(categoryid_inputs)
</code></pre></div><p>以下のように時系列順に並び替えられたリストが作成されます。</p>
<pre><code>itemid
[[[5, Timestamp('2019-01-02 00:00:00')],
  [3, Timestamp('2019-01-04 00:00:00')],
  [8, Timestamp('2019-01-07 00:00:00')],
  [4, Timestamp('2019-01-08 00:00:00')],
  [7, Timestamp('2019-01-17 00:00:00')],
  [4, Timestamp('2019-01-19 00:00:00')]],
 [[6, Timestamp('2019-01-01 00:00:00')],
  [0, Timestamp('2019-01-06 00:00:00')],
  [7, Timestamp('2019-01-12 00:00:00')],
  [1, Timestamp('2019-01-14 00:00:00')],
  [8, Timestamp('2019-01-18 00:00:00')],
  [2, Timestamp('2019-01-20 00:00:00')]],
 [[6, Timestamp('2019-01-03 00:00:00')],
  [7, Timestamp('2019-01-05 00:00:00')],
  [9, Timestamp('2019-01-09 00:00:00')],
  [5, Timestamp('2019-01-10 00:00:00')],
  [8, Timestamp('2019-01-11 00:00:00')],
  [5, Timestamp('2019-01-13 00:00:00')],
  [4, Timestamp('2019-01-15 00:00:00')],
  [3, Timestamp('2019-01-16 00:00:00')],
  [8, Timestamp('2019-01-21 00:00:00')]]]
categoryid
[[[1, Timestamp('2019-01-02 00:00:00')],
  [1, Timestamp('2019-01-04 00:00:00')],
  [2, Timestamp('2019-01-07 00:00:00')],
  [1, Timestamp('2019-01-08 00:00:00')],
  [2, Timestamp('2019-01-17 00:00:00')],
  [1, Timestamp('2019-01-19 00:00:00')]],
 [[2, Timestamp('2019-01-01 00:00:00')],
  [0, Timestamp('2019-01-06 00:00:00')],
  [2, Timestamp('2019-01-12 00:00:00')],
  [0, Timestamp('2019-01-14 00:00:00')],
  [2, Timestamp('2019-01-18 00:00:00')],
  [0, Timestamp('2019-01-20 00:00:00')]],
 [[2, Timestamp('2019-01-03 00:00:00')],
  [2, Timestamp('2019-01-05 00:00:00')],
  [3, Timestamp('2019-01-09 00:00:00')],
  [1, Timestamp('2019-01-10 00:00:00')],
  [2, Timestamp('2019-01-11 00:00:00')],
  [1, Timestamp('2019-01-13 00:00:00')],
  [1, Timestamp('2019-01-15 00:00:00')],
  [1, Timestamp('2019-01-16 00:00:00')],
  [2, Timestamp('2019-01-21 00:00:00')]]]
</code></pre><h2 id="時系列を考慮した系列データの作成">時系列を考慮した系列データの作成</h2>
<p>まず、上記で作成したリストから可変長の系列特徴量（シーケンシャルな特徴量）を作成するための処理は以下になります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_sequential</span>(inputs):
    <span style="color:#75715e"># リストのうちtimestampのリストを削除</span>
    <span style="color:#66d9ef">return</span> [[i[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> i_input] <span style="color:#66d9ef">for</span> i_input <span style="color:#f92672">in</span> inputs]
</code></pre></div><p>これを実行すると、</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;各ユーザーが接触したitemid（時系列順）&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_sequential(itemid_inputs))

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;各ユーザーが接触したcategoryid（時系列順）&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_sequential(categoryid_inputs))
</code></pre></div><p>求めていた結果を得ることができます。</p>
<pre><code>各ユーザーが接触したitemid（時系列順）
[[5, 3, 8, 4, 7, 4], 
 [6, 0, 7, 1, 8, 2], 
 [6, 7, 9, 5, 8, 5, 4, 3, 8]]

各ユーザーが接触したcategoryid（時系列順）
[[1, 1, 2, 1, 2, 1], 
 [2, 0, 2, 0, 2, 0], 
 [2, 2, 3, 1, 2, 1, 1, 1, 2]]
</code></pre><h2 id="時系列を考慮したカテゴリデータの作成">時系列を考慮したカテゴリデータの作成</h2>
<p>次に、上記で作成したリストから各ユーザーの最新のレコードをカテゴリ変数として取得するための処理は以下になります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_category</span>(inputs, n<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    :param n: 時系列順のリストのうち、何番目のものを残すか
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#75715e"># リストのうちtimestampのリストを削除</span>
    <span style="color:#75715e"># 時系列順の系列データのうち、n番目のもののみを残す</span>
    <span style="color:#66d9ef">return</span> [[i[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> i_input][n] <span style="color:#66d9ef">for</span> i_input <span style="color:#f92672">in</span> inputs]
</code></pre></div><p>これを実行すると、</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;各ユーザーが接触した最新のitemid&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_category(itemid_inputs, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;各ユーザーが接触した最新のcategoryid&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_category(categoryid_inputs, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</code></pre></div><p>以下のように求めていた結果を得ることができます。</p>
<pre><code>各ユーザーが接触した最新のitemid
[4, 2, 8]

各ユーザーが接触した最新のcategoryid
[1, 0, 2]
</code></pre><h2 id="処理まとめ">処理まとめ</h2>
<p>ここで、上記説明のために分けていた関数を統合すると以下のようになります。</p>
<pre><code class="language-pythondef" data-lang="pythondef">        df, user_index_col, sort_col, target_col, user_num, is_descending, is_sequence, n=-1):
    &quot;&quot;&quot;
    :param user_index_col: User ID column
    :param sort_col: Column containing the value to be used for sort
    :param target_col: column to sort
    :param user_num: Number of users (acquire from encoder etc.)
    :param is_descending: Whether it is descending
    :param is_sequence: Whether it is sequential
    :param n: Which item in the chronological list to keep (category only)
    &quot;&quot;&quot;
    #Create list
    inputs = [[] for _ in range(user_num)]
    for _, user_index, sort_value, target_value in df[[user_index_col, sort_col, target_col]].itertuples():
        inputs[user_index].append([target_value, sort_value])

    #Sort list
    inputs = [sorted(i_input, key=lambda i: i[1], reverse=is_descending) for i_input in inputs]

    if is_sequence:
        return [[i[0] for i in i_input] for i_input in inputs]
    else:
        return [[i[0] for i in i_input][n] for i_input in inputs]
</code></pre><p>#How to read data in pieces</p>
<p>This is where I wanted to write most, and if you create a list to hold time series information as described above, if you cannot put all the data in the memory, etc. It can also be used for processing.</p>
<p>As an example, assuming that the first DataFrame is divided into three and stored in the dictionary as follows,
(I don&rsquo;t think it is a case, but as an example,&hellip;)</p>
<pre><code>{'df1': userid itemid categoryid timestamp
0 0 3 1 2019-01-04
1 0 4 1 2019-01-08
2 0 4 1 2019-01-19
3 0 5 1 2019-01-02
4 0 7 2 2019-01-17
5 0 8 2 2019-01-07
6 1 0 0 2019-01-06,
 'df2': userid itemid categoryid timestamp
7 1 1 0 2019-01-14
8 1 2 0 2019-01-20
9 1 6 2 2019-01-01
10 1 7 2 2019-01-12
11 1 8 2 2019-01-18
12 2 3 1 2019-01-16
13 2 4 1 2019-01-15,
 'df3': userid itemid categoryid timestamp
14 2 5 1 2019-01-10
15 2 5 1 2019-01-13
16 2 6 2 2019-01-03
17 2 7 2 2019-01-05
18 2 8 2 2019-01-11
19 2 8 2 2019-01-21
20 2 9 3 2019-01-09}
</code></pre><p>Since the time series information is stored in the list, it can be processed by changing the function as follows, for example.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">create_features_by_datasets</span>(
        df_dict, user_index_col, sort_col, target_col, user_num, is_descending, is_sequence, n<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>):
    inputs <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(user_num)]

    <span style="color:#75715e"># Process for each division unit of the dataset</span>
    <span style="color:#66d9ef">for</span> df <span style="color:#f92672">in</span> df_dict<span style="color:#f92672">.</span>values():
        <span style="color:#66d9ef">for</span> _, user_index, sort_value, target_value <span style="color:#f92672">in</span> df[[user_index_col, sort_col, target_col]]<span style="color:#f92672">.</span>itertuples():
            inputs[user_index]<span style="color:#f92672">.</span>append([target_value, sort_value])

    inputs <span style="color:#f92672">=</span> [sorted(i_input, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> i: i[<span style="color:#ae81ff">1</span>], reverse<span style="color:#f92672">=</span>is_descending) <span style="color:#66d9ef">for</span> i_input <span style="color:#f92672">in</span> inputs]

    <span style="color:#66d9ef">if</span> is_sequence:
        <span style="color:#66d9ef">return</span> [[i[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> i_input] <span style="color:#66d9ef">for</span> i_input <span style="color:#f92672">in</span> inputs]
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> [[i[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> i_input][n] <span style="color:#66d9ef">for</span> i_input <span style="color:#f92672">in</span> inputs]
</code></pre></div><p>If you do the following</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;itemid that each user touched (in chronological order)&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_features_by_datasets(df_dict, user_index_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;userid&#39;</span>, sort_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;timestamp&#39;</span>, target_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;itemid&#39;</span>, user_num<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, is_descending<span style="color:#f92672">=</span>False, is_sequence<span style="color:#f92672">=</span>True))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Latest itemid contacted by each user&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_features_by_datasets(df_dict, user_index_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;userid&#39;</span>, sort_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;timestamp&#39;</span>, target_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;itemid&#39;</span>, user_num<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, is_descending<span style="color:#f92672">=</span>False, is_sequence<span style="color:#f92672">=</span>False))
</code></pre></div><p>The result is the same as above.</p>
<pre><code>Itemids contacted by each user (in chronological order)
[[5, 3, 8, 4, 7, 4],
 [6, 0, 7, 1, 8, 2],
 [6, 7, 9, 5, 8, 5, 4, 3, 8]]

The latest itemid contacted by each user
 [4, 2, 8]
</code></pre><h1 id="sort-other-than-time-series-information">Sort other than time series information</h1>
<p>Also, this time, the sorting criteria was narrowed down to time series information, but it is also possible to sort by other columns or in descending order.
By changing the variable passed to the above process, it is possible to sort in ascending/descending order or columns.</p>
<p>For example, in the following dataset</p>
<pre><code>    userid itemid categoryid score
0 0 3 1 0.730968
1 0 3 1 0.889117
2 0 3 1 0.714828
3 0 4 1 0.430737
4 0 5 1 0.734746
5 0 7 2 0.412346
6 1 0 0 0.660 430
7 1 3 1 0.095672
8 1 4 1 0.985072
9 1 5 1 0.629274
10 1 6 2 0.617733
11 1 7 2 0.636219
12 1 8 2 0.246769
13 1 8 2 0.020140
14 2 0 0 0.812525
15 2 1 0 0.671 100
16 2 2 0 0.174011
17 2 2 0 0.164321
18 2 3 1 0.783329
19 2 4 1 0.068837
20 2 5 1 0.265281
</code></pre><p>Even if there is a column called score, if you want to create series data or category data in that order, the process is as follows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Score order (itemid)&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_features(df, user_index_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;userid&#39;</span>, sort_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;score&#39;</span>, target_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;itemid&#39;</span>, user_num<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, is_descending<span style="color:#f92672">=</span>True, is_sequence<span style="color:#f92672">=</span>True))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;maximum score (itemid)&#39;</span>)
pprint<span style="color:#f92672">.</span>pprint(create_features(df, user_index_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;userid&#39;</span>, sort_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;score&#39;</span>, target_col<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;itemid&#39;</span>, user_num<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, is_descending<span style="color:#f92672">=</span>True, is_sequence<span style="color:#f92672">=</span>False, n<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>))
</code></pre></div><p>The result looks like this:</p>
<pre><code>Score order (itemid)[[3, 5, 3, 3, 4, 7],
  [4, 0, 7, 5, 6, 8, 3, 8],
  [0, 3, 1, 5, 2, 2, 4]]

Maximum score (itemid)
[3, 4, 0]
</code></pre><h1 id="at-the-end">At the end</h1>
<p>This time, I wrote about how to convert log data into series feature quantity and category feature quantity while saving memory while considering time series information.
If there is a better way, let me know in the comments. Thank you very much.</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
