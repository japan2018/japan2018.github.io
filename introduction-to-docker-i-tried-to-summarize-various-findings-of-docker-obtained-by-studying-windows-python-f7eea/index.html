<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://japan2018.github.io/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://japan2018.github.io/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://japan2018.github.io/favicon-16x16.png">

  
  <link rel="manifest" href="https://japan2018.github.io/site.webmanifest">

  
  <link rel="mask-icon" href="https://japan2018.github.io/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://japan2018.github.io/css/bootstrap.min.css" />

  
  <title>[Introduction to Docker] I tried to summarize various findings of Docker obtained by studying (Windows/Python) | Some Title</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>[Introduction to Docker] I tried to summarize various findings of Docker obtained by studying (Windows/Python)</h1>
<p>
  <small class="text-secondary">
  
  
  Jan 27, 2020
  </small>
  

<small><code><a href="https://japan2018.github.io/tags/python">Python</a></code></small>


<small><code><a href="https://japan2018.github.io/tags/linux"> Linux</a></code></small>


<small><code><a href="https://japan2018.github.io/tags/beginner"> beginner</a></code></small>


<small><code><a href="https://japan2018.github.io/tags/docker"> Docker</a></code></small>


<small><code><a href="https://japan2018.github.io/tags/python3"> Python3</a></code></small>

</p>
<pre><code>There was a person in charge of specialized infrastructure related things in the company, and he was kind to the environment, but it would be bad if I had to study Docker around myself as soon as possible. I've finally been introduced to Docker recently, so I'll try to put together and try what I have learned as a memorandum.
</code></pre>
<p>Since I have been working on unfamiliar work such as infrastructure around my career, please forgive me for things that are rough (shallow) in terms of knowledge.
I am also a beginner, and this article is for those who are not familiar with infrastructure.</p>
<p>We will focus on moving Linux and Python related things in the Windows environment (Docker for Windows).</p>
<h1 id="touch-in-this-article">Touch in this article</h1>
<ul>
<li>Outline and advantages of containers etc.</li>
<li>Install and set up Docker for Windows</li>
<li>Basics of container and image relationship</li>
<li>About Docker Hub and tags</li>
<li>Dockerfile basics</li>
<li>Actually building an image that entangled Python etc. in Ubuntu</li>
</ul>
<p>#Do not touch in this article</p>
<p>I won&rsquo;t cover the following mainly because the article is too long.
*If there is an opportunity, we will respond with another article&hellip;</p>
<ul>
<li>Around networks and filesystems</li>
<li>Around Docker Compose</li>
<li>Swarm, Kubernetes, etc.</li>
<li>Deployment around server etc.</li>
</ul>
<h1 id="what-is-a-container-in-the-first-place-what-are-you-happy-about-using-docker">What is a container in the first place? What are you happy about using Docker?</h1>
<blockquote>
<p>A container is a logical partition (container) on the host OS, and the libraries and applications necessary to run applications are grouped together so that they can be used as if they were individual servers. It was done. Resources of the host OS are logically separated and shared by multiple containers.
<a href="https://codezine.jp/article/detail/11336">What is a container? What is Kubernetes? Introduction, operation, use case explanation</a></p>
</blockquote>
<p>The image is difficult to attach with just this, so I will chew based on the image.</p>
<p>As an example, consider a website such as Django or Flask that uses a Linux server.
When developing, it is necessary to run Linux on the local PC such as Windows to match the production, and it is necessary to put the libraries such as Python and Django and the code of the website there.</p>
<p>This technology for running Linux on Windows is called a virtual environment (virtual machine), and it has been available for a long time by using tools and services such as VirtualBox and VMWare.</p>
<p>Is it the image that another PC is inside the Windows PC?
This makes it possible to prepare an environment similar to the production environment on the local PC and use it conveniently.</p>
<p>However, it may be necessary to allocate memory, CPU, etc. to each virtual environment, resources of the original Windows PC are rushed and resources are wasted too much, virtual environment startup time is long There was a painful side.</p>
<p>The illustration is a bit subtle, but let&rsquo;s compare it when you want to use multiple design tools (Photoshop, Illustrator, etc.).
Obviously, when you use these tools, you need to start your PC only once, like &ldquo;Start PC&rdquo; → &ldquo;Start Photoshop&rdquo; → &ldquo;Start Illustrator&rdquo; → &ldquo;&hellip;&rdquo;. It can also be started continuously.</p>
<p>On the other hand, in the case of VirtualBox etc., if you compare it with the tool above, &ldquo;Start PC&rdquo; → &ldquo;Start another PC&rdquo; → &ldquo;Start Photoshop&rdquo; → &ldquo;Start another PC&rdquo; → &ldquo;Start Illustrator&rdquo; Was necessary.
In this case, compared to the normal case, you have to wait for the time when each OS starts up, and the memory required for the OS is also brought, so it is wasteful and it is a painful place.</p>
<p>By using the container (Docker) technology, you can start the environment without waste as if you started multiple software in succession after starting the above OS (strictly, container relations are not only Docker There are various, but I will not touch this time.)</p>
<p>You can also launch Linux, Python on top of it, libraries to use, and website code as a container, just like a piece of software.
Since it can be used as if launching software without waste, the startup time is much shorter than when launching a virtual environment with VirtualBox, etc., and the environment in which other OS&rsquo;s are isolated is handled on Windows in a form close to production. You will be able to.</p>
<p>A rough sketch is as follows.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/9fa0ecf4-bda3-8898-a0f2-78fd5d872ecd.png" alt="temp0119_2.png"></p>
<p>In addition, there are various advantages such as easy integration of local environment for multiple people, comfortable with CI/CD, easy deployment, and so on.</p>
<blockquote>
<p>When developing an application by multiple people, it is necessary to set up the development environment for the number of developers&rsquo; machines (ignoring VDI). Well, it&rsquo;s tough
&hellip;
As long as this is a docker service/daemon running, you can insert one common Docker Image and all developers will get the exact same environment.
&hellip;
Since the image that was moved in development was exactly as it was in production and CI was also used in that development, you can see how it is advantageous from the stability and risk avoidance perspective.
<a href="https://cloudpack.media/41647">Why we use containers/Docker in 2018</a></p>
</blockquote>
<h2 id="easier-environment-building-and-sharing">Easier environment building and sharing</h2>
<p>In addition, since each container is built with the code (text) of a file called Dockerfile, it is also easy to reproduce the building procedure (also called Infrastructure as Code). ).
Until now, when creating the environment with VirtualBox etc., there were things that were quite painful, such as procedures and installation of necessary libraries (the order was different, the file size was huge even if shared, etc.).</p>
<p>In Docker, the required OS, libraries, code, etc. are specified in a text file, so it is easy to build, and it is easy to share and distribute the built ones.</p>
<h1 id="install-docker-for-windows">Install Docker for Windows</h1>
<p>I will install Docker on Windows at once.</p>
<p>First of all, Windows 10 is required (I think that most people are Windows 10 because Windows 7 has also ended support, but if it is Win 7, Docker cannot be used).</p>
<h2 id="enable-hyper-v-and-containers">Enable Hyper-V and Containers</h2>
<p>You need to enable the Hyper-V and Containers features in your Windows settings.
You can set it from &ldquo;Windows functions&rdquo;.</p>
<p>Search for &ldquo;apps and features&rdquo; in the start menu.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/9229f861-6d7f-3744-adab-3b48054fd445.png" alt="image.png"></p>
<p>Select &ldquo;Programs and Features&rdquo; on the right side of the settings screen that opens.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/7ccbb5a5-c80e-e6bd-595a-b5f02befae10.png" alt="image.png"></p>
<p>Select &ldquo;Turn Windows features on or off&rdquo; in the left menu.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/d66b5cdc-6c3c-acd2-bfe7-f3d5dec07c9f.png" alt="image.png"></p>
<p>In the opened window, check Cotnainers and Hyper-V.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/18e0d797-c127-4e1b-9838-ec4390f8ec17.png" alt="image.png"></p>
<p>Click OK and restart your PC.</p>
<h2 id="download-and-install-docker-desktop-for-windows">Download and install Docker Desktop for Windows</h2>
<p>Download the installer from the <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows?tab=description">Docker Desktop for Windows</a> page.
You will need a Docker account (you will need an account even when you are not downloading, as described later).
After creating the account, download it and install it using that installer (don&rsquo;t hesitate, just follow the installer&rsquo;s instructions and it will work for the time being).
Please note that the file is fairly large, close to 1GB.</p>
<p>After installation, sign out or restart once.</p>
<p>After restarting, Docker will start automatically.</p>
<p>You can check if the whale icon is displayed by clicking the resident application display part in the lower right.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/d78a5d9a-ff36-ebc9-d403-aec081a4b348.png" alt="image.png"></p>
<p>Open a command line and run the command to display the version to see if docker works.</p>
<pre><code>$ docker version
</code></pre><pre><code>Client: Docker Engine-Community
 Version: 19.03.5
 API version: 1.40
 Go version: go1.12.12
 Git commit: 633a0ea
 Built: Wed Nov 13 07:22:37 2019
 OS/Arch: windows/amd64
 Experimental: false

Server: Docker Engine-Community
 Engine:
  Version: 19.03.5
  API version: 1.40 (minimum version 1.12)
  Go version: go1.12.12
  Git commit: 633a0ea
  Built: Wed Nov 13 07:29:19 2019
  OS/Arch: linux/amd64
  Experimental: false
 containerd:Version: v1.2.10
  GitCommit: b34a5c8af56e510852c35414db4c1f4fa6172339
 runc:
  Version: 1.0.0-rc8+dev
  GitCommit: 3e425f80a8c931f88e6d94a8c831b9d5aa481657
 docker-init:
  Version: 0.18.0
  GitCommit: fec3683
</code></pre><p>It was displayed without any problems.</p>
<h1 id="switch-to-handle-linux">Switch to handle Linux</h1>
<p>With Docker for Windows, you can switch between using the Windows Docker environment on a Windows PC or using the Linux environment on a Windows PC.
Since I want to run Linux on Windows this time, I will switch to Linux.</p>
<p>Right-click the whale icon in the resident app in the lower left.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/0590294f-530e-36fd-386c-72f96d4d3f90.png" alt="image.png"></p>
<p>From the menu that appears, select Switch to Linux containers&hellip; (It may take some time to display it for the first time, etc. In that case, right-click and leave it for a while).
If it says Switch to Windows containers&hellip;, you have already switched to the Linux environment, so you do not need to do anything.</p>
<p>There is a warning, but there is no problem, so select Switch.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/809dfbba-88fb-761b-bcab-7c789e5fa1d8.png" alt="image.png"></p>
<p>Wait a few seconds and the Linux environment will be activated.</p>
<p>#What is an image?</p>
<p>The container is launched using something called an image.
The image is similar to something like a stopped virtual machine (or stopped container) or a template.
What kind of container is it? Information and data are variously packed.</p>
<h2 id="download-the-published-image">Download the published image</h2>
<p>You can create your own image, but first of all, I will drop what others have published.
You can drop something published by others, or you can publish it yourself, just as you drop the repository file on Github etc.</p>
<p>The commands are also formatted like git commands.
For example, to drop an Ubuntu image, you can use the following <code>image pull</code> command.</p>
<pre><code>$ docker image pull ubuntu:latest
</code></pre><pre><code>latest: Pulling from library/ubuntu
5c939e3a4d10: Pull complete
c63719cdbe7a: Pull complete
19a861ea6baf: Pull complete
651c9d2d6c4f: Pull complete
Digest: sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110
Status: Downloaded newer image for ubuntu:latest
docker.io/library/ubuntu:latest
</code></pre><p>The name of the image you want to drop in ubuntu, the latest part is called a tag and is used to specify the version.
(In addition to the version number, it does not necessarily mean the latest version, but the word latest as the latest stable version is often used.)</p>
<p>For images that exist locally, you can check the list of images in the same way as the Linux ls command (a command that displays a list of files in a directory).</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu latest ccc6e87d482b 4 days ago 64.2MB
</code></pre><h1 id="try-to-start-the-dropped-image">Try to start the dropped image</h1>
<p>I will start a container using the Ubuntu image that I pulled.
You can start the container with the <code>docker container run</code> command.</p>
<pre><code>$ docker container run -it ubuntu:latest bash
</code></pre><p>The <code>ubuntu:latest</code> part specifies the image (and the target tag) you want to launch.</p>
<p>The <code>bash</code> part at the end specifies the program you want to start on Ubuntu.
When you start Linux for server with VirtualBox etc., the black screen of the console appears, but like this, I want to be able to execute commands on Ubuntu, so I specified bash.</p>
<p>If you specify the argument of <code>-it</code>, it will specify the bash on Ubuntu started to the command prompt on Windows (please keep in mind that Linux other than Ubuntu may require something other than bash) ..
It&rsquo;s hard to understand if you write &ldquo;Assign,&rdquo; but the command prompt on Windows switches to the terminal when you log in to Linux.</p>
<p>If you look at the command prompt, you&rsquo;ll see that it&rsquo;s switched to the Ubuntu root user (a user view like <code>root@75ae40e15c7f:/#</code>) (when I first touched it, it was kind of strange at first). It became a feeling).</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/279471c7-bd00-c7c4-0d67-66883b531aff.png" alt="image.png"></p>
<p>In this state, you can actually execute the command for Ubuntu even though it is running on Windows. If you run the <code>ls</code> command, you&rsquo;ll see the directories you are accustomed to in Ubuntu.</p>
<pre><code>root@75ae40e15c7f:/# ls
</code></pre><pre><code>bin dev home lib64 mnt proc run srv tmp var
boot etc lib media opt root sbin sys usr
</code></pre><p>It&rsquo;s like booting Ubuntu and logging in.</p>
<p>Also, as mentioned above, the advantage of the container is that it starts up quickly, but in my environment it can be migrated in just a few seconds until the Ubuntu container is started with the above command and bash can be input. After all, it&rsquo;s much faster than booting with VirtualBox or VMWare.
This speed is good considering that it is normally started every day in the development environment.</p>
<p>The <code>-it</code> argument seems to be a combination of the <code>-i</code> and <code>-t</code> arguments, and the settings are as follows.</p>
<blockquote>
<p>-i is Keep STDIN open even if not attached
Continues to open standard input.</p>
<p>-t is Allocate a pseudo-TTY
Assign a pseudo tty.</p>
<p>Keep the standard input open and be able to manipulate it.
→ Allow input in docker in your environment
<a href="https://www.nyamucoro.com/entry/2018/01/11/224932">What is docker exec -it actually doing? [Day 90]</a></p>
</blockquote>
<h1 id="return-to-the-original-windows-command-prompt">Return to the original Windows command prompt</h1>
<p>If you want to return to the original Windows command prompt from bash on Ubuntu, execute exit or the command, or press Ctrl + P → Ctrl + Q on the keyboard to return.
If you execute the exit command, the container itself will be stopped depending on the condition (if that is the only process running?). If you type Ctrl + P → Ctrl + Q and go back, the Ubuntu container will remain running.</p>
<blockquote>
<p>Note that if you execute the exit command as if you were logging out of the server, the container that started will also stop.
<a href="https://qiita.com/kooohei/items/0e788a2ce8c30f9dba53">Create Docker container, start-stop</a></p>
</blockquote>
<h1 id="check-the-list-of-running-containers">Check the list of running containers</h1>
<p>Similar to the image ls command, you can use the container ls command (<code>docker container ls</code>) to display a list of running containers.
Start Ubuntu container as a trial, use Ctrl + P → Ctrl + Q shortcut (exit bash while it is running) instead of exit, and then check with ls command.</p>
<pre><code>$ docker container run -it ubuntu:latest bash
</code></pre><ul>
<li>Type Ctrl + P → Ctrl + Q to return to the Windows command prompt.</li>
</ul>
<pre><code>$ docker container ls
</code></pre><pre><code>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
e8f5c7aadcb5 ubuntu:latest &quot;bash&quot; About a minute ago Up About a minute xenodochial_hodgkin
</code></pre><p>The container information of Ubuntu started earlier is displayed.</p>
<h1 id="stop-running-container">Stop running container</h1>
<p>To stop it, specify <code>docker container stop &lt;parameter for identifying container&gt;</code>.</p>
<p>You can specify the CONTAINER ID or NAMES displayed by the above <code>docker container ls</code> command.
If you do not specify the NAMES value when starting the container, some value will be set automatically.</p>
<p>For example, if you specify the ID for the container you just started and stop it,</p>
<pre><code>$ docker container stop e8f5c7aadcb5
</code></pre><p>When stopping by specifying NAMES, it becomes as follows.</p>
<pre><code>$ docker container stop xenodochial_hodgkin```

If you check the running container again with the ls command after the stop processing, you can confirm that the running container is gone by displaying only the header.

</code></pre><p>$ docker container ls</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</p>
<pre><code>
# Name and start the container

You can start the container without specifying a name, but it is convenient to control it with a script if you specify a specific name.
To specify the name, specify `--name &lt;container name&gt;`. For example, if you want to specify the name ubuntutest as a container and start it, it will be as follows.

</code></pre><p>$ docker container run &ndash;name ubuntutest -it ubuntu:latest bash</p>
<pre><code>
If you return to the command prompt of Windows with the container started with Ctrl + P, Ctrl + Q and check with the ls command, you can see that the name ubuntutest specified in the argument is set as the value of NAMES.

</code></pre><p>$ docker container ls</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
9c1141a99d07 ubuntu:latest &ldquo;bash&rdquo; About a minute ago Up About a minute ubuntutest</p>
<pre><code>
Once stop the above container and proceed to the next.

</code></pre><p>$ docker container stop 9c1141a99d07</p>
<pre><code>
# Show a list of stopped containers

The normal `docker container ls` command will only show the running container.

</code></pre><p>$ docker container ls</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</p>
<pre><code>
However, the stopped container is not deleted locally.
You can also display stopped containers by adding the `-a` option.

</code></pre><p>$ docker container ls -a</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
9c1141a99d07 ubuntu:latest &ldquo;bash&rdquo; 10 hours ago Exited (0) 43 seconds ago ubuntutest
e8f5c7aadcb5 ubuntu:latest &ldquo;bash&rdquo; 11 hours ago Exited (0) 11 hours ago xenodochial_hodgkin
39c583048c7f ubuntu:latest &ldquo;bash&rdquo; 23 hours ago Exited (0) 23 hours ago nervous_swanson
&hellip;</p>
<pre><code>
# Remove container

For a stopped container, you can remove the target container with the command of the format `docker container rm &lt;target container ID or name&gt;`.

</code></pre><p>$ docker container rm ubuntutest</p>
<pre><code>
If you check with the ls command, you can see that the container named ubuntutest (ID=9c1141a99d07) at the top has disappeared.

</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
e8f5c7aadcb5 ubuntu:latest &ldquo;bash&rdquo; 11 hours ago Exited (0) 11 hours ago xenodochial_hodgkin
39c583048c7f ubuntu:latest &ldquo;bash&rdquo; 23 hours ago Exited (0) 23 hours ago nervous_swanson
&hellip;</p>
<pre><code>
Note that you cannot basically delete a running container, so you need to stop it. Start the container with the name running_ubuntu as a trial, return to the command prompt while starting with Ctrl + P → Ctrl + Q, and try deleting.

</code></pre><p>$ docker container run &ndash;name running_ubuntu -it ubuntu:latest bash</p>
<pre><code>
* Press Ctrl + P → Ctrl + Q.

</code></pre><p>$ docker container rm running_ubuntu</p>
<pre><code>
You get angry as follows.

</code></pre><p>Error response from daemon: You cannot remove a running container 95586a709576d33521072c1b40c2d84e5c3881a6d6468b485958e62f6d2a3440.Stop the container before attempting removal or force remove</p>
<pre><code>
You can forcibly remove it by adding the `-f` option. However, there is an impression that basically it is preferable to follow the process of stopping → deleting.

</code></pre><p>$ docker container rm -f running_ubuntu</p>
<pre><code>
# What if you specify the same name and start it multiple times in a container?

If you start a container without specifying a name (--name argument), another container will be started each time.
So what happens when you try to launch with the same name multiple times while specifying the name?
Start the container with the name same_name_ubuntu.

</code></pre><p>$ docker container run &ndash;name same_name_ubuntu -it ubuntu:latest bash</p>
<pre><code>
Return to the Windows command prompt from bash while starting with Ctrl + P, Ctrl + Q.
Try to start the container again with the same name.

</code></pre><p>$ docker container run &ndash;name same_name_ubuntu -it ubuntu:latest bash</p>
<pre><code>
Then, as shown below, another container does not start up and it is played with an error, and you can see that the name must be unique.

</code></pre><p>docker: Error response from daemon: Conflict. The container name &ldquo;/same_name_ubuntu&rdquo; is already in use by container &ldquo;9abe70cdbc98350f18b780880fd3b2ba23d0202b1cdb464c290dfe929924188b&rdquo;. You have to remove (or rename) that container to be able to reuse that name.
See&rsquo;docker run &ndash;help&rsquo;.</p>
<pre><code>
# Resume a stopped container

To restart a stopped container, run the command in the format `docker start &lt;container id or name&gt;`. It is neither `docker container run` nor `docker container start`, but in the format `docker start`.

Stop the running container once:

</code></pre><p>$ docker container stop same_name_ubuntu</p>
<pre><code>
Start with:

</code></pre><p>$ docker start same_name_ubuntu</p>
<pre><code>
If you execute the ls command, you can confirm that it is running properly.

</code></pre><p>$ docker container ls</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
9abe70cdbc98 ubuntu:latest &ldquo;bash&rdquo; 35 minutes ago Up 4 minutes same_name_ubuntu</p>
<pre><code>
In addition, this command does not switch to bash just by starting the container.


# How to re-enter bash for running container?

When you exit bash while starting with Ctrl + P, Ctrl + Q, or you want to switch to bash again after starting the container with the `docker start` command, or to start the application in another arbitrary container You can run it with the `docker container exec` command.

</code></pre><p>$ docker container exec -it same_name_ubuntu bash</p>
<pre><code>
The command prompt will be displayed as `root@9abe70cdbc98:/#` and you can see that you have switched to bash.

#Delete image

Images can be deleted in the same way as containers.Specify the IMAGE ID value instead of the CONTAINER ID because it can be confirmed with the ls command.

</code></pre><p>$ docker image ls</p>
<pre><code>
</code></pre><p>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu latest ccc6e87d482b 6 days ago 64.2MB</p>
<pre><code>
However, it will be played if the corresponding image is used in any container.

</code></pre><p>$ docker image rm ccc6e87d482b</p>
<pre><code>
</code></pre><p>Error response from daemon: conflict: unable to delete ccc6e87d482b (cannot be forced)-image is being used by running container 9abe70cdbc98</p>
<pre><code>
The error content is that it is used in the running container and can not be deleted, but even if you stop the container, you get angry with the error.
Use the ls command to check the container that is running as a trial, stop the container, and then execute the delete command again.

</code></pre><p>$ docker container ls</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
9abe70cdbc98 ubuntu:latest &ldquo;bash&rdquo; 14 hours ago Up 14 hours same_name_ubuntu</p>
<pre><code>
</code></pre><p>$ docker container stop 9abe70cdbc98</p>
<pre><code>
</code></pre><p>$ docker image rm ccc6e87d482b</p>
<pre><code>
</code></pre><p>Error response from daemon: conflict: unable to delete ccc6e87d482b (must be forced)-image is being used by stopped container 75ae40e15c7f</p>
<pre><code>
The error content is `image is being used by stopped container`, and you can see that it is played even if it is used in a stopped container.

Like the container, you can forcibly delete it for the time being by adding the `-f` option. However, be careful when executing because it may adversely affect the container side.

</code></pre><p>$ docker image rm -f ccc6e87d482b</p>
<pre><code>
</code></pre><p>Untagged: ubuntu:latest
Untagged: ubuntu@sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110
Deleted: sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0</p>
<pre><code>
Besides the ID, you can also delete a specific image by specifying `&lt;image name&gt;:&lt;tag name&gt;`.

</code></pre><p>$ docker image rm ubuntu:latest</p>
<pre><code>
Since deleting the original image or leaving the affected container as it is is subtle, in the next section I will delete the stopped container at once.

# Delete all stopped containers at once

Although it is a feeling that you need to be careful (such as deleting the containers you do not want to delete), you can batch delete the stopped containers with the `docker container prune` command.

If you check with the ls command, you can see that various stopped containers remain.

</code></pre><p>$ docker container ls -a</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
9abe70cdbc98 ccc6e87d482b &ldquo;bash&rdquo; 15 hours ago Exited (0) 23 minutes ago same_name_ubuntu
e8f5c7aadcb5 ccc6e87d482b &ldquo;bash&rdquo; 26 hours ago Exited (0) 26 hours ago xenodochial_hodgkin
39c583048c7f ccc6e87d482b &ldquo;bash&rdquo; 38 hours ago Exited (0) 38 hours ago nervous_swanson
&hellip;</p>
<pre><code>
Try running the prune command.

</code></pre><p>$ docker container prune</p>
<pre><code>
At the warning, type y and press Enter.

</code></pre><p>WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N]</p>
<pre><code>
</code></pre><p>Deleted Containers:
9abe70cdbc98350f18b780880fd3b2ba23d0202b1cdb464c290dfe929924188b
e8f5c7aadcb54cbddb1b9857ffc6c9ae16d389023f094fd8fb52385ad1195c47
39c583048c7f63c425c5bcb1e88cbf10fa5a6e69f736e1f3db235678cbac089e
&hellip;</p>
<p>Total reclaimed space: 33B</p>
<pre><code>
If you check it with the ls command, you can see that it has been deleted properly.

</code></pre><p>$ docker container ls -a</p>
<pre><code>
</code></pre><p>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</p>
<pre><code>
# Stopping the container does not delete the internal data

Even if you stop the container with `docker container stop`, the data such as added internal files will remain.
As an experiment, add an Ubuntu container, add a file from bash, stop it, then restart it and check that the file remains.

Since all the containers etc. were deleted up to the previous section, add and start the container again with the `docker container run` command. This time, I prefixed it with file_persistency_test.
Although the image has already been deleted, if the specified image is not found locally with the `docker container run` command, it will pull at the same time. Convenient.

</code></pre><p>$ docker container run &ndash;name file_persistency_test -it ubuntu:latest bash</p>
<pre><code>
</code></pre><p>Unable to find image&rsquo;ubuntu:latest&rsquo; locally
latest: Pulling from library/ubuntu
5c939e3a4d10: Pull complete
c63719cdbe7a: Pull complete
19a861ea6baf: Pull complete
651c9d2d6c4f: Pull complete
Digest: sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110
Status: Downloaded newer image for ubuntu:latest</p>
<pre><code>
Since it switches to Ubuntu bash, move to the tmp folder with the cd command and save the file for confirmation.

</code></pre><p>root@d289b867492e:/# cd tmp</p>
<pre><code>
Write with the file name `test_file.txt`.

</code></pre><p>root@d289b867492e:/tmp# echo &ldquo;I am a cat&rdquo; &raquo; test_file.txt</p>
<pre><code>
Check the written contents with the cat command.

</code></pre><p>root@d289b867492e:/tmp# cat test_file.txt</p>
<pre><code>
</code></pre><p>I am a cat</p>
<pre><code>
It seems that the data has been written successfully, so stop the container and start it again.
It is okay to exit bash and stop it with exit, but since it may not stop due to the startup process, normally use Ctrl + P, Ctrl + Q to exit and then stop with a command.

</code></pre><p>$ docker container stop file_persistency_test</p>
<pre><code>
Start again.

</code></pre><p>$ docker start file_persistency_test</p>
<pre><code>
Switch to bash.

</code></pre><p>$ docker container exec -it file_persistency_test bash</p>
<pre><code>
Go to the tmp folder and make sure the files remain.

</code></pre><p>root@d289b867492e:/# cd tmp
root@d289b867492e:/tmp# ls</p>
<pre><code>
</code></pre><p>test_file.txt</p>
<pre><code>
</code></pre><p>root@d289b867492e:/tmp# cat test_file.txt</p>
<pre><code>
</code></pre><p>I am a cat</p>
<pre><code>
It was displayed safely. It was confirmed that the file remains even if the container is stopped.

# About Docker Hub

I was pulling images without explanation, but these images have been dropped from the official Docker server called Docker Hub.

[Docker Hub](https://hub.docker.com/)![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/0fb867dc-8920-437e-27ea-a2fef78640d3.png)

As I will mention later, you can upload an image yourself and publish it in addition to pulling the image of others.

The image is also published on a server other than Docker Hub, and you can drop it and use it, but basically Docker Hub is the main.
Except for special cases, you will basically be using Docker Hub.

#Search for images

If you want to find the image you need, you can find it by searching Google with something like `docker hub &lt;keyword of target image&gt;`.

For example, if you want to find MongoDB image, you can use `docker hub mongodb`.

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/45362264-9e49-7293-5560-165296d8a2aa.png)

You can check the information of each tag and the pull command in that tag by looking at the pull command and the Tags tab.

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/9c9807af-de9e-3561-396d-9f584a3947f7.png)

Besides, you can also search on the command prompt by using the `docker search` command.

</code></pre><p>$ docker search mongo</p>
<pre><code>
</code></pre><p>NAME DESCRIPTION STARS OFFICIAL AUTOMATED
mongo MongoDB document databases provide high avai… 6519 [OK]
mongo-express Web-based MongoDB admin interface, written w… 600 [OK]
tutum/mongodb MongoDB Docker image – listens in port 27017… 229 [OK]
bitnami/mongodb Bitnami MongoDB Docker Image 108 [OK]
mongoclient/mongoclient Official docker image for Mongoclient, featu… 79 [OK]
mongooseim/mongooseim Small docker image for MongooseIM-robust a… 19
frodenas/mongodb A Docker Image for MongoDB 18 [OK]
cvallance/mongo-k8s-sidecar Kubernetes side car to setup and maintain a …14 [OK]</p>
<pre><code>
About 25 of the most popular images are displayed in descending order from popular image repositories.

If you want to check more than that, you can display up to 100 by specifying the --limit option.

</code></pre><p>$ docker search &ndash;limit 50 mongo</p>
<pre><code>
# About official and unofficial images (repositories)

In the `docker search` command above, there was a column called OFFICIAL in the search results.

</code></pre><p>NAME &hellip; OFFICIAL AUTOMATED
mongo&hellip; [OK]
mongo-express &hellip; [OK]
tutum/mongodb &hellip; [OK]
bitnami/mongodb &hellip; [OK]
mongoclient/mongoclient &hellip; [OK]</p>
<pre><code>
You can see that some repositories are marked as OK and some are empty.
This can be used to judge whether the repository is officially handled by Docker.
Repositories that are not marked with [OK] will be repositories that are personal or not related to the official third party.

While they are often useful, some may be stuck with updates, left vulnerable, or left with bugs.
If you use it, you are at your own risk.
Of course, officially such vulnerabilities may be found, and even if it is official, it is not safe, but there is a possibility that there will be a difference depending on whether or not the update is properly done in such a case.

# Search only official repositories

You can limit the search to official repositories by adding the argument `--filter &quot;is-official=true&quot;`.

</code></pre><p>$ docker search mongo &ndash;filter &ldquo;is-official=true&rdquo;</p>
<pre><code>
</code></pre><p>NAME DESCRIPTION STARS OFFICIAL AUTOMATED
mongo MongoDB document databases provide high avai… 6519 [OK]
mongo-express Web-based MongoDB admin interface, written w… 600 [OK]</p>
<pre><code>
# Check image details with inspect command

You can check the details of the target image with the command of the format `docker image inspect &lt;image name:tag or ID&gt;`.

Information displayed includes various information such as set tags, hash values for uniqueness determination, generation date and time, set values, executed commands, OS, size, network information, mount (file system).

</code></pre><p>$ docker image inspect ubuntu:latest</p>
<pre><code>
</code></pre><p>[
{
&ldquo;Id&rdquo;: &ldquo;sha256:ccc6e87d482b79dd1645affd958479139486e47191dfe7a997c862d89cd8b4c0&rdquo;,
&ldquo;RepoTags&rdquo;: [
&ldquo;ubuntu:latest&rdquo;
],
&ldquo;RepoDigests&rdquo;: [
&ldquo;ubuntu@sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110&rdquo;
],
&ldquo;Parent&rdquo;: &ldquo;&rdquo;,
&ldquo;Comment&rdquo;: &ldquo;&rdquo;,
&ldquo;Created&rdquo;: &ldquo;2020-01-16T01:20:34.28326882Z&rdquo;,
&ldquo;Container&rdquo;: &ldquo;8fadb7780c5426c7a294cc9fdb50294da831d550a3ecaf8382737d6b141b3054&rdquo;,
&ldquo;ContainerConfig&rdquo;: {
&ldquo;Hostname&rdquo;: &ldquo;8fadb7780c54&rdquo;,
&ldquo;Domainname&rdquo;: &ldquo;&rdquo;,
&ldquo;User&rdquo;: &ldquo;&rdquo;,
&ldquo;AttachStdin&rdquo;: false,
&ldquo;AttachStdout&rdquo;: false,
&ldquo;AttachStderr&rdquo;: false,
&ldquo;Tty&rdquo;: false,
&ldquo;OpenStdin&rdquo;: false,
&ldquo;StdinOnce&rdquo;: false,
&ldquo;Env&rdquo;: [
&ldquo;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&rdquo;
],
&ldquo;Cmd&rdquo;: [
&ldquo;/bin/sh&rdquo;,
&ldquo;-c&rdquo;,
&ldquo;#(nop) &ldquo;,
&ldquo;CMD [&quot;/bin/bash&quot;]&rdquo;
],
&ldquo;ArgsEscaped&rdquo;: true,
&ldquo;Image&rdquo;: &ldquo;sha256:d73776eba985c9fbd43227fbf32eeb85baf88775dc0c27db7edb0c8ddeb72b26&rdquo;,
&ldquo;Volumes&rdquo;: null,
&ldquo;WorkingDir&rdquo;: &ldquo;&rdquo;,
&ldquo;Entrypoint&rdquo;: null,
&ldquo;OnBuild&rdquo;: null,
&ldquo;Labels&rdquo;: {}
},
&ldquo;DockerVersion&rdquo;: &ldquo;18.06.1-ce&rdquo;,
&ldquo;Author&rdquo;: &ldquo;&rdquo;,
&ldquo;Config&rdquo;: {
&ldquo;Hostname&rdquo;: &ldquo;&rdquo;,&ldquo;Domainname&rdquo;: &ldquo;&rdquo;,
&ldquo;User&rdquo;: &ldquo;&rdquo;,
&ldquo;AttachStdin&rdquo;: false,
&ldquo;AttachStdout&rdquo;: false,
&ldquo;AttachStderr&rdquo;: false,
&ldquo;Tty&rdquo;: false,
&ldquo;OpenStdin&rdquo;: false,
&ldquo;StdinOnce&rdquo;: false,
&ldquo;Env&rdquo;: [
&ldquo;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&rdquo;
],
&ldquo;Cmd&rdquo;: [
&ldquo;/bin/bash&rdquo;
],
&ldquo;ArgsEscaped&rdquo;: true,
&ldquo;Image&rdquo;: &ldquo;sha256:d73776eba985c9fbd43227fbf32eeb85baf88775dc0c27db7edb0c8ddeb72b26&rdquo;,
&ldquo;Volumes&rdquo;: null,
&ldquo;WorkingDir&rdquo;: &ldquo;&rdquo;,
&ldquo;Entrypoint&rdquo;: null,
&ldquo;OnBuild&rdquo;: null,
&ldquo;Labels&rdquo;: null
},
&ldquo;Architecture&rdquo;: &ldquo;amd64&rdquo;,
&ldquo;Os&rdquo;: &ldquo;linux&rdquo;,
&ldquo;Size&rdquo;: 64194748,
&ldquo;VirtualSize&rdquo;: 64194748,
&ldquo;GraphDriver&rdquo;: {
&ldquo;Data&rdquo;: {
&ldquo;LowerDir&rdquo;: &ldquo;/var/lib/docker/overlay2/f03c69f5d7637556772ae1b2c650e1872f8a574db88e45f3911315729db0a59c/diff:/var/lib/docker/overlay2/1c79f0978277afcdf1c118571885a43fe9be6d979eeaafd5b27196e757628da0/diff:/var/lib/docker/overlay2/0109eef00cd0de560fdbdf6c680e1cf89511736fb8b24180c9ef889e37611e59/diff&rdquo;,
&ldquo;MergedDir&rdquo;: &ldquo;/var/lib/docker/overlay2/e902d5b0ebae48707cca044bdbf7b1397c560bd58b397c841e426b20de6f5333/merged&rdquo;,
&ldquo;UpperDir&rdquo;: &ldquo;/var/lib/docker/overlay2/e902d5b0ebae48707cca044bdbf7b1397c560bd58b397c841e426b20de6f5333/diff&rdquo;,
&ldquo;WorkDir&rdquo;: &ldquo;/var/lib/docker/overlay2/e902d5b0ebae48707cca044bdbf7b1397c560bd58b397c841e426b20de6f5333/work&rdquo;
},
&ldquo;Name&rdquo;: &ldquo;overlay2&rdquo;
},
&ldquo;RootFS&rdquo;: {
&ldquo;Type&rdquo;: &ldquo;layers&rdquo;,
&ldquo;Layers&rdquo;: [
&ldquo;sha256:43c67172d1d182ca5460fc962f8f053f33028e0a3a1d423e05d91b532429e73d&rdquo;,
&ldquo;sha256:21ec61b65b20ec53a1b7f069fd04df5acb0e75434bd3603c88467c8bfc80d9c6&rdquo;,
&ldquo;sha256:1d0dfb259f6a31f95efcba61f0a3afa318448890610c7d9a64dc4e95f9add843&rdquo;,
&ldquo;sha256:f55aa0bd26b801374773c103bed4479865d0e37435b848cb39d164ccb2c3ba51&rdquo;
]
},
&ldquo;Metadata&rdquo;: {
&ldquo;LastTagTime&rdquo;: &ldquo;0001-01-01T00:00:00Z&rdquo;
}
}
]</p>
<pre><code>
# イメージのレイヤーの話

各イメージは、複数のレイヤーという要素で構成されています。
各イメージでレイヤーが何個で構成されているかは前述の`docker image inspect`コマンドで確認することができます。

Ubuntuのイメージで確認してみると、以下のように4つのレイヤーで構成されていることが分かります（バージョンによってレイヤー数はある程度前後します）。

</code></pre><p>$ docker image inspect ubuntu:latest</p>
<pre><code>
</code></pre><p>&hellip;
&ldquo;RootFS&rdquo;: {
&ldquo;Type&rdquo;: &ldquo;layers&rdquo;,
&ldquo;Layers&rdquo;: [
&ldquo;sha256:43c67172d1d182ca5460fc962f8f053f33028e0a3a1d423e05d91b532429e73d&rdquo;,
&ldquo;sha256:21ec61b65b20ec53a1b7f069fd04df5acb0e75434bd3603c88467c8bfc80d9c6&rdquo;,
&ldquo;sha256:1d0dfb259f6a31f95efcba61f0a3afa318448890610c7d9a64dc4e95f9add843&rdquo;,
&ldquo;sha256:f55aa0bd26b801374773c103bed4479865d0e37435b848cb39d164ccb2c3ba51&rdquo;
]
},
&hellip;</p>
<pre><code>
例えば自分でイメージを作る際に、Linuxのイメージに加えて、Python関係を色々入れたり・・・と、要素を追加していくとレイヤーがどんどん増えていきます。
一方で、メタデータのみの追加であれば特にレイヤーは追加されません（詳細は後述しますが、例えばDockerfileにて指定する、コンテナ起動時に実行して欲しいコマンドの指定のための`CMD`の設定などは、メタデータの追加のみのためレイヤーは追加されません）。


# なぜレイヤーが分かれているのか

いくつか理由がありますが、大きな点の1つとしてイメージをpullする際に、すでにローカルに該当のイメージで必要な特定のレイヤーが存在すれば、そのレイヤーのダウンロードはスキップされ、処理時間が短縮されるというメリットがあります。

たとえば、特定のイメージでレイヤーを4つ使っているとします。次のマイナーバージョンが公開され、その際に4つのレイヤーのうち1つが更新されているとします。
ユーザーがアップデートのためpullすると、新バージョンのイメージ全体のダウンロードが実行されるのではなく、更新された1レイヤーのみがダウンロードされ、該当バージョンのイメージが利用可能になります。
この複数のイメージ間でレイヤーが共有されることによって、ローカルのディスクサイズの節約やダウンロード時間の節約に繋がります。

この辺りはpullコマンドの際に確認することができます。
ダウンロードがレイヤーごとに実行されるため、すでにローカルに該当のレイヤーが存在すれば`Already exists`という表示になり、pullがスキップされていることが確認できます。

</code></pre><p>$ docker image pull mongo:4.2.2</p>
<pre><code>
</code></pre><p>5c939e3a4d10: Already exists
c63719cdbe7a: Already exists
19a861ea6baf: Already exists
651c9d2d6c4f: Already exists
85155c6d5fac: Pull complete
85fb0780fd97: Pull complete
85b3b1a901f5: Pull complete
6a882e007bb6: Pull complete
f7806503a70f: Pull complete
e23d5068c270: Pull complete
56eb708963d7: Pull complete
fc4def32f081: Pull complete
ea1dc19faea9: Pull complete
Digest: sha256:a1a71d8659ef2f944469f9eb876a44b7ae7c05153f356c18c165fd485fc60f2b
Status: Downloaded newer image for mongo:4.2.2
docker.io/library/mongo:4.2.2</p>
<pre><code>
# コンテナの自動の再起動設定（restart policy）

コンテナが何らかの要因で終了してしまったり、Docker自体を再起動した際に自動で再起動するようにする機能があります。
なんらかの要因でプロセスが死んでしまって、手動で再起動したりせずに済むようになります。

設定はコンテナごとに行えます。`docker container run`コマンドに`--restart`オプションを指定することで設定ができます。

`--restart`オプションには以下のいずれかの値を指定します。

-  **always**: 一通りの条件でコンテナが再起動するようになる。
-  **on-failure**: コンテナのプロセスがエラーで終了した場合や、Docker再起動時などに正常に終了しなかった場合などに再起動するようになる。
-  **unless-stopped**: 明示的にstopコマンドでコンテナが停止している場合にDockerを再起動などしてもコンテナは再起動しない。それ以外はalwaysと同様大体再起動する。

※明示的に対象のコンテナをstopコマンドで手動で止めた場合にはalwaysでも再起動しません（そこで再起動してしまうと止めれなくなりますしね・・・）。ただし、停止させている状態でDocker自体を再起動した際などには該当コンテナも再起動します。

実際に試してみます。実験のため、一旦起動しているコンテナを全て停止し、lsコマンドの結果が空になるようにしておきます（起動中のものがあれば`docker container stop`コマンドで止めておきます）。

</code></pre><p>$ docker container ls</p>
<pre><code>
```CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
</code></pre><p>First, try from <code>--restart always</code>.
We will proceed with the name <code>always_restart_ubuntu</code>.</p>
<pre><code>$ docker container run -it --restart always --name always_restart_ubuntu ubuntu:latest bash
</code></pre><p>Exit bash while starting with Ctrl + P, Ctrl + Q.
Use the ls command to confirm that the relevant container has started.</p>
<pre><code>$ docker container ls
</code></pre><pre><code>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
eb83d8b715ed ubuntu:latest &quot;bash&quot; 8 seconds ago Up 7 seconds always_restart_ubuntu
</code></pre><p>Try restarting Docker and make sure that the affected container also restarts.
You can restart Docker from &ldquo;Restart&hellip;&rdquo; in the context menu that appears when you right-click the whale icon of the resident app in the lower left.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/d78a5d9a-ff36-ebc9-d403-aec081a4b348.png" alt="image.png"></p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/d965fdfc-680b-630e-ceee-7f84b70bc2f7.png" alt="image.png"></p>
<p>There is a warning, but there is no problem so proceed as it is.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/7f410668-41fe-579d-9a7c-8b6e92414adf.png" alt="image.png"></p>
<p>While restarting, when you hover over the whale icon, it is displayed that it is restarting. Wait a while and the restart of Docker will be completed.</p>
<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/228778/812a8d78-ec3c-20d0-8219-66557bbfb609.png" alt="image.png"></p>
<p>Try to display the running container with the ls command.</p>
<pre><code>$ docker container ls
</code></pre><pre><code>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
eb83d8b715ed ubuntu:latest &quot;bash&quot; 7 minutes ago Up About a minute always_restart_ubuntu
</code></pre><p>You can see that the container that has the corresponding <code>--restart</code> setting is successfully started.
Also, while <code>CREATED</code> is about 7 minutes ago, <code>STATUS</code> is displayed as being started about 1 minute ago, so it is stopped when Docker is restarted, and the container also matches with Docker. You can see that it is newly started.</p>
<p>What is #Dockerfile</p>
<p>A Dockerfile is like instructions for creating a container image.
It is used to tell Docker when you create an image yourself, &ldquo;Please make an image of a container like this&rdquo;.
Since there is a fixed format, you can create an image with the <code>docker image build</code> command after writing according to that format.</p>
<h1 id="make-your-own-image-build">Make your own image (build)</h1>
<p>Prepare the Dockerfile yourself and build it with the build command.
Since it is the first time, let&rsquo;s proceed with the minimum configuration and specify only Ubuntu.</p>
<p>Prepare an empty folder. This time we will proceed with the name build_test_1.
Add a file named Dockerfile to that folder (do not set the extension).</p>
<pre><code class="language-docker:build_test_1\Dockerfile" data-lang="docker:build_test_1\Dockerfile">FROM ubuntu:18.04

</code></pre><p><code>FROM</code> is the designation of the base image. Specify basic things such as OS images (Ubuntu is specified this time).
Write at the beginning of the Dockerfile.</p>
<p>Also, if the tag is latest, it will be a different version of Ubuntu at the future build timing, so a fixed version is specified.</p>
<p>Note that the Docker best practices document recommends that you specify the official image repository as FROM.</p>
<blockquote>
<p>If possible, use the current official repository as the basis for your image. We recommend the Debian image. This is because it is very well managed and kept to be the smallest of any distribution (currently less than 100 MB).
<a href="http://docs.docker.jp/engine/articles/dockerfile_best-practice.html#from">Dockerfile Best Practices</a></p>
</blockquote>
<p>Before executing the build, at the Windows command prompt, change to the folder where this Docker file is installed.</p>
<pre><code>$ cd build_test_1
</code></pre><p>Check the file with the dir command (a command similar to the ls command on Windows).</p>
<pre><code>$ dir
</code></pre><pre><code>2020/01/22 17:34 19 Dockerfile
</code></pre><p>Build is executed with a command in the format of <code>docker image build -t &lt;name to give to image&gt;:&lt;tag name&gt; &lt;path where Dockerfile is installed&gt;</code>.</p>
<p>This time, the image name is ubuntu_build_test_1 and the tag name is 0.0.1.
Regarding the path where the Dockerfile is installed, it has already been moved to the Dockerfile installation directory, so specify the path directly below.</p>
<pre><code>$ docker image build -t ubuntu_build_test_1:1.0.0 ./
</code></pre><p>It ended without error.</p>
<pre><code>Sending build context to Docker daemon 2.048kB
Step 1/1 :From ubuntu:18.04
18.04: Pulling from library/ubuntu
Digest: sha256:8d31dad0c58f552e890d68bbfb735588b6b820a46e459672d96e585871acc110
Status: Downloaded newer image for ubuntu:18.04
 ---&gt; ccc6e87d482b
Successfully built ccc6e87d482b
Successfully tagged ubuntu_build_test_1:1.0.0
</code></pre><p>However, there is a warning at the end.</p>
<pre><code>SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host.All files and directories added to build context will have'-rwxr-xr-x' permissions.It is recommended to double check and reset permissions for sensitive files and directories.
</code></pre><p>Hmm&hellip; When building Linux on Windows, the permissions of all files seem to have fixed values. It seems that sensitive files and directories should have their permissions changed properly.
It is a must check when using it in practice.
Since this is a trial, I will proceed as it is.</p>
<p>If you run the ls command, you will see that the image you built has been added properly.</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
...
ubuntu_build_test_1 1.0.0 ccc6e87d482b 6 days ago 64.2MB
</code></pre><p>Of course, you can also use the commands of each docker you have tried so far.
You can start it as follows.</p>
<pre><code>$ docker container run -it ubuntu_build_test_1:1.0.0 bash
</code></pre><h1 id="add-python-installation-relationship-to-dockerfile">Add Python installation relationship to Dockerfile</h1>
<p>If you run the Python command on the Ubuntu image you built in the previous section, you can see that Python is not included.</p>
<pre><code>root@762ce425ca58:/# python -V
</code></pre><pre><code>bash: python: command not found
</code></pre><p>This is probably the impression that &ldquo;containers should be trimmed of waste and kept small&rdquo; according to best practices. By that amount, the image of official Ubuntu etc. is much smaller.</p>
<blockquote>
<p>Containers created using images defined in a Dockerfile should be ephemeral if possible. Our &ldquo;ephemeral&rdquo; means it can be stopped and destroyed, and obviously built and used with a minimal setup.
&hellip;
To reduce complexity, dependencies, file size, and build order respectively, extra or unnecessary &ldquo;better to include&rdquo; packages should be avoided from installation.&gt; <a href="http://docs.docker.jp/engine/articles/dockerfile_best-practice.html">Dockerfile Best Practices</a></p>
</blockquote>
<p>So I&rsquo;d like to add a Python installation to the Ubuntu image. In practice, I think that pipenv and poetry will be involved, but since it is an article of Docker, I will omit that area.</p>
<p>Although it will be described later in the Dockerfile, the following commands are the minimum required. Before writing in the Dockerfile, try executing them one by one and check that the command can be executed.</p>
<p>[1]. Update the list of installable packages on Ubuntu</p>
<p>When installing Python with the <code>apt-get install</code> command etc., it is necessary to execute it once in advance.</p>
<pre><code>root@762ce425ca58:/# apt-get update
</code></pre><pre><code>Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Get:2 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]
Get:3 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [23.7 kB]
...
Get:17 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [2496 B]
Get:18 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [4241 B]
Fetched 17.5 MB in 58s (303 kB/s)
Reading package lists... Done
</code></pre><p>[2]. Execute command for Python installation</p>
<p>Install without <code>-y</code> specified? do not do? Since it will be asked, I will add the option of <code>-y</code> in consideration of moving to Dockerfile. It takes quite a while, so leave it for a while after execution.</p>
<pre><code>root@762ce425ca58:/# apt-get install -y python3.7 python3.7-dev
</code></pre><pre><code>Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  file libc-dev-bin libc6-dev libexpat1 libexpat1-dev libmagic-mgc libmagic1 libmpdec2 libpython3.7 libpython3.7-dev libpython3.7-minimal
  libpython3.7-stdlib libreadline7 libsqlite3-0 libssl1.1 linux-libc-dev manpages manpages-dev mime-support python3.7-minimal readline-common xz-utils
  zlib1g-dev
...
Setting up python3.7 (3.7.5-2~18.04) ...
Setting up libpython3.7:amd64 (3.7.5-2~18.04) ...
Setting up libpython3.7-dev:amd64 (3.7.5-2~18.04) ...
Setting up python3.7-dev (3.7.5-2~18.04) ...
Processing triggers for libc-bin (2.27-3ubuntu1) ...
</code></pre><p>It seems that he passed without any errors.
To confirm that it is working properly, check the version and run print on the Python interactive shell.</p>
<pre><code>root@762ce425ca58:/# python3.7 -V
</code></pre><pre><code>Python 3.7.5
</code></pre><pre><code>root@762ce425ca58:/# python3.7
</code></pre><pre><code>Python 3.7.5 (default, Nov 7 2019, 10:50:52)
[GCC 8.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</code></pre><pre><code>&gt;&gt;&gt; print('Hello Python!')
Hello Python!
</code></pre><p>It&rsquo;s moving. It doesn&rsquo;t seem to matter.
The commands up to the above are described in the Dockerfile.
To specify a command in the Dockerfile, add RUN at the beginning.
To describe multiple commands, it seems that you can connect multiple RUNs or &amp;&amp;. If you connect with &amp;&amp;, one line becomes long, so add a line break with a backslash (\) etc. to make it easier to see.</p>
<ul>
<li>Regarding the method to describe multiple RUNs, there is a statement that each time you write a RUN, the number of layers of the image increases, and it is a best practice to minimize the number of layers. It seems that writing multiple RUNs makes it easier to read to some extent, but if the number of layers is too large, there are unfavorable points.</li>
</ul>
<blockquote>
<p>Minimize the number of layers
Minimize the readability of the Dockerfile and the number of image layers used. You need to find a balance between the two. Use layers carefully and strategically.
<a href="http://docs.docker.jp/engine/articles/dockerfile_best-practice.html#id5">Dockerfile Best Practices
</a></p>
</blockquote>
<p>‥</p>
<blockquote>
<p>RUN as much as possible
To prevent unnecessary image layers from being created even in RUN, write the necessary processing in one RUN statement as much as possible.
<a href="https://qiita.com/c18t/items/f3a911ef01f124071c95">10 things to keep in mind when writing a Dockerfile</a></p>
</blockquote>
<p>It&rsquo;s a bit of a light investigation, and it seems that performance and capacity are consumed as the number of layers increases.</p>
<blockquote>
<p>Reduction of the number of layers (minimization)
• In older versions of Docker, minimizing the number of image layers was very important to ensure performance.
• Currently, the layer is created and the capacity is consumed only when the RUN COPY ADD command is issued.
<a href="https://www.slideshare.net/zembutsu/explaining-best-practices-for-writing-dockerfiles">Best practices for writing Dockerfiles</a> Quoted from page 33.</p>
</blockquote>
<p>This time, I will write it using &amp;&amp;.</p>
<pre><code class="language-dockerfile:build_test_1\Dockerfile" data-lang="dockerfile:build_test_1\Dockerfile">FROM ubuntu:18.04

RUN apt-get update \
    &amp;&amp; apt-get install -y \
    python3.7 \
    python3.7-dev

</code></pre><p>Building. The version of the tag is switched from <code>1.0.0</code> to <code>1.0.1</code>.</p>
<pre><code>$ docker image build -t ubuntu_build_test_1:1.0.1 ./
</code></pre><p>Somehow some warning came out, but this time I will judge that there is no problem and proceed.</p>
<pre><code>...
debconf: delaying package configuration, since apt-utils is not installed
...
update-alternatives: warning: skip creation of /usr/share/man/man1/lzma.1.gz because associated file /usr/share/man/man1/xz.1.gz (of link group lzma) doesn't exist
...
Successfully built e82c7cfa3b67
Successfully tagged ubuntu_build_test_1:1.0.1
</code></pre><p>Start it up and see if you can use Python. Please note that this also requires switching the tag part to <code>1.0.1</code>.</p>
<pre><code>$ docker container run -it ubuntu_build_test_1:1.0.1 bash
</code></pre><pre><code>root@2902e7eb95df:/# python3.7 -V
</code></pre><pre><code>Python 3.7.5
</code></pre><p>It is properly included. Easy and wonderful&hellip;</p>
<h1 id="set-python-alias-in-dockerfile">Set python alias in Dockerfile</h1>
<p>If you do this, you will have to type <code>python3.7</code> instead of <code>python</code> when running Python.
Since the command of the application will not be changed when the number of inputs increases or the version is changed, if you enter python, make sure that the installed Python starts. Use a Linux alias.</p>
<p>First of all, like before, check the operation on bash before adding to the Dockerfile.
Simply executing the alias command will not enable it when the container is started, so consider adding it to bashrc.
Also, in order to confirm that there is no problem even if you stop and then start it again, once you name the container <code>ubuntu_alias_test</code> and start it.</p>
<pre><code>$ docker container run -it --name ubuntu_alias_test ubuntu_build_test_1:1.0.1 bash
</code></pre><pre><code>root@c2f056bf6daa:/# echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root/.bashrc
root@c2f056bf6daa:/# source /root/.bashrc
</code></pre><p>Make sure you can run the command in python instead of python3.7.</p>
<pre><code>root@c2f056bf6daa:/# python -V
</code></pre><pre><code>Python 3.7.5
</code></pre><p>It looks okay.
Confirm that the alias is working even if you stop the container and then start it again.
Exit the bash with the exit command and stop the container.</p>
<pre><code>root@c2f056bf6daa:/# exit
</code></pre><p>Start again and switch to bash.</p>
<pre><code>$ docker start ubuntu_alias_test$ docker container exec -it ubuntu_alias_test bash
</code></pre><p>Check if the alias is working.</p>
<pre><code>root@c2f056bf6daa:/# python -V
</code></pre><pre><code>Python 3.7.5
</code></pre><p>Since it seems to be okay, I will add the above command to the Dockerfile.</p>
<pre><code class="language-dockerfile:build_test_1\Dockerfile" data-lang="dockerfile:build_test_1\Dockerfile">FROM ubuntu:18.04

RUN apt-get update \
    &amp;&amp; apt-get install -y \
    python3.7 \
    python3.7-dev \
    &amp;&amp; echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root/.bashrc

</code></pre><p>Try to build by increasing the tag version.</p>
<pre><code>$ docker image build -t ubuntu_build_test_1:1.0.2 ./
</code></pre><p>Boot with the built image.</p>
<pre><code>$ docker container run -it ubuntu_build_test_1:1.0.2 bash
</code></pre><p>Check if the alias is working.</p>
<pre><code>root@50c41d6289ca:/# python -V
</code></pre><pre><code>Python 3.7.5
</code></pre><p>It looks okay.</p>
<p>A little more about #tags</p>
<p>Multiple tags can be set for one image.
However, the same tag cannot be attached to multiple images. For example, you cannot tag the latest tag with multiple versions of an image.</p>
<p>I&rsquo;ll give it a try.
We will use two images, <code>ubuntu_build_test_1:1.0.2</code> and <code>ubuntu_build_test_1:1.0.1</code>, which were built by the above process.</p>
<p>To add a tag, execute the command in the format <code>docker tag &lt;image ID&gt; &lt;new image name&gt;:&lt;tag name to add&gt;</code>. If you do not need to change the image name, specify the same value for the <code>&lt;new image name&gt;</code> part.</p>
<p>Check the image ID with the ls command.</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu_build_test_1 1.0.2 f2b89ec36f84 14 minutes ago 241MB
ubuntu_build_test_1 1.0.1 e82c7cfa3b67 12 hours ago 241MB
</code></pre><p>As a test, let&rsquo;s add a tag called latest to the image with the tag of 1.0.1.</p>
<pre><code>$ docker tag e82c7cfa3b67 ubuntu_build_test_1:latest
</code></pre><p>Check the contents again with the ls command.</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu_build_test_1 1.0.2 f2b89ec36f84 17 minutes ago 241MB
ubuntu_build_test_1 1.0.1 e82c7cfa3b67 12 hours ago 241MB
ubuntu_build_test_1 latest e82c7cfa3b67 12 hours ago 241MB
</code></pre><p>Looking at the IMAGE ID column, you can see that there are two rows of images with the same ID, and multiple tags can be set for one image.</p>
<p>Then what happens if you run the command to add the latest tag to images that have an additional 1.0.2 tag set? I&rsquo;ll give it a try.</p>
<pre><code>$ docker tag f2b89ec36f84 ubuntu_build_test_1:latest
</code></pre><pre><code>$ docker image ls
</code></pre><pre><code>ubuntu_build_test_1 1.0.2 f2b89ec36f84 13 hours ago 241MB
ubuntu_build_test_1 latest f2b89ec36f84 13 hours ago 241MB
ubuntu_build_test_1 1.0.1 e82c7cfa3b67 24 hours ago 241MB
</code></pre><p>You can see that the latest tag attached to the image of 1.0.1 has been peeled off. In this way, the same tag cannot be set for multiple images, so the tags set for the older image will be lost.</p>
<h1 id="remove-tag-from-image">Remove tag from image</h1>
<p>To remove tags from an image, use a command in the format <code>docker rmi &lt;image name&gt;:&lt;tag name&gt;</code>.</p>
<p>Let&rsquo;s erase the latest tag.</p>
<pre><code>$ docker rmi ubuntu_build_test_1:latest
</code></pre><pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu_build_test_1 1.0.2 f2b89ec36f84 13 hours ago 241MB
ubuntu_build_test_1 1.0.1 e82c7cfa3b67 24 hours ago 241MB
</code></pre><p>The latest tag attached to the 1.0.2 image has disappeared.</p>
<h1 id="what-happens-if-there-are-no-tags-set-in-the-image">What happens if there are no tags set in the image</h1>
<p>Earlier I removed one tag from an image with two tags, but what if I remove a tag from an image that has only one tag? I will try this as well.</p>
<p>Try to delete the 1.0.1 tag.</p>
<pre><code>$ docker rmi ubuntu_build_test_1:1.0.1
</code></pre><pre><code>Untagged: ubuntu_build_test_1:1.0.1
Deleted: sha256:e82c7cfa3b67a7c1354c7640ce53e0000a1d500176a63d2e86270581c3efbe46
Deleted: sha256:cb5593f33928c36ae1b90ce2fb1c469dbeb49617b100a7ddebf7bd164f7dbacf
</code></pre><p>Let&rsquo;s check what happened.</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu_build_test_1 1.0.2 f2b89ec36f84 24 hours ago 241MB
</code></pre><p>With the <code>rmi</code> command, it seems that the image has disappeared.</p>
<p>Then, what happens when the image is set only with the latest tag and the latest is set for another image (the latest tag is removed)?
To try it, try building an image separately.
If the contents of Dockerfile remain the same, it will be treated as the same image as 1.0.2, so I will temporarily add a meaningless command to the end.</p>
<pre><code class="language-dockerfile:build_test_1\Dockerfile" data-lang="dockerfile:build_test_1\Dockerfile">FROM ubuntu:18.04

RUN apt-get update \
    &amp;&amp; apt-get install -y \
    python3.7 \
    python3.7-dev \
    &amp;&amp; echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root/.bashrc \
    &amp;&amp; echo'temporary'
</code></pre><p>Build with the latest tag.</p>
<pre><code>$ docker image build -t ubuntu_build_test_1:latest ./
</code></pre><p>Confirm with IMAGE ID that the image is different from 1.0.2.</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
ubuntu_build_test_1 latest 734018f9903b 44 seconds ago 241MB
ubuntu_build_test_1 1.0.2 f2b89ec36f84 24 hours ago 241MB
</code></pre><p>Try setting the latest tag on the 1.0.2 side.</p>
<pre><code>$ docker tag f2b89ec36f84 ubuntu_build_test_1:latest
</code></pre><p>Check what happened.</p>
<pre><code>$ docker image ls
</code></pre><pre><code>REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;none&gt; &lt;none&gt; 734018f9903b 8 minutes ago 241MB
ubuntu_build_test_1 1.0.2 f2b89ec36f84 24 hours ago 241MB
ubuntu_build_test_1 latest f2b89ec36f84 24 hours ago 241MB
</code></pre><p>Now the tags and repositories are displayed as <code>&lt;none&gt;</code>.
When the tag is moved to another image and the number of tags is 0, it is not deleted like this but <code>&lt;none&gt;</code> is displayed.</p>
<h1 id="add-pip-to-dockerfileim-going-to-try-out-the-python-library-related-a-little-so-ill-add-pip-related">add pip to DockerfileI&rsquo;m going to try out the Python library related a little, so I&rsquo;ll add pip related.</h1>
<p>As before, check if you can type the command directly in the container.
Also, since I was stumbled by the installation order etc., I will proceed in order from the Ubuntu image and verify it (I&rsquo;m stumbling around here because old information is updated on pip side &hellip;).</p>
<p>*Reference: bow:: <a href="https://qiita.com/sabaku20XX/items/67eb69f006adbbf9c525">Build Python 3.7 + Pipenv environment on Ubuntu 18.04 LTS</a></p>
<pre><code>$ docker container run -it ubuntu:18.04 bash
</code></pre><pre><code>root@d6c0ea41779a:/# apt-get update
root@d6c0ea41779a:/# apt-get install -y python3.7-dev
root@d6c0ea41779a:/# apt-get install -y python3.7
root@d6c0ea41779a:/# apt-get install -y python3-distutils
root@d6c0ea41779a:/# apt-get install -y wget
root@d6c0ea41779a:/# echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root/.bashrc
root@d6c0ea41779a:/# cd tmp/
root@d6c0ea41779a:/# wget https://bootstrap.pypa.io/get-pip.py
root@d6c0ea41779a:/# python3.7 get-pip.py
</code></pre><p>The changes are:</p>
<ul>
<li>Since it went via get-pip.py, I installed wget etc. first.</li>
<li>I was angry at pip installation without python3-distutils, so I installed it after Python 3.7 installation (it was installed on another Python version earlier, it was played at pip installation).</li>
</ul>
<p>Such a place.
I will build it.
Try running it with a command and it seems to be fine, so edit the Dockerfile.</p>
<pre><code class="language-dockerfile:build_test_1\Dockerfile" data-lang="dockerfile:build_test_1\Dockerfile">FROM ubuntu:18.04

RUN apt-get update \
    &amp;&amp; apt-get install -y \
    python3.7-dev \
    python3.7 \
    python3-distutils \
    wget \
    &amp;&amp; echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root/.bashrc \
    &amp;&amp; cd tmp / \
    &amp;&amp; wget https://bootstrap.pypa.io/get-pip.py \
    &amp;&amp; python3.7 get-pip.py

</code></pre><pre><code>$ docker image build -t ubuntu_build_test_1:1.0.3 ./
</code></pre><p>The build itself seems to have passed without problems. However, there are warnings in the process.</p>
<pre><code>WARNING: pip is being invoked by an old script wrapper.This will fail in a future version of pip.
Please see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.
To avoid this problem you can invoke Python with'-m pip' instead of running pip directly.
</code></pre><p>I tried looking at the corresponding link, but it seems that this case can not be solved (if it is via get-pip.py in the first place, it can not be solved by <code>-m pip</code>), and on the net Feeling that I&rsquo;m investigating, almost no information hits, so I will proceed as it is&hellip; (I feel that it will automatically become bad in a future update)</p>
<p>Start it up and try the pip command.</p>
<pre><code>$ docker container run -it ubuntu_build_test_1:1.0.3 bash
</code></pre><pre><code>root@c1beaf56d656:/# pip -V
</code></pre><pre><code>pip 20.0.2 from /usr/local/lib/python3.7/dist-packages/pip (python 3.7)
</code></pre><p>It seems that pip has entered safely. I thought it would be nice to be sophisticated and simple in this area (errors, warnings, new and old information, etc&hellip;).
(Although there are articles about Python environment construction every year, it seems that it is still improving with a similar feeling&hellip;)</p>
<p>#Think about image build cache</p>
<p>I mentioned earlier that the RUN part of the Dockerfile should be put together.
However, there are cases where it is preferable to separate them, and one of them is the cache side of the build.</p>
<p>In the image build process, the description of the Dockerfile is executed in order from the top, and if the contents are the same as the previously executed build halfway, the cache is referenced there and the build shortening is executed.</p>
<p>On the other hand, if RUN commands are put together, if you add a new description to them, it will be necessary to execute the RUN command normally.
Therefore, if you write things that are frequently updated in the lower part of the Dockerfile and separate the RUN command, the daily build will be shortened.</p>
<p>As a trial, add a description to install the library (Django) with another RUN command at the end of the Dockerfile that was updated earlier (this time, skip the library management in requirement.txt etc.).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-docker" data-lang="docker"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> ubuntu:18.04</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> apt-get update <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> apt-get install -y <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    python3.7-dev <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    python3.7 <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    python3-distutils <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    wget <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> echo<span style="color:#e6db74">&#39;alias python=&#34;/usr/bin/python3.7&#34;&#39;</span> &gt;&gt; /root/.bashrc <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> cd tmp / <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> wget https://bootstrap.pypa.io/get-pip.py <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    <span style="color:#f92672">&amp;&amp;</span> python3.7 get-pip.py<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> pip install <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>    Django<span style="color:#f92672">==</span>3.0.2<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>I will build it.</p>
<pre><code>$ docker image build -t ubuntu_build_test_1:1.0.4 ./
</code></pre><pre><code>Sending build context to Docker daemon 2.048kB
Step 1/3: FROM ubuntu:18.04
 ---&gt; ccc6e87d482b
Step 2/3: RUN apt-get update &amp;&amp; apt-get install -y python3.7-dev python3.7 python3-distutils wget &amp;&amp; echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root /.bashrc &amp;&amp; cd tmp / &amp;&amp; wget https://bootstrap.pypa.io/get-pip.py &amp;&amp; python3.7 get-pip.py
 ---&gt; Using cache
 ---&gt; 09019f05baa6
Step 3/3: RUN pip install Django==3.0.2
 ---&gt; Running in e485f302a7f7
Collecting Django==3.0.2
  Downloading Django-3.0.2-py3-none-any.whl (7.4 MB)
Collecting asgiref~=3.2
  Downloading asgiref-3.2.3-py2.py3-none-any.whl (18 kB)
Collecting pytz
  Downloading pytz-2019.3-py2.py3-none-any.whl (509 kB)
Collecting sqlparse&gt;=0.2.2
  Downloading sqlparse-0.3.0-py2.py3-none-any.whl (39 kB)
Installing collected packages: asgiref, pytz, sqlparse, Django
Successfully installed Django-3.0.2 asgiref-3.2.3 pytz-2019.3 sqlparse-0.3.0
Removing intermediate container e485f302a7f7
 ---&gt; 1d076e3f7bb9
Successfully built 1d076e3f7bb9
Successfully tagged ubuntu_build_test_1:1.0.4
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host.All files and directories added to build context will have'-rwxr-xr-x' permissions.It is recommended to double check and reset permissions for sensitive files and directories.
</code></pre><p>The build was completed in a very short time because the contents are the same except the last Django installation.
If you take a closer look at the output when executing the command, you can see that the cache is being used.</p>
<pre><code>...
Step 2/3: RUN apt-get update &amp;&amp; apt-get install -y python3.7-dev python3.7 python3-distutils wget &amp;&amp; echo'alias python=&quot;/usr/bin/python3.7&quot;' &gt;&gt; /root /.bashrc &amp;&amp; cd tmp / &amp;&amp; wget https://bootstrap.pypa.io/get-pip.py &amp;&amp; python3.7 get-pip.py
 ---&gt; Using cache
 ---&gt; 09019f05baa6
...
```In this way, it is not something to forcibly reduce the RUN command etc., for example, &quot;Python and pip versions are updated only occasionally&quot; &quot;Different because the library updates and adds versions at a reasonable frequency&quot; &quot; If you make appropriate adjustments such as &quot;divide the code part&quot;, the build will be comfortable.

# References/Site Summary

- [Docker Deep Dive](https://www.amazon.com/Docker-Deep-Dive-Nigel-Poulton-ebook/dp/B01LXWQUFF/)
- [What is a container? What is Kubernetes? Introduction, operation, use case explanation](https://codezine.jp/article/detail/11336)
- [What is docker exec -it actually doing? [Day 90]](https://www.nyamucoro.com/entry/2018/01/11/224932)
- [Create Docker container, start-stop](https://qiita.com/kooohei/items/0e788a2ce8c30f9dba53)
- [Why we use containers/Docker in 2018](https://cloudpack.media/41647)
- [Delete all [docker] Containers](https://qiita.com/ozhaan/items/9e2090da22ffd6c7ad2a)
- [Start containers automatically](https://docs.docker.com/config/containers/start-containers-automatically/)
- [Table summarizes the differences between Docker restart policies](https://ysk24ok.github.io/2019/08/07/docker_restart_policy.html)
- [How to write and use Dockerfile](https://blog.codecamp.jp/docker-file-how-to)
- [How to write Dockerfile, commands to use, procedure for creating](https://www.wakuwakubank.com/posts/270-docker-build-image/)
- [Dockerfile best practices](http://docs.docker.jp/engine/articles/dockerfile_best-practice.html)
- [Linux Ubuntu — Difference between apt-get update / upgrade](https://qiita.com/YumaInaura/items/dd50ba59c245a0a5f3f1)
- [Build Python3.7 + Pipenv environment on Ubuntu 18.04 LTS](https://qiita.com/sabaku20XX/items/67eb69f006adbbf9c525)
- [fnndsc/ubuntu-python3](https://hub.docker.com/r/fnndsc/ubuntu-python3/dockerfile/)
- [10 things to keep in mind when writing a Dockerfile](https://qiita.com/c18t/items/f3a911ef01f124071c95)
- [Best Practice Guide for Writing Dockerfiles](https://www.slideshare.net/zembutsu/explaining-best-practices-for-writing-dockerfiles)
- [How do I alias python2 to python3 in a docker container?](https://stackoverflow.com/questions/55346068/how-do-i-alias-python2-to-python3-in-a-docker-container)
- [[Docker] How to change image name and tag name](https://sleepless-se.net/2019/04/14/change-docker-image-and-tag-name/)
- [How to add/remove tags in Docker image](https://blog.jnyo.net/post/how-to-remove-tag-from-docker-image/)
- [Install wget](http://programdl.hatenablog.com/entry/2017/11/11/144850)
- [Install Python3, related libraries pip, virtualenv and framework Django, bottle, Flask on CentOS on Docker! With a Dockerfile that summarizes these! ](https://qiita.com/RyosukeKamei/items/eca9687162b7fe122094)
- [Build Python3.7 + Pipenv environment on Ubuntu 18.04 LTS](https://qiita.com/sabaku20XX/items/67eb69f006adbbf9c525)</code></pre>
    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-123456789-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
