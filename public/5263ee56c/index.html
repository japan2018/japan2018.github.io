<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.72.0" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://memotut.com/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://memotut.com/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://memotut.com/favicon-16x16.png">

  
  <link rel="manifest" href="https://memotut.com/site.webmanifest">

  
  <link rel="mask-icon" href="https://memotut.com/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://memotut.com/css/bootstrap.min.css" />

  
  <title>[Python] Comparing basic syntax of Python and Go in an easy-to-understand manner | Memo Tut</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #fff;
}



body {
  color: #212529;
}



a {
  color: #007bff;
}



a:hover,
a:focus {
  color: #0056b3;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>[Python] Comparing basic syntax of Python and Go in an easy-to-understand manner</h1>
<p>
  <small class="text-secondary">
  
  
  Dec 24, 2019
  </small>
  

<small><code><a href="https://memotut.com/tags/python">Python</a></code></small>


<small><code><a href="https://memotut.com/tags/go">Go</a></code></small>

</p>
<pre><code>This article is on December 24 (Tue) of [DeNA Advent Calendar 2019](https://qiita.com/advent-calendar/2019/dena).
</code></pre>
<h2 id="introduction">Introduction</h2>
<p>I usually use Perl, but I put together it for the purpose of learning Go and reviewing Python.
Python&rsquo;s grammar is very simple, so I thought it would be easier to learn Go by the difference.
I&rsquo;ve written as much as possible, but I think there are various shortages. Please note.</p>
<h2 id="comment">Comment</h2>
<p>First, how to write a comment.
Python doesn&rsquo;t originally have the ability to comment out multiple lines, but putting a string in a program has no effect, so you can use it to write a multiple-line comment.
Also, multi-line comments can be left as documentation strings.</p>
<pre><code class="language-python:Python" data-lang="python:Python"># One line comment

'''
Multiple line comment
'''
&quot;&quot;&quot;
Multiple line comment
&quot;&quot;&quot;

def func():
   &quot;&quot;&quot;
   Program description, etc.
   &quot;&quot;&quot;
   
help(func)
print(func.__doc__)
</code></pre><pre><code class="language-go:Go" data-lang="go:Go">// one line comment

/*
Multiple line comment
*/
</code></pre><h2 id="variable-definition">Variable definition</h2>
<p>Python is a dynamically typed language, so there is no need to declare the variable type.</p>
<pre><code class="language-python:Python" data-lang="python:Python">n = 10
name = &quot;hoge&quot;

#Define collectively
x, y, z = 1, 2, 3
a = b = c = 1
</code></pre><p>For Go, you should first pay attention to the first character of the variable name.</p>
<ul>
<li>If the first letter is uppercase, it can be accessed from outside the package.</li>
<li>If the first letter is lowercase, it cannot be accessed from outside the package.</li>
</ul>
<p>This is also true for constants and functions.
Go is a statically typed language, but there are explicit and implicit definitions.</p>
<h5 id="explicit-definition">explicit definition</h5>
<p>Define it as <code>var [variable name] [variable type]</code>.</p>
<pre><code class="language-go:Go" data-lang="go:Go">var n int
n = 1

// define collectively
var x, y, z int
x, y, z = 1, 2, 3

var (
    x, y int
    name string
)
x, y, name = 1, 2, &quot;hoge&quot;

// type declaration and value assignment at the same time
var n int = 1
</code></pre><h5 id="implicit-definition">Implicit definition</h5>
<p>Define it as <code>[variable name] := [value]</code> or <code>var [variable name] = [value]</code>. Assigning a value implicitly infers the type of the variable.</p>
<pre><code class="language-go:Go" data-lang="go:Go">n := 1

// type can be omitted even in the definition using var
var n = 1

// define collectively
x, y, name := 1, 2, &quot;hoge&quot;

var (
    x = 1
    y = 2
    name = &quot;hoge&quot;
)
</code></pre><h2 id="constant">constant</h2>
<p>There is no keyword in Python to define a constant. By convention, capital letters and underscores only represent constants.</p>
<pre><code class="language-python:Python" data-lang="python:Python">PI = 3.14
MAX_NUM = 100
</code></pre><p>Go uses <code>const</code> to define constants. You can use the identifier <code>iota</code> to generate an integer sequence number.
Attempting to change the value of the constant will result in an error.</p>
<pre><code class="language-go:Go" data-lang="go:Go">const Pi = 3.14
const MaxNum = 100

// Define with ()
const (
    Pi = 3.14
    MaxNum = 100
)

const (
    X = iota // 0
    Y // 1
    Z // 2
)

// When specifying the start number
const (
    X = iota + 10 // 10
    Y // 11
    Z // 12
)
</code></pre><h2 id="array">array</h2>
<p>Python lists are very simple to write. The following is the basic usage.</p>
<pre><code class="language-python:Python" data-lang="python:Python">#Definition
numbers = [1, 2, 3]

#Add element
numbers.append(6)
numbers.insert(3, 5) # numbers: [1, 2, 3, 5, 6]

# Element count
len(numbers)

#Delete element
numbers.remove(3) # numbers: [1, 2, 5, 6]
numbers.pop(1) # numbers: [1, 5, 6]
del numbers[0] # numbers: [5, 6]

# Join list
numbers += [3, 4] # numbers: [5, 6, 3, 4]
numbers.extend([1, 2]) # numbers: [5, 6, 3, 4, 1, 2]

# Element search
print(6 in numbers) # True
print(numbers.index(6)) # 1

# Sort list
numbers.sort() # numbers: [1, 2, 3, 4, 5, 6]
numbers.sort(reverse=True) # numbers: [6, 5, 4, 3, 2, 1]
</code></pre><p>The Go array type cannot be expanded or reduced in size. A data structure like a Python list corresponds to a slice in Go.
The <code>append</code> function is often used in slice operations. **For <code>...</code>, see <a href="#Variablearguments">Variable arguments of function</a>. **</p>
<pre><code class="language-go:Go" data-lang="go:Go">// array cannot be resized
array := [3]int{1, 2, 3}
fmt.Println(array[0]) // 1
fmt.Println(array[1:3]) // [2 3]

// slice
n1 := []int{} // n1: []
n2 := make([]int, 0) // n2: []
numbers := []int{1, 2, 3}

// add elements
numbers = append(numbers, 6) // numbers: [1 2 3 6]
numbers = append(numbers[0:3], append([]int{5}, numbers[3:]...)...) // numbers: [1 2 3 5 6]

// Element count
len(numbers)

// remove element
numbers = append(numbers[0:2], numbers[3:]...) // numbers: [1 2 5 6]
numbers = numbers[2:] // numbers: [5 6]

// combine arrays
numbers = append(numbers, []int{3, 4, 1, 2}...) // numbers: [5 6 3 4 1 2]

// element search
// There is no equivalent to Python's index, so write it yourself
fmt.Println(IndexOf(numbers, 6)) // 1

func IndexOf(s []int, n int) int {
    for i, v := range s {
        if n == v {
            return i
        }
    }
    return -1
}

// sort the array
// use sort package
sort.Ints(numbers)
fmt.Println(numbers) // [1 2 3 4 5 6]
sort.Sort(sort.Reverse(sort.IntSlice(numbers)))
fmt.Println(numbers) // [6 5 4 3 2 1]
</code></pre><h2 id="associative-array">Associative array</h2>
<p>Python uses a data structure called a dictionary.</p>
<pre><code class="language-python:Python" data-lang="python:Python">#Definition
dic = {'hoge': 1,'fuga': 2,'piyo': 3}
list1 = [('hoge', 1), ('fuga', 2), ('piyo', 3)]
dic2 = dict(list1) # same as the value of dic
dic['hoge']
dic.get('hoge')

# Add and remove elements
dic['foo'] = 4
dic.setdefault('bar', 5)
dic.pop('hoge') # {'fuga': 2,'piyo': 3,'foo': 4,'bar': 5}
del dic['fuga'], dic['piyo'] # {'foo': 4,'bar': 5}

# Element count
len(dic)

# Check existence of key
'foo' in dic

# Key and value retrieval
list(dic.keys()) # ['foo','bar']
list(dic.values()) # [4, 5]
for k, v in dic.items():
    print(k, v)
</code></pre><p>A Go map is equivalent to a Python dictionary. Define in the following format.
<code>map [key type] element type</code></p>
<pre><code class="language-go:Go" data-lang="go:Go">// definition
dic := map[string]int{&quot;hoge&quot;: 1, &quot;fuga&quot;: 2, &quot;piyo&quot;: 3}
dic2 := make(map[string]int)
fmt.Println(dic) // map[fuga:2 hoge:1 piyo:3]
fmt.Println(dic2) // map[]

// add and remove elements
dic[&quot;foo&quot;] = 4
delete(dic, &quot;hoge&quot;)
fmt.Println(dic) // map[foo:4 fuga:2 piyo:3]

// Element count
len(dic)

// check the existence of the key
_, exist := dic[&quot;foo&quot;]
fmt.Println(exist) // true
if value, exist := dic[&quot;foo&quot;]; exist {
    fmt.Println(value) // 4
}

// key and value retrieval
for k, v := range dic {
    fmt.Println(k, v)
}
</code></pre><h2 id="conditional-branch">Conditional branch</h2>
<p>There is no switch statement in Python. Use <code>if... elif... else</code> instead.
There is also a notation called conditional expression (ternary operator).</p>
<blockquote>
<p>6.12. Conditional Expressions
<a href="https://docs.python.org/ja/3/reference/expressions.html#conditional-expressions">https://docs.python.org/ja/3/reference/expressions.html#conditional-expressions</a></p>
</blockquote>
<p>Logical operators use <code>and</code>,<code>or</code>,<code>not</code>.</p>
<pre><code class="language-python:Python" data-lang="python:Python">x, y = 1, 2
if x&gt; y:
    print('x&gt; y')
elif x &lt;y:
    print('x &lt;y')
else:
    print('x == y')

n = 10
#Conditional expressionresult = &quot;positive&quot; if n &gt;0 else &quot;negative or zero&quot;
</code></pre><p>There are two types of conditional branching in Go, if and switch. You can define a valid variable only in that block by writing if with a simple statement.
There is no ternary operator, but you can write something like that with map.
Logical operators use <code>&amp;&amp;</code>,<code>||</code>,<code>!</code>.</p>
<pre><code class="language-python:Go" data-lang="python:Go">x, y := 1, 2
if x&gt; y {
    fmt.Println(&quot;x&gt; y&quot;)
} else if x &lt;y {
    fmt.Println(&quot;x &lt;y&quot;)
} else {
    fmt.Println(&quot;x == y&quot;)
}

# If with simple sentence
if x, y := 1, 2; x&gt; y {
    fmt.Println(&quot;x&gt; y&quot;)
} else if x &lt;y {
    fmt.Println(&quot;x &lt;y&quot;)
} else {
    fmt.Println(&quot;x == y&quot;)
}

# switch statement
x, y := 1, 2;
switch {
case x&gt; y:
    fmt.Println(&quot;x&gt; y&quot;)
case x &lt;y:
    fmt.Println(&quot;x &lt;y&quot;)
default:
    fmt.Println(&quot;x == y&quot;)
}

n := 10
# Writing like a ternary operator
result := map[bool]string{true: &quot;positive&quot;, false: &quot;negative&quot;}[n&gt; 0]
</code></pre><h2 id="loop">loop</h2>
<p>Python for loops use for and while.</p>
<pre><code class="language-python:Python" data-lang="python:Python">sum = 0
for num in range(1, 11):
    sum += num

num, sum = 1, 0
while num &lt;= 10:
    sum += num
    num += 1

# infinite loop
num, sum = 1, 0
while True:
    sum += num
    num += 1
    if num&gt; 10:
        break
</code></pre><p>Go&rsquo;s loop has only for, but you can control it like while.</p>
<pre><code class="language-go:Go" data-lang="go:Go">sum := 0
for num := 0 ;num &lt;= 10 ;num++ {
    sum += num
}

// while
num, sum := 1, 0
for num &lt;= 10 {
    sum += num
    num++
}

// infinite loop
num, sum := 1, 0
for {
    sum += num
    num++
    if num&gt; 10 {
        break
    }
}
</code></pre><h2 id="function">function</h2>
<p>Python functions are defined with <code>def</code>. The function definition must be written before the function call is executed.
There are the following usages.</p>
<ul>
<li>Argument can have default value</li>
<li>You can call a function with keyword arguments</li>
<li>Variable length arguments can be specified</li>
<li>Can return multiple return values (tuple type)</li>
</ul>
<pre><code class="language-python:Python" data-lang="python:Python">def greet(name=&quot;World&quot;):
    print(&quot;Hello, &quot;+ name)

greet()
greet(&quot;Alice&quot;)
greet(name=&quot;Alice&quot;)

# Variable length variable
def greet(*names):
    for name in names:
        print(&quot;Hello, &quot;+ name)

greet(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;)

# Multiple return values
def cal(a, b):
    add = a + b
    mul = a * b
    return add, mul

add, mul = cal(10, 5)
</code></pre><p>Go functions are defined with <code>func</code>.
<code>func [function name]([argumentdefinition]) [return type] {[function body] }</code>
There are no default or keyword arguments, but they have the following characteristics.</p>
<ul>
<li>Supports multiple return values and varargs, similar to Python</li>
<li>The return value can be given a name in advance. In that case, it is not necessary to describe the value to be returned after return</li>
<li>Statements with the <code>defer</code> keyword are executed when the function ends. If you define multiple, it will be called from the end</li>
</ul>
<h5 id="variable-length-argument">Variable length argument</h5>
<p>The variable length argument of a function is defined as <code>[argument name] ... [argument type]</code>.
And if you pass a slice as a variable length argument, you need to add <code>...</code> after the variable to expand the slice.</p>
<pre><code class="language-go:Go" data-lang="go:Go">func main() {
    add, mul := cal(10, 5)
    fmt.Println(add, mul) // 15 50
    add, mul = calc(10, 5)
    fmt.Println(add, mul) // 15 50

    greet(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;)
    names := []string{&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;}
    greet(names...) // pass slice to varargs

    testDefer() // BDCA
}

// basic form
func cal(a int, b int) (int, int) {
    add := a + b
    mul := a * b
    return add, mul
}

// Named return value
// If the argument types are the same, they can be written together
func calc(a, b int) (add int, mul int) {
    add = a + b
    mul = a * b
    return
}

// Function with no return value
// varargs
func greet(names ...string) {
    for _, name := range names {
        fmt.Println(&quot;Hello,&quot;, name)
    }
}

// defer delay execution
func testDefer() {
    defer fmt.Print(&quot;A&quot;)
    fmt.Print(&quot;B&quot;)
    defer fmt.Print(&quot;C&quot;) // C is output before A
    fmt.Print(&quot;D&quot;)
}
</code></pre><h2 id="exception-handling">Exception handling</h2>
<p>Python uses the <code>try-except</code> syntax to catch and handle exceptions.</p>
<pre><code class="language-python:Python" data-lang="python:Python">def doDivision(x, y):
    try:
        result = x / y
    except Exception as e:
        result = None
        print(&quot;except:&quot; + e.args[0])
    else: # Execute at normal end
        print(&quot;else&quot;)
    finally: # always run on exit
        print(&quot;finally&quot;)
    return result

doDivision(10, 2)
# else
# finally
doDivision(10, 0)
# except:test exception
# finally
</code></pre><p>There is no exception mechanism like <code>try-except</code> in Go. Instead, by utilizing the property that multiple return values of a function can be returned, error detection is realized by returning whether an error has occurred (<code>error interface</code>) as part of the return value.
The <code>error interface</code> is defined as follows.
<a href="https://golang.org/pkg/builtin/#error">https://golang.org/pkg/builtin/#error</a></p>
<pre><code class="language-go:Go's" data-lang="go:Go's">type error interface {
    Error() string
}
</code></pre><p>The following example uses the <code>New</code> function of the <code>errors</code> package to create an <code>error type</code>.
Also, by using <code>defer</code>, you can achieve the same behavior as Python&rsquo;s <code>finally</code>.</p>
<pre><code class="language-go:Go" data-lang="go:Go">package main
import (
    &quot;fmt&quot;
    &quot;errors&quot;
)

func main() {
    _, err := doDivision(10, 2)
    if (err != nil) {
        // error handling
    }
    // defer
    
    _, err = doDivision(10, 0)
    if (err != nil) {
        // error handling
    }
    // error
    // defer
}

func doDivision(i, j int) (result int, err error) (
    defer fmt.Println(&quot;defer&quot;) // always run on exit

    if j == 0 {
        fmt.Println(&quot;error&quot;)
        err = errors.New(&quot;Divided by Zero&quot;)
        return
    }
    result = i / j
    return
}
</code></pre><p>In addition, Go has an error handling mechanism called <code>panic/recover</code>, but I will omit it here.</p>
<h2 id="class">class</h2>
<p>Below is an example of a simple Python class.</p>
<pre><code class="language-python:Python" data-lang="python:Python">class Player:
    def __init__(self, id, name):
        self.id = id
        self.name = name
        self.__hp = 100

    @property
    def hp(self):
        return self.__hp

    def consume_hp(self, num):
        self.__hp -= num
        
player = Player(10001, &quot;Alice&quot;)
print(player.hp) # 100
player.consume_hp(10)
print(player.hp) #90
</code></pre><p>Go doesn&rsquo;t have a Python equivalent for <code>class</code>, but it uses a struct that handles related variables in a similar role.
You can define methods on the structure. Methods, unlike functions, require the receiver type and its variable name.
The following example defines a method called <code>consumeHp</code> for a pointer type called <code>*Player</code>.</p>
<pre><code class="language-go:Go" data-lang="go:Go">// Player type structure
type Player struct{
    ID int
    Name string
    Hp int
}

// constructorfunc newPlayer(id int, name string) Player {
    return Player{ID: id, Name: name, Hp: 100}
}

// *Player type method
func (p *Player) consumeHp(num int) {
    p.Hp -= num
}

func main() {
    p := newPlayer(10001, &quot;Alice&quot;)
    fmt.Println(p.Hp) // 100
    p.consumeHp(10)
    fmt.Println(p.Hp) // 90
}
</code></pre><h2 id="multithread">Multithread</h2>
<p>Lastly, I will write about multithreading a little.
Below is a simple example of creating a thread using the <code>threading</code> module and passing data in a queue.</p>
<pre><code class="language-python:Python" data-lang="python:Python">import threading
import time
from queue import Queue

def worker(a, b, q):
    time.sleep(1)
    result = a + b
    q.put(result) # put an element in the queue
    print(&quot;result:&quot;, result)

q = Queue()
thread = threading.Thread(target=worker, args=(2, 3, q))
thread.start()
thread.join()

print(&quot;main thread&quot;)
result = q.get() # retrieve element from queue
q.task_done()
print(&quot;received:&quot;, result) # received: 5
</code></pre><p>Let&rsquo;s do the same with Go.
In Go, a lightweight thread, goroutine, is implemented to run in parallel. If you write <code>go f(x)</code>, it will start a new goroutine and execute its function.
It uses a data structure called a channel to pass data between goroutines. The channel type name is written as <code>chan [data type]</code>.</p>
<pre><code class="language-go:Go" data-lang="go:Go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func newThread(a, b int, ch chan int) {
    time.Sleep(1000)
    result := a + b
    ch &lt;- result // send data to channel
    fmt.Println(&quot;result:&quot;, result)
}

func main() {
    ch := make(chan int) // create a channel
    go newThread(2, 3, ch) // execute newThread in a new goroutine

    fmt.Println(&quot;main thread&quot;)
    result := &lt;-ch // receive data from channel
    close(ch)
    fmt.Println(&quot;received:&quot;, result) // received: 5
}
</code></pre><h2 id="finally">Finally</h2>
<p>I&rsquo;ve seen the Go grammar while comparing it with Python.
Although Go is a statically typed language, it also has the ease of writing of a dynamically typed language such as Python.
As Go is said to be influenced by various languages, I think anyone who understands C can readily understand pointers and structures in Go.
I couldn&rsquo;t go into detail about goroutine and channel, which are important for concurrency, but I would like to write again next time.</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-169005401-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>
